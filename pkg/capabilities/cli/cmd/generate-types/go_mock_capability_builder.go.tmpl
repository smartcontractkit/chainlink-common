// Code generated by github.com/smartcontractkit/chainlink-common/pkg/capabilities/cli, DO NOT EDIT.

package {{.Package}}test
import (
    "github.com/smartcontractkit/chainlink-common/pkg/workflows/testutils"
{{- if not (and (.RootType.Ref) (and .Input .Input.Ref)) }}
    "{{.FullPackage}}"
{{- end }}

{{- range .ExtraImports }}
    {{.}}
{{- end }}
)

{{- $fn_type := "func(" }}
{{- $input_type := "struct{}" -}}
{{ if .Input }}
    {{- if .Input.Ref -}}
        {{ $input_type = printf "%s.%s" .Input.RefPkg .Input.Name -}}
    {{- else -}}
        {{ $input_type = printf "%s.%s" .Package .Input.Name -}}
    {{- end -}}
    {{- if eq .CapabilityType "consensus" -}}
        {{$input_type = printf "[]%s" $input_type}}
    {{- end -}}
{{- end }}

{{- $output_type := "struct{}" -}}
{{- if ne .CapabilityType "target" }}
    {{- if .RootType.Ref -}}
        {{ $output_type = printf .RootType.Name -}}
    {{- else -}}
        {{ $output_type = printf "%s.%s" .Package .RootType.Name -}}
    {{- end -}}
    {{- $output_type = printf "%s%s" (Repeat "[]" .RootNumSlice) $output_type -}}
{{- end }}



{{- if .Input -}}
{{ $fn_type = printf "%sinput %s" $fn_type  $input_type }}
{{- end -}}
{{ $fn_type = printf "%s)" $fn_type -}}
{{- if eq .CapabilityType "target" -}}
{{ $fn_type = printf "%s error" $fn_type}}
{{- else -}}
{{ $fn_type = printf "%s (%s, error)" $fn_type $output_type}}
{{- end }}

// {{.BaseName}} registers a new capability mock with the runner
{{- if eq .CapabilityType "action" }}
// if another mock is registered for the same capability with for a step, it will take priority for that step.
{{- end }}
func {{.BaseName}}(runner *testutils.Runner {{- if not .ID }}, id string {{- end }}, fn {{$fn_type}}) *testutils.{{- if eq .CapabilityType "trigger" }}TriggerMock[{{$output_type}}]{{- else if eq .CapabilityType "target"}}TargetMock[{{$input_type}}]{{- else }}Mock[{{$input_type}},{{$output_type}}]{{- end }}{
    mock := testutils.Mock{{- if eq .CapabilityType "trigger" }}Trigger[{{$output_type}}]{{- else if eq .CapabilityType "target"}}Target[{{$input_type}}]{{- else }}Capability[{{$input_type}},{{$output_type}}]{{- end }}({{- if .ID }} "{{.ID}}" {{- else }} id {{- end }}, fn)
    runner.MockCapability({{- if .ID }} "{{.ID}}" {{- else }} id {{- end }}, nil, mock)
    return mock
}

{{- if eq .CapabilityType "action" }}
// {{.BaseName}}ForStep registers a new capability mock with the runner, but only for a given step.
// if another mock was registered for the same capability without a step, this mock will take priority for that step.
func {{.BaseName}}ForStep(runner *testutils.Runner {{- if not .ID }}, id string {{- end }}, step string, mockFn {{$fn_type}}) *testutils.Mock[{{$input_type}},{{$output_type}}]{
    {{- if eq .CapabilityType "target" }}
    fn := func(i {{$input_type}}) (struct{}, error) {
        return struct{}{}, mockFn(i)
    }
    {{- else }}
    fn := mockFn
    {{- end }}
    mock := testutils.MockCapability[{{$input_type}},{{$output_type}}]({{- if .ID }} "{{.ID}}" {{- else }} id {{- end }}, fn)
    runner.MockCapability({{- if .ID }} "{{.ID}}" {{- else }} id {{- end }}, &step, mock)
    return mock
}
{{- end }}