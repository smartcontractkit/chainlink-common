// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: arbiter.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Arbiter_GetDesiredReplicas_FullMethodName = "/ring.Arbiter/GetDesiredReplicas"
)

// ArbiterClient is the client API for Arbiter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ArbiterClient interface {
	GetDesiredReplicas(ctx context.Context, in *ShardStatusRequest, opts ...grpc.CallOption) (*ArbiterResponse, error)
}

type arbiterClient struct {
	cc grpc.ClientConnInterface
}

func NewArbiterClient(cc grpc.ClientConnInterface) ArbiterClient {
	return &arbiterClient{cc}
}

func (c *arbiterClient) GetDesiredReplicas(ctx context.Context, in *ShardStatusRequest, opts ...grpc.CallOption) (*ArbiterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ArbiterResponse)
	err := c.cc.Invoke(ctx, Arbiter_GetDesiredReplicas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ArbiterServer is the server API for Arbiter service.
// All implementations must embed UnimplementedArbiterServer
// for forward compatibility.
type ArbiterServer interface {
	GetDesiredReplicas(context.Context, *ShardStatusRequest) (*ArbiterResponse, error)
	mustEmbedUnimplementedArbiterServer()
}

// UnimplementedArbiterServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedArbiterServer struct{}

func (UnimplementedArbiterServer) GetDesiredReplicas(context.Context, *ShardStatusRequest) (*ArbiterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDesiredReplicas not implemented")
}
func (UnimplementedArbiterServer) mustEmbedUnimplementedArbiterServer() {}
func (UnimplementedArbiterServer) testEmbeddedByValue()                 {}

// UnsafeArbiterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ArbiterServer will
// result in compilation errors.
type UnsafeArbiterServer interface {
	mustEmbedUnimplementedArbiterServer()
}

func RegisterArbiterServer(s grpc.ServiceRegistrar, srv ArbiterServer) {
	// If the following call pancis, it indicates UnimplementedArbiterServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Arbiter_ServiceDesc, srv)
}

func _Arbiter_GetDesiredReplicas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShardStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArbiterServer).GetDesiredReplicas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Arbiter_GetDesiredReplicas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArbiterServer).GetDesiredReplicas(ctx, req.(*ShardStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Arbiter_ServiceDesc is the grpc.ServiceDesc for Arbiter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Arbiter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ring.Arbiter",
	HandlerType: (*ArbiterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDesiredReplicas",
			Handler:    _Arbiter_GetDesiredReplicas_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "arbiter.proto",
}

const (
	ArbiterScaler_Status_FullMethodName              = "/ring.ArbiterScaler/Status"
	ArbiterScaler_ConsensusWantShards_FullMethodName = "/ring.ArbiterScaler/ConsensusWantShards"
)

// ArbiterScalerClient is the client API for ArbiterScaler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ArbiterScalerClient interface {
	Status(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ReplicaStatus, error)
	ConsensusWantShards(ctx context.Context, in *ConsensusWantShardsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type arbiterScalerClient struct {
	cc grpc.ClientConnInterface
}

func NewArbiterScalerClient(cc grpc.ClientConnInterface) ArbiterScalerClient {
	return &arbiterScalerClient{cc}
}

func (c *arbiterScalerClient) Status(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ReplicaStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReplicaStatus)
	err := c.cc.Invoke(ctx, ArbiterScaler_Status_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arbiterScalerClient) ConsensusWantShards(ctx context.Context, in *ConsensusWantShardsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ArbiterScaler_ConsensusWantShards_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ArbiterScalerServer is the server API for ArbiterScaler service.
// All implementations must embed UnimplementedArbiterScalerServer
// for forward compatibility.
type ArbiterScalerServer interface {
	Status(context.Context, *emptypb.Empty) (*ReplicaStatus, error)
	ConsensusWantShards(context.Context, *ConsensusWantShardsRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedArbiterScalerServer()
}

// UnimplementedArbiterScalerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedArbiterScalerServer struct{}

func (UnimplementedArbiterScalerServer) Status(context.Context, *emptypb.Empty) (*ReplicaStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedArbiterScalerServer) ConsensusWantShards(context.Context, *ConsensusWantShardsRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConsensusWantShards not implemented")
}
func (UnimplementedArbiterScalerServer) mustEmbedUnimplementedArbiterScalerServer() {}
func (UnimplementedArbiterScalerServer) testEmbeddedByValue()                       {}

// UnsafeArbiterScalerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ArbiterScalerServer will
// result in compilation errors.
type UnsafeArbiterScalerServer interface {
	mustEmbedUnimplementedArbiterScalerServer()
}

func RegisterArbiterScalerServer(s grpc.ServiceRegistrar, srv ArbiterScalerServer) {
	// If the following call pancis, it indicates UnimplementedArbiterScalerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ArbiterScaler_ServiceDesc, srv)
}

func _ArbiterScaler_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArbiterScalerServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ArbiterScaler_Status_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArbiterScalerServer).Status(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArbiterScaler_ConsensusWantShards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConsensusWantShardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArbiterScalerServer).ConsensusWantShards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ArbiterScaler_ConsensusWantShards_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArbiterScalerServer).ConsensusWantShards(ctx, req.(*ConsensusWantShardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ArbiterScaler_ServiceDesc is the grpc.ServiceDesc for ArbiterScaler service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ArbiterScaler_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ring.ArbiterScaler",
	HandlerType: (*ArbiterScalerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _ArbiterScaler_Status_Handler,
		},
		{
			MethodName: "ConsensusWantShards",
			Handler:    _ArbiterScaler_ConsensusWantShards_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "arbiter.proto",
}
