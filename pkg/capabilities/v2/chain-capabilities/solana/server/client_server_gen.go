// Code generated by github.com/smartcontractkit/chainlink-common/pkg/capabilities/v2/protoc, DO NOT EDIT.

package server

import (
	"context"
	"fmt"
	"strconv"
	"time"

	"github.com/smartcontractkit/chainlink-common/pkg/capabilities/v2/chain-capabilities/solana"
	"google.golang.org/protobuf/types/known/emptypb"

	"github.com/smartcontractkit/chainlink-common/pkg/capabilities"
	caperrors "github.com/smartcontractkit/chainlink-common/pkg/capabilities/errors"
	"github.com/smartcontractkit/chainlink-common/pkg/types/core"
)

// Avoid unused imports if there is configuration type
var _ = emptypb.Empty{}

type ClientCapability interface {
	GetAccountInfoWithOpts(ctx context.Context, metadata capabilities.RequestMetadata, input *solana.GetAccountInfoWithOptsRequest) (*capabilities.ResponseAndMetadata[*solana.GetAccountInfoWithOptsReply], caperrors.Error)

	GetBalance(ctx context.Context, metadata capabilities.RequestMetadata, input *solana.GetBalanceRequest) (*capabilities.ResponseAndMetadata[*solana.GetBalanceReply], caperrors.Error)

	GetBlock(ctx context.Context, metadata capabilities.RequestMetadata, input *solana.GetBlockRequest) (*capabilities.ResponseAndMetadata[*solana.GetBlockReply], caperrors.Error)

	GetFeeForMessage(ctx context.Context, metadata capabilities.RequestMetadata, input *solana.GetFeeForMessageRequest) (*capabilities.ResponseAndMetadata[*solana.GetFeeForMessageReply], caperrors.Error)

	GetMultipleAccountsWithOpts(ctx context.Context, metadata capabilities.RequestMetadata, input *solana.GetMultipleAccountsWithOptsRequest) (*capabilities.ResponseAndMetadata[*solana.GetMultipleAccountsWithOptsReply], caperrors.Error)

	GetSignatureStatuses(ctx context.Context, metadata capabilities.RequestMetadata, input *solana.GetSignatureStatusesRequest) (*capabilities.ResponseAndMetadata[*solana.GetSignatureStatusesReply], caperrors.Error)

	GetSlotHeight(ctx context.Context, metadata capabilities.RequestMetadata, input *solana.GetSlotHeightRequest) (*capabilities.ResponseAndMetadata[*solana.GetSlotHeightReply], caperrors.Error)

	GetTransaction(ctx context.Context, metadata capabilities.RequestMetadata, input *solana.GetTransactionRequest) (*capabilities.ResponseAndMetadata[*solana.GetTransactionReply], caperrors.Error)

	RegisterLogTrigger(ctx context.Context, triggerID string, metadata capabilities.RequestMetadata, input *solana.FilterLogTriggerRequest) (<-chan capabilities.TriggerAndId[*solana.Log], caperrors.Error)
	UnregisterLogTrigger(ctx context.Context, triggerID string, metadata capabilities.RequestMetadata, input *solana.FilterLogTriggerRequest) caperrors.Error

	WriteReport(ctx context.Context, metadata capabilities.RequestMetadata, input *solana.WriteReportRequest) (*capabilities.ResponseAndMetadata[*solana.WriteReportReply], caperrors.Error)
	AckEvent(ctx context.Context, triggerId string, eventId string, method string) caperrors.Error

	ChainSelector() uint64

	Start(ctx context.Context) error
	Close() error
	HealthReport() map[string]error
	Name() string
	Description() string
	Ready() error
	Initialise(ctx context.Context, dependencies core.StandardCapabilitiesDependencies) error
}

func NewClientServer(capability ClientCapability) *ClientServer {
	stopCh := make(chan struct{})
	return &ClientServer{
		clientCapability: clientCapability{ClientCapability: capability, stopCh: stopCh},
		stopCh:           stopCh,
	}
}

type ClientServer struct {
	clientCapability
	capabilityRegistry core.CapabilitiesRegistry
	stopCh             chan struct{}
}

func (c *ClientServer) Initialise(ctx context.Context, dependencies core.StandardCapabilitiesDependencies) error {
	if err := c.ClientCapability.Initialise(ctx, dependencies); err != nil {
		return fmt.Errorf("error when initializing capability: %w", err)
	}

	c.capabilityRegistry = dependencies.CapabilityRegistry

	if err := dependencies.CapabilityRegistry.Add(ctx, &clientCapability{
		ClientCapability: c.ClientCapability,
	}); err != nil {
		return fmt.Errorf("error when adding %s to the registry: %w", "solana"+":ChainSelector:"+strconv.FormatUint(c.ChainSelector(), 10)+"@1.0.0", err)
	}

	return nil
}

func (c *ClientServer) Close() error {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()

	if c.capabilityRegistry != nil {
		if err := c.capabilityRegistry.Remove(ctx, "solana"+":ChainSelector:"+strconv.FormatUint(c.ChainSelector(), 10)+"@1.0.0"); err != nil {
			return err
		}
	}

	if c.stopCh != nil {
		close(c.stopCh)
	}

	return c.clientCapability.Close()
}

func (c *ClientServer) Infos(ctx context.Context) ([]capabilities.CapabilityInfo, error) {
	info, err := c.clientCapability.Info(ctx)
	if err != nil {
		return nil, err
	}
	return []capabilities.CapabilityInfo{info}, nil
}

type clientCapability struct {
	ClientCapability
	stopCh chan struct{}
}

func (c *clientCapability) Info(ctx context.Context) (capabilities.CapabilityInfo, error) {
	// Maybe we do need to split it out, even if the user doesn't see it
	return capabilities.NewCapabilityInfo("solana"+":ChainSelector:"+strconv.FormatUint(c.ChainSelector(), 10)+"@1.0.0", capabilities.CapabilityTypeCombined, c.ClientCapability.Description())
}

var _ capabilities.ExecutableAndTriggerCapability = (*clientCapability)(nil)

const ClientID = "solana@1.0.0"

func (c *clientCapability) RegisterTrigger(ctx context.Context, request capabilities.TriggerRegistrationRequest) (<-chan capabilities.TriggerResponse, error) {
	switch request.Method {
	case "LogTrigger":
		input := &solana.FilterLogTriggerRequest{}
		return capabilities.RegisterTrigger(ctx, c.stopCh, "solana"+":ChainSelector:"+strconv.FormatUint(c.ChainSelector(), 10)+"@1.0.0", request, input, c.ClientCapability.RegisterLogTrigger)
	default:
		return nil, fmt.Errorf("trigger %s not found", request.Method)
	}
}

func (c *clientCapability) UnregisterTrigger(ctx context.Context, request capabilities.TriggerRegistrationRequest) error {
	switch request.Method {
	case "LogTrigger":
		input := &solana.FilterLogTriggerRequest{}
		_, err := capabilities.FromValueOrAny(request.Config, request.Payload, input)
		if err != nil {
			return err
		}
		return c.ClientCapability.UnregisterLogTrigger(ctx, request.TriggerID, request.Metadata, input)
	default:
		return fmt.Errorf("method %s not found", request.Method)
	}
}

func (c *clientCapability) AckEvent(ctx context.Context, triggerId string, eventId string, method string) error {
	switch method {
	case "LogTrigger":
		return c.ClientCapability.AckEvent(ctx, triggerId, eventId, method)
	default:
		return fmt.Errorf("trigger %s not found", method)
	}
}

func (c *clientCapability) RegisterToWorkflow(ctx context.Context, request capabilities.RegisterToWorkflowRequest) error {
	return nil
}

func (c *clientCapability) UnregisterFromWorkflow(ctx context.Context, request capabilities.UnregisterFromWorkflowRequest) error {
	return nil
}

func (c *clientCapability) Execute(ctx context.Context, request capabilities.CapabilityRequest) (capabilities.CapabilityResponse, error) {
	response := capabilities.CapabilityResponse{}
	switch request.Method {
	case "GetAccountInfoWithOpts":
		input := &solana.GetAccountInfoWithOptsRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *solana.GetAccountInfoWithOptsRequest, _ *emptypb.Empty) (*solana.GetAccountInfoWithOptsReply, capabilities.ResponseMetadata, error) {
			output, err := c.ClientCapability.GetAccountInfoWithOpts(ctx, metadata, input)
			if err != nil {
				return nil, capabilities.ResponseMetadata{}, err
			}
			if output == nil {
				return nil, capabilities.ResponseMetadata{}, fmt.Errorf("output and error is nil for method GetAccountInfoWithOpts(..) (if output is nil error must be present)")
			}
			return output.Response, output.ResponseMetadata, err
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	case "GetBalance":
		input := &solana.GetBalanceRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *solana.GetBalanceRequest, _ *emptypb.Empty) (*solana.GetBalanceReply, capabilities.ResponseMetadata, error) {
			output, err := c.ClientCapability.GetBalance(ctx, metadata, input)
			if err != nil {
				return nil, capabilities.ResponseMetadata{}, err
			}
			if output == nil {
				return nil, capabilities.ResponseMetadata{}, fmt.Errorf("output and error is nil for method GetBalance(..) (if output is nil error must be present)")
			}
			return output.Response, output.ResponseMetadata, err
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	case "GetBlock":
		input := &solana.GetBlockRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *solana.GetBlockRequest, _ *emptypb.Empty) (*solana.GetBlockReply, capabilities.ResponseMetadata, error) {
			output, err := c.ClientCapability.GetBlock(ctx, metadata, input)
			if err != nil {
				return nil, capabilities.ResponseMetadata{}, err
			}
			if output == nil {
				return nil, capabilities.ResponseMetadata{}, fmt.Errorf("output and error is nil for method GetBlock(..) (if output is nil error must be present)")
			}
			return output.Response, output.ResponseMetadata, err
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	case "GetFeeForMessage":
		input := &solana.GetFeeForMessageRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *solana.GetFeeForMessageRequest, _ *emptypb.Empty) (*solana.GetFeeForMessageReply, capabilities.ResponseMetadata, error) {
			output, err := c.ClientCapability.GetFeeForMessage(ctx, metadata, input)
			if err != nil {
				return nil, capabilities.ResponseMetadata{}, err
			}
			if output == nil {
				return nil, capabilities.ResponseMetadata{}, fmt.Errorf("output and error is nil for method GetFeeForMessage(..) (if output is nil error must be present)")
			}
			return output.Response, output.ResponseMetadata, err
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	case "GetMultipleAccountsWithOpts":
		input := &solana.GetMultipleAccountsWithOptsRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *solana.GetMultipleAccountsWithOptsRequest, _ *emptypb.Empty) (*solana.GetMultipleAccountsWithOptsReply, capabilities.ResponseMetadata, error) {
			output, err := c.ClientCapability.GetMultipleAccountsWithOpts(ctx, metadata, input)
			if err != nil {
				return nil, capabilities.ResponseMetadata{}, err
			}
			if output == nil {
				return nil, capabilities.ResponseMetadata{}, fmt.Errorf("output and error is nil for method GetMultipleAccountsWithOpts(..) (if output is nil error must be present)")
			}
			return output.Response, output.ResponseMetadata, err
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	case "GetSignatureStatuses":
		input := &solana.GetSignatureStatusesRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *solana.GetSignatureStatusesRequest, _ *emptypb.Empty) (*solana.GetSignatureStatusesReply, capabilities.ResponseMetadata, error) {
			output, err := c.ClientCapability.GetSignatureStatuses(ctx, metadata, input)
			if err != nil {
				return nil, capabilities.ResponseMetadata{}, err
			}
			if output == nil {
				return nil, capabilities.ResponseMetadata{}, fmt.Errorf("output and error is nil for method GetSignatureStatuses(..) (if output is nil error must be present)")
			}
			return output.Response, output.ResponseMetadata, err
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	case "GetSlotHeight":
		input := &solana.GetSlotHeightRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *solana.GetSlotHeightRequest, _ *emptypb.Empty) (*solana.GetSlotHeightReply, capabilities.ResponseMetadata, error) {
			output, err := c.ClientCapability.GetSlotHeight(ctx, metadata, input)
			if err != nil {
				return nil, capabilities.ResponseMetadata{}, err
			}
			if output == nil {
				return nil, capabilities.ResponseMetadata{}, fmt.Errorf("output and error is nil for method GetSlotHeight(..) (if output is nil error must be present)")
			}
			return output.Response, output.ResponseMetadata, err
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	case "GetTransaction":
		input := &solana.GetTransactionRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *solana.GetTransactionRequest, _ *emptypb.Empty) (*solana.GetTransactionReply, capabilities.ResponseMetadata, error) {
			output, err := c.ClientCapability.GetTransaction(ctx, metadata, input)
			if err != nil {
				return nil, capabilities.ResponseMetadata{}, err
			}
			if output == nil {
				return nil, capabilities.ResponseMetadata{}, fmt.Errorf("output and error is nil for method GetTransaction(..) (if output is nil error must be present)")
			}
			return output.Response, output.ResponseMetadata, err
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	case "WriteReport":
		input := &solana.WriteReportRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *solana.WriteReportRequest, _ *emptypb.Empty) (*solana.WriteReportReply, capabilities.ResponseMetadata, error) {
			output, err := c.ClientCapability.WriteReport(ctx, metadata, input)
			if err != nil {
				return nil, capabilities.ResponseMetadata{}, err
			}
			if output == nil {
				return nil, capabilities.ResponseMetadata{}, fmt.Errorf("output and error is nil for method WriteReport(..) (if output is nil error must be present)")
			}
			return output.Response, output.ResponseMetadata, err
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	default:
		return response, fmt.Errorf("method %s not found", request.Method)
	}
}
