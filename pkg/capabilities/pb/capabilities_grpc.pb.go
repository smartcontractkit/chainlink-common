// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.1
// source: capabilities/pb/capabilities.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	BaseCapability_Info_FullMethodName = "/capabilities.BaseCapability/Info"
)

// BaseCapabilityClient is the client API for BaseCapability service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BaseCapabilityClient interface {
	Info(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CapabilityInfoReply, error)
}

type baseCapabilityClient struct {
	cc grpc.ClientConnInterface
}

func NewBaseCapabilityClient(cc grpc.ClientConnInterface) BaseCapabilityClient {
	return &baseCapabilityClient{cc}
}

func (c *baseCapabilityClient) Info(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CapabilityInfoReply, error) {
	out := new(CapabilityInfoReply)
	err := c.cc.Invoke(ctx, BaseCapability_Info_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BaseCapabilityServer is the server API for BaseCapability service.
// All implementations must embed UnimplementedBaseCapabilityServer
// for forward compatibility
type BaseCapabilityServer interface {
	Info(context.Context, *emptypb.Empty) (*CapabilityInfoReply, error)
	mustEmbedUnimplementedBaseCapabilityServer()
}

// UnimplementedBaseCapabilityServer must be embedded to have forward compatible implementations.
type UnimplementedBaseCapabilityServer struct {
}

func (UnimplementedBaseCapabilityServer) Info(context.Context, *emptypb.Empty) (*CapabilityInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Info not implemented")
}
func (UnimplementedBaseCapabilityServer) mustEmbedUnimplementedBaseCapabilityServer() {}

// UnsafeBaseCapabilityServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BaseCapabilityServer will
// result in compilation errors.
type UnsafeBaseCapabilityServer interface {
	mustEmbedUnimplementedBaseCapabilityServer()
}

func RegisterBaseCapabilityServer(s grpc.ServiceRegistrar, srv BaseCapabilityServer) {
	s.RegisterService(&BaseCapability_ServiceDesc, srv)
}

func _BaseCapability_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseCapabilityServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BaseCapability_Info_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseCapabilityServer).Info(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// BaseCapability_ServiceDesc is the grpc.ServiceDesc for BaseCapability service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BaseCapability_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "capabilities.BaseCapability",
	HandlerType: (*BaseCapabilityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Info",
			Handler:    _BaseCapability_Info_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "capabilities/pb/capabilities.proto",
}

const (
	TriggerExecutable_RegisterTrigger_FullMethodName   = "/capabilities.TriggerExecutable/RegisterTrigger"
	TriggerExecutable_UnregisterTrigger_FullMethodName = "/capabilities.TriggerExecutable/UnregisterTrigger"
)

// TriggerExecutableClient is the client API for TriggerExecutable service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TriggerExecutableClient interface {
	RegisterTrigger(ctx context.Context, in *TriggerRegistrationRequest, opts ...grpc.CallOption) (TriggerExecutable_RegisterTriggerClient, error)
	UnregisterTrigger(ctx context.Context, in *TriggerRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type triggerExecutableClient struct {
	cc grpc.ClientConnInterface
}

func NewTriggerExecutableClient(cc grpc.ClientConnInterface) TriggerExecutableClient {
	return &triggerExecutableClient{cc}
}

func (c *triggerExecutableClient) RegisterTrigger(ctx context.Context, in *TriggerRegistrationRequest, opts ...grpc.CallOption) (TriggerExecutable_RegisterTriggerClient, error) {
	stream, err := c.cc.NewStream(ctx, &TriggerExecutable_ServiceDesc.Streams[0], TriggerExecutable_RegisterTrigger_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &triggerExecutableRegisterTriggerClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TriggerExecutable_RegisterTriggerClient interface {
	Recv() (*TriggerResponseMessage, error)
	grpc.ClientStream
}

type triggerExecutableRegisterTriggerClient struct {
	grpc.ClientStream
}

func (x *triggerExecutableRegisterTriggerClient) Recv() (*TriggerResponseMessage, error) {
	m := new(TriggerResponseMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *triggerExecutableClient) UnregisterTrigger(ctx context.Context, in *TriggerRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TriggerExecutable_UnregisterTrigger_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TriggerExecutableServer is the server API for TriggerExecutable service.
// All implementations must embed UnimplementedTriggerExecutableServer
// for forward compatibility
type TriggerExecutableServer interface {
	RegisterTrigger(*TriggerRegistrationRequest, TriggerExecutable_RegisterTriggerServer) error
	UnregisterTrigger(context.Context, *TriggerRegistrationRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedTriggerExecutableServer()
}

// UnimplementedTriggerExecutableServer must be embedded to have forward compatible implementations.
type UnimplementedTriggerExecutableServer struct {
}

func (UnimplementedTriggerExecutableServer) RegisterTrigger(*TriggerRegistrationRequest, TriggerExecutable_RegisterTriggerServer) error {
	return status.Errorf(codes.Unimplemented, "method RegisterTrigger not implemented")
}
func (UnimplementedTriggerExecutableServer) UnregisterTrigger(context.Context, *TriggerRegistrationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterTrigger not implemented")
}
func (UnimplementedTriggerExecutableServer) mustEmbedUnimplementedTriggerExecutableServer() {}

// UnsafeTriggerExecutableServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TriggerExecutableServer will
// result in compilation errors.
type UnsafeTriggerExecutableServer interface {
	mustEmbedUnimplementedTriggerExecutableServer()
}

func RegisterTriggerExecutableServer(s grpc.ServiceRegistrar, srv TriggerExecutableServer) {
	s.RegisterService(&TriggerExecutable_ServiceDesc, srv)
}

func _TriggerExecutable_RegisterTrigger_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TriggerRegistrationRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TriggerExecutableServer).RegisterTrigger(m, &triggerExecutableRegisterTriggerServer{stream})
}

type TriggerExecutable_RegisterTriggerServer interface {
	Send(*TriggerResponseMessage) error
	grpc.ServerStream
}

type triggerExecutableRegisterTriggerServer struct {
	grpc.ServerStream
}

func (x *triggerExecutableRegisterTriggerServer) Send(m *TriggerResponseMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _TriggerExecutable_UnregisterTrigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TriggerRegistrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerExecutableServer).UnregisterTrigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerExecutable_UnregisterTrigger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerExecutableServer).UnregisterTrigger(ctx, req.(*TriggerRegistrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TriggerExecutable_ServiceDesc is the grpc.ServiceDesc for TriggerExecutable service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TriggerExecutable_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "capabilities.TriggerExecutable",
	HandlerType: (*TriggerExecutableServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UnregisterTrigger",
			Handler:    _TriggerExecutable_UnregisterTrigger_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RegisterTrigger",
			Handler:       _TriggerExecutable_RegisterTrigger_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "capabilities/pb/capabilities.proto",
}

const (
	Executable_RegisterToWorkflow_FullMethodName     = "/capabilities.Executable/RegisterToWorkflow"
	Executable_UnregisterFromWorkflow_FullMethodName = "/capabilities.Executable/UnregisterFromWorkflow"
	Executable_Execute_FullMethodName                = "/capabilities.Executable/Execute"
)

// ExecutableClient is the client API for Executable service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ExecutableClient interface {
	RegisterToWorkflow(ctx context.Context, in *RegisterToWorkflowRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UnregisterFromWorkflow(ctx context.Context, in *UnregisterFromWorkflowRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Execute(ctx context.Context, in *CapabilityRequest, opts ...grpc.CallOption) (Executable_ExecuteClient, error)
}

type executableClient struct {
	cc grpc.ClientConnInterface
}

func NewExecutableClient(cc grpc.ClientConnInterface) ExecutableClient {
	return &executableClient{cc}
}

func (c *executableClient) RegisterToWorkflow(ctx context.Context, in *RegisterToWorkflowRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Executable_RegisterToWorkflow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executableClient) UnregisterFromWorkflow(ctx context.Context, in *UnregisterFromWorkflowRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Executable_UnregisterFromWorkflow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executableClient) Execute(ctx context.Context, in *CapabilityRequest, opts ...grpc.CallOption) (Executable_ExecuteClient, error) {
	stream, err := c.cc.NewStream(ctx, &Executable_ServiceDesc.Streams[0], Executable_Execute_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &executableExecuteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Executable_ExecuteClient interface {
	Recv() (*CapabilityResponse, error)
	grpc.ClientStream
}

type executableExecuteClient struct {
	grpc.ClientStream
}

func (x *executableExecuteClient) Recv() (*CapabilityResponse, error) {
	m := new(CapabilityResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ExecutableServer is the server API for Executable service.
// All implementations must embed UnimplementedExecutableServer
// for forward compatibility
type ExecutableServer interface {
	RegisterToWorkflow(context.Context, *RegisterToWorkflowRequest) (*emptypb.Empty, error)
	UnregisterFromWorkflow(context.Context, *UnregisterFromWorkflowRequest) (*emptypb.Empty, error)
	Execute(*CapabilityRequest, Executable_ExecuteServer) error
	mustEmbedUnimplementedExecutableServer()
}

// UnimplementedExecutableServer must be embedded to have forward compatible implementations.
type UnimplementedExecutableServer struct {
}

func (UnimplementedExecutableServer) RegisterToWorkflow(context.Context, *RegisterToWorkflowRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterToWorkflow not implemented")
}
func (UnimplementedExecutableServer) UnregisterFromWorkflow(context.Context, *UnregisterFromWorkflowRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterFromWorkflow not implemented")
}
func (UnimplementedExecutableServer) Execute(*CapabilityRequest, Executable_ExecuteServer) error {
	return status.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (UnimplementedExecutableServer) mustEmbedUnimplementedExecutableServer() {}

// UnsafeExecutableServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExecutableServer will
// result in compilation errors.
type UnsafeExecutableServer interface {
	mustEmbedUnimplementedExecutableServer()
}

func RegisterExecutableServer(s grpc.ServiceRegistrar, srv ExecutableServer) {
	s.RegisterService(&Executable_ServiceDesc, srv)
}

func _Executable_RegisterToWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterToWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutableServer).RegisterToWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Executable_RegisterToWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutableServer).RegisterToWorkflow(ctx, req.(*RegisterToWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Executable_UnregisterFromWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterFromWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutableServer).UnregisterFromWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Executable_UnregisterFromWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutableServer).UnregisterFromWorkflow(ctx, req.(*UnregisterFromWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Executable_Execute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CapabilityRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExecutableServer).Execute(m, &executableExecuteServer{stream})
}

type Executable_ExecuteServer interface {
	Send(*CapabilityResponse) error
	grpc.ServerStream
}

type executableExecuteServer struct {
	grpc.ServerStream
}

func (x *executableExecuteServer) Send(m *CapabilityResponse) error {
	return x.ServerStream.SendMsg(m)
}

// Executable_ServiceDesc is the grpc.ServiceDesc for Executable service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Executable_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "capabilities.Executable",
	HandlerType: (*ExecutableServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterToWorkflow",
			Handler:    _Executable_RegisterToWorkflow_Handler,
		},
		{
			MethodName: "UnregisterFromWorkflow",
			Handler:    _Executable_UnregisterFromWorkflow_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Execute",
			Handler:       _Executable_Execute_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "capabilities/pb/capabilities.proto",
}

const (
	StandardCapabilities_Initialise_FullMethodName = "/capabilities.StandardCapabilities/Initialise"
	StandardCapabilities_Infos_FullMethodName      = "/capabilities.StandardCapabilities/Infos"
)

// StandardCapabilitiesClient is the client API for StandardCapabilities service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StandardCapabilitiesClient interface {
	Initialise(ctx context.Context, in *InitialiseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Infos(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CapabilityInfosReply, error)
}

type standardCapabilitiesClient struct {
	cc grpc.ClientConnInterface
}

func NewStandardCapabilitiesClient(cc grpc.ClientConnInterface) StandardCapabilitiesClient {
	return &standardCapabilitiesClient{cc}
}

func (c *standardCapabilitiesClient) Initialise(ctx context.Context, in *InitialiseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, StandardCapabilities_Initialise_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *standardCapabilitiesClient) Infos(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CapabilityInfosReply, error) {
	out := new(CapabilityInfosReply)
	err := c.cc.Invoke(ctx, StandardCapabilities_Infos_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StandardCapabilitiesServer is the server API for StandardCapabilities service.
// All implementations must embed UnimplementedStandardCapabilitiesServer
// for forward compatibility
type StandardCapabilitiesServer interface {
	Initialise(context.Context, *InitialiseRequest) (*emptypb.Empty, error)
	Infos(context.Context, *emptypb.Empty) (*CapabilityInfosReply, error)
	mustEmbedUnimplementedStandardCapabilitiesServer()
}

// UnimplementedStandardCapabilitiesServer must be embedded to have forward compatible implementations.
type UnimplementedStandardCapabilitiesServer struct {
}

func (UnimplementedStandardCapabilitiesServer) Initialise(context.Context, *InitialiseRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Initialise not implemented")
}
func (UnimplementedStandardCapabilitiesServer) Infos(context.Context, *emptypb.Empty) (*CapabilityInfosReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Infos not implemented")
}
func (UnimplementedStandardCapabilitiesServer) mustEmbedUnimplementedStandardCapabilitiesServer() {}

// UnsafeStandardCapabilitiesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StandardCapabilitiesServer will
// result in compilation errors.
type UnsafeStandardCapabilitiesServer interface {
	mustEmbedUnimplementedStandardCapabilitiesServer()
}

func RegisterStandardCapabilitiesServer(s grpc.ServiceRegistrar, srv StandardCapabilitiesServer) {
	s.RegisterService(&StandardCapabilities_ServiceDesc, srv)
}

func _StandardCapabilities_Initialise_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitialiseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StandardCapabilitiesServer).Initialise(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StandardCapabilities_Initialise_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StandardCapabilitiesServer).Initialise(ctx, req.(*InitialiseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StandardCapabilities_Infos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StandardCapabilitiesServer).Infos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StandardCapabilities_Infos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StandardCapabilitiesServer).Infos(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// StandardCapabilities_ServiceDesc is the grpc.ServiceDesc for StandardCapabilities service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StandardCapabilities_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "capabilities.StandardCapabilities",
	HandlerType: (*StandardCapabilitiesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Initialise",
			Handler:    _StandardCapabilities_Initialise_Handler,
		},
		{
			MethodName: "Infos",
			Handler:    _StandardCapabilities_Infos_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "capabilities/pb/capabilities.proto",
}
