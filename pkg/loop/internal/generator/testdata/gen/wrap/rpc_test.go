// Code generated by genrpc tests; DO NOT EDIT.
package test

import (
  "context"
  "net"
  "reflect"
  "testing"

  "google.golang.org/grpc"
  "google.golang.org/grpc/credentials/insecure"
  "google.golang.org/grpc/test/bufconn"

  pb "github.com/smartcontractkit/chainlink-common/pkg/loop/internal/generator/testdata/gen/pb"
  testdata "github.com/smartcontractkit/chainlink-common/pkg/loop/internal/generator/testdata"
  evm "github.com/smartcontractkit/chainlink-common/pkg/types/chains/evm"
  query "github.com/smartcontractkit/chainlink-common/pkg/types/query"
  primitives "github.com/smartcontractkit/chainlink-common/pkg/types/query/primitives"
  evm2 "github.com/smartcontractkit/chainlink-common/pkg/types/query/primitives/evm"
)

const bufSize = 1024 * 1024

// ---- fake impl that returns preloaded values per method ----
type fakeImpl struct {
  ret_GetBytes []byte
  ret_GetInt uint64
  ret_GetIntArr [10]int
  ret_GetIntSlice []int
  ret_SendNested testdata.NestedStruct
  ret_SendStruct testdata.MyStruct
}
func (f *fakeImpl) GetBytes(ctx context.Context, b []byte) ([]byte, error) {
  return f.ret_GetBytes, nil
}
func (f *fakeImpl) GetInt(ctx context.Context) (uint64, error) {
  return f.ret_GetInt, nil
}
func (f *fakeImpl) GetIntArr(ctx context.Context) ([10]int, error) {
  return f.ret_GetIntArr, nil
}
func (f *fakeImpl) GetIntSlice(ctx context.Context) ([]int, error) {
  return f.ret_GetIntSlice, nil
}
func (f *fakeImpl) SendNested(ctx context.Context, ns testdata.NestedStruct) (testdata.NestedStruct, error) {
  return f.ret_SendNested, nil
}
func (f *fakeImpl) SendStruct(ctx context.Context, ms testdata.MyStruct) (testdata.MyStruct, error) {
  return f.ret_SendStruct, nil
}

// ---- fixtures (depth-limited) for user-defined messages ----

// Public, depth-1 convenience wrapper
func fixture_Address() evm2.Address { return fixture_Address_depth(3) }

func fixture_Address_depth(d int) evm2.Address {
  var out evm2.Address
  if d <= 0 { return out }
  // fixed-size [N]byte-like (named array type)
  {
    var e evm.Address
    copy(e[:], []byte{9,8,7,6})
    out.Address = e
  }
  return out
}

// Public, depth-1 convenience wrapper
func fixture_BoolExpression() query.BoolExpression { return fixture_BoolExpression_depth(3) }

func fixture_BoolExpression_depth(d int) query.BoolExpression {
  var out query.BoolExpression
  if d <= 0 { return out }
  out.Expressions = make([]query.Expression, 2)
  out.Expressions[0] = fixture_Expression_depth(d-1)
  out.Expressions[1] = fixture_Expression_depth(d-1)
  // numeric scalar (cast)
  out.BoolOperator = query.BoolOperator(2)
  return out
}

// Public, depth-1 convenience wrapper
func fixture_EventByTopic() evm2.EventByTopic { return fixture_EventByTopic_depth(3) }

func fixture_EventByTopic_depth(d int) evm2.EventByTopic {
  var out evm2.EventByTopic
  if d <= 0 { return out }
  // numeric scalar (cast)
  out.Topic = uint64(2)
  out.HashedValueComparers = make([]evm2.HashedValueComparator, 2)
  out.HashedValueComparers[0] = fixture_HashedValueComparator_depth(d-1)
  out.HashedValueComparers[1] = fixture_HashedValueComparator_depth(d-1)
  return out
}

// Public, depth-1 convenience wrapper
func fixture_Expression() query.Expression { return fixture_Expression_depth(3) }

func fixture_Expression_depth(d int) query.Expression {
  var out query.Expression
  if d <= 0 { return out }
  out.Primitive = fixture_Primitive_depth(d-1)
  out.BoolExpression = fixture_BoolExpression_depth(d-1)
  return out
}

// Public, depth-1 convenience wrapper
func fixture_HashedValueComparator() evm2.HashedValueComparator { return fixture_HashedValueComparator_depth(3) }

func fixture_HashedValueComparator_depth(d int) evm2.HashedValueComparator {
  var out evm2.HashedValueComparator
  if d <= 0 { return out }
  // []bytes (element may be []byte or fixed-size [N]byte-like)
  out.Values = make([]evm.Hash, 2)
  {
    var e0 evm.Hash; copy(e0[:], []byte{1,2,3,4})
    var e1 evm.Hash; copy(e1[:], []byte{5,6,7,8})
    out.Values[0], out.Values[1] = e0, e1
  }
  // numeric scalar (cast)
  out.Operator = primitives.ComparisonOperator(2)
  return out
}

// Public, depth-1 convenience wrapper
func fixture_MyStruct() testdata.MyStruct { return fixture_MyStruct_depth(3) }

func fixture_MyStruct_depth(d int) testdata.MyStruct {
  var out testdata.MyStruct
  if d <= 0 { return out }
  // []byte
  out.B = []byte{9,8,7,6}
  out.Prim = primitives.ConfidenceLevel("fixture")
  out.Expr = fixture_Expression_depth(d-1)
  return out
}

// Public, depth-1 convenience wrapper
func fixture_NestedStruct() testdata.NestedStruct { return fixture_NestedStruct_depth(3) }

func fixture_NestedStruct_depth(d int) testdata.NestedStruct {
  var out testdata.NestedStruct
  if d <= 0 { return out }
  out.F1 = fixture_MyStruct_depth(d-1)
  out.F2 = fixture_MyStruct_depth(d-1)
  return out
}

// ---- fixtures for interface oneofs (pick first case), depth-limited ----

// Public, depth-1 convenience wrapper
func fixture_Primitive() primitives.Primitive { return fixture_Primitive_depth(1) }

func fixture_Primitive_depth(d int) primitives.Primitive {
  if d <= 0 { return nil }
  {
    v := fixture_Address_depth(d-1)
    return &v
  }
}

// ---- single suite with subtests (one server/client for all) ----
func Test_Test_DomainRoundtrip(t *testing.T) {
  impl := &fakeImpl{}

  lis := bufconn.Listen(bufSize)
  s := grpc.NewServer()
  pb.RegisterTestServer(s, NewServer(impl))
  go func() { _ = s.Serve(lis) }()
  t.Cleanup(func() { s.Stop(); _ = lis.Close() })

  dialer := func(ctx context.Context, _ string) (net.Conn, error) { return lis.Dial() }
  conn, err := grpc.DialContext(context.Background(), "bufnet",
    grpc.WithContextDialer(dialer),
    grpc.WithTransportCredentials(insecure.NewCredentials()))
  if err != nil { t.Fatalf("dial: %v", err) }
  t.Cleanup(func() { _ = conn.Close() })

  c := NewClient(pb.NewTestClient(conn))
  t.Run("GetBytes happy path", func(t *testing.T) {
    ctx := context.Background()
    // want: []byte
    want := []byte{10,11}
    impl.ret_GetBytes = want
    var b []byte = []byte{4,5,6}
    got, err := c.GetBytes(ctx, b)
    if err != nil { t.Fatalf("rpc error: %v", err) }
    if !reflect.DeepEqual(got, impl.ret_GetBytes) {
      t.Fatalf("result mismatch:\n got  = %#v\n want = %#v", got, impl.ret_GetBytes)
    }
  })
  t.Run("GetInt happy path", func(t *testing.T) {
    ctx := context.Background()
    want := uint64(2)
    impl.ret_GetInt = want
    got, err := c.GetInt(ctx)
    if err != nil { t.Fatalf("rpc error: %v", err) }
    if !reflect.DeepEqual(got, impl.ret_GetInt) {
      t.Fatalf("result mismatch:\n got  = %#v\n want = %#v", got, impl.ret_GetInt)
    }
  })
  t.Run("GetIntArr happy path", func(t *testing.T) {
    ctx := context.Background()
    // want: [N]T (fixed-size array)
    var want [10]int
    for i := range want { want[i] = int(i+1) }
    impl.ret_GetIntArr = want
    got, err := c.GetIntArr(ctx)
    if err != nil { t.Fatalf("rpc error: %v", err) }
    if !reflect.DeepEqual(got, impl.ret_GetIntArr) {
      t.Fatalf("result mismatch:\n got  = %#v\n want = %#v", got, impl.ret_GetIntArr)
    }
  })
  t.Run("GetIntSlice happy path", func(t *testing.T) {
    ctx := context.Background()
    // want: []scalar
    want := []int{ int(1), int(2), int(3) }
    impl.ret_GetIntSlice = want
    got, err := c.GetIntSlice(ctx)
    if err != nil { t.Fatalf("rpc error: %v", err) }
    if !reflect.DeepEqual(got, impl.ret_GetIntSlice) {
      t.Fatalf("result mismatch:\n got  = %#v\n want = %#v", got, impl.ret_GetIntSlice)
    }
  })
  t.Run("SendNested happy path", func(t *testing.T) {
    ctx := context.Background()
    // want: Message
    want := fixture_NestedStruct()
    impl.ret_SendNested = want
    var ns testdata.NestedStruct = fixture_NestedStruct()
    got, err := c.SendNested(ctx, ns)
    if err != nil { t.Fatalf("rpc error: %v", err) }
    if !reflect.DeepEqual(got, impl.ret_SendNested) {
      t.Fatalf("result mismatch:\n got  = %#v\n want = %#v", got, impl.ret_SendNested)
    }
  })
  t.Run("SendStruct happy path", func(t *testing.T) {
    ctx := context.Background()
    // want: Message
    want := fixture_MyStruct()
    impl.ret_SendStruct = want
    var ms testdata.MyStruct = fixture_MyStruct()
    got, err := c.SendStruct(ctx, ms)
    if err != nil { t.Fatalf("rpc error: %v", err) }
    if !reflect.DeepEqual(got, impl.ret_SendStruct) {
      t.Fatalf("result mismatch:\n got  = %#v\n want = %#v", got, impl.ret_SendStruct)
    }
  })
}
