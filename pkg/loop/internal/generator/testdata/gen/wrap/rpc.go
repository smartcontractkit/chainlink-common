
// Code generated by genrpc; DO NOT EDIT.
package test

import (
  "context"
  "fmt"

  pb "github.com/smartcontractkit/chainlink-common/pkg/loop/internal/generator/testdata/gen/pb"
  testdata "github.com/smartcontractkit/chainlink-common/pkg/loop/internal/generator/testdata"
  evm "github.com/smartcontractkit/chainlink-common/pkg/types/chains/evm"
  query "github.com/smartcontractkit/chainlink-common/pkg/types/query"
  primitives "github.com/smartcontractkit/chainlink-common/pkg/types/query/primitives"
  evm2 "github.com/smartcontractkit/chainlink-common/pkg/types/query/primitives/evm"
)

type Client struct{ rpc pb.TestClient }

func NewClient(r pb.TestClient) *Client { return &Client{rpc: r} }


func (c *Client) GetBytes(
  ctx context.Context, b []byte,
) ([]byte, error) {

  req := &pb.GetBytesRequest{
    B: b,
  }

  rep, err := c.rpc.GetBytes(ctx, req)
  if err != nil { var zero []byte; return zero, err
  }
  // pb []byte -> domain []byte
  return rep.Result, nil
}

func (c *Client) GetInt(
  ctx context.Context,
) (uint64, error) {

  req := &pb.GetIntRequest{
  }

  rep, err := c.rpc.GetInt(ctx, req)
  if err != nil { var zero uint64; return zero, err
  }
  return uint64(rep.Result), nil
}

func (c *Client) GetIntArr(
  ctx context.Context,
) ([10]int, error) {

  req := &pb.GetIntArrRequest{
  }

  rep, err := c.rpc.GetIntArr(ctx, req)
  if err != nil { var zero [10]int; return zero, err
  }
  // pb []scalar -> domain [N]T
  var out [10]int
  if rep.Result != nil {
    for i := range out {
      if i < len(rep.Result) {
        out[i] = int(rep.Result[i])
      }
    }
  }
  return out, nil
}

func (c *Client) GetIntSlice(
  ctx context.Context,
) ([]int, error) {

  req := &pb.GetIntSliceRequest{
  }

  rep, err := c.rpc.GetIntSlice(ctx, req)
  if err != nil { var zero []int; return zero, err
  }
  // pb []scalar -> domain []scalar (cast if needed)
  if rep.Result == nil { var zero []int; return zero, nil }
  out := make([]int, len(rep.Result))
  for i := range rep.Result {
    out[i] = int(rep.Result[i])
  }
  return out, nil
}

func (c *Client) SendNested(
  ctx context.Context, ns testdata.NestedStruct,
) (testdata.NestedStruct, error) {

  req := &pb.SendNestedRequest{
    Ns: toPB_NestedStruct(ns),
  }

  rep, err := c.rpc.SendNested(ctx, req)
  if err != nil { var zero testdata.NestedStruct; return zero, err
  }
  return fromPB_NestedStruct(rep.Result), nil
}

func (c *Client) SendStruct(
  ctx context.Context, ms testdata.MyStruct,
) (testdata.MyStruct, error) {

  req := &pb.SendStructRequest{
    Ms: toPB_MyStruct(ms),
  }

  rep, err := c.rpc.SendStruct(ctx, req)
  if err != nil { var zero testdata.MyStruct; return zero, err
  }
  return fromPB_MyStruct(rep.Result), nil
}


// ---- pb<->domain converters for user messages ----
func toPB_Address(in evm2.Address) *pb.Address {
  out := &pb.Address{}
  // domain [N]byte/uint8 -> pb []byte
  out.Address = in.Address[:]
  return out
}

func fromPB_Address(in *pb.Address) evm2.Address {
  var out evm2.Address
  if in == nil { return out }
  // pb []byte -> domain [N]byte/uint8
  if in.Address != nil {
    copy(out.Address[:], in.Address)
  }
  return out
}
func toPB_BoolExpression(in query.BoolExpression) *pb.BoolExpression {
  out := &pb.BoolExpression{}
  if in.Expressions != nil {
    out.Expressions = make([]*pb.Expression, len(in.Expressions))
    for i, v := range in.Expressions { out.Expressions[i] = toPB_Expression(v) }
  }
  out.BoolOperator = int64(in.BoolOperator)
  return out
}

func fromPB_BoolExpression(in *pb.BoolExpression) query.BoolExpression {
  var out query.BoolExpression
  if in == nil { return out }
  if in.Expressions != nil {
    out.Expressions = make([]query.Expression, len(in.Expressions))
    for i, v := range in.Expressions {
      out.Expressions[i] = fromPB_Expression(v)
    }
  }
  out.BoolOperator = query.BoolOperator(in.BoolOperator)
  return out
}
func toPB_EventByTopic(in evm2.EventByTopic) *pb.EventByTopic {
  out := &pb.EventByTopic{}
  out.Topic = uint64(in.Topic)
  if in.HashedValueComparers != nil {
    out.HashedValueComparers = make([]*pb.HashedValueComparator, len(in.HashedValueComparers))
    for i, v := range in.HashedValueComparers { out.HashedValueComparers[i] = toPB_HashedValueComparator(v) }
  }
  return out
}

func fromPB_EventByTopic(in *pb.EventByTopic) evm2.EventByTopic {
  var out evm2.EventByTopic
  if in == nil { return out }
  out.Topic = uint64(in.Topic)
  if in.HashedValueComparers != nil {
    out.HashedValueComparers = make([]evm2.HashedValueComparator, len(in.HashedValueComparers))
    for i, v := range in.HashedValueComparers {
      out.HashedValueComparers[i] = fromPB_HashedValueComparator(v)
    }
  }
  return out
}
func toPB_Expression(in query.Expression) *pb.Expression {
  out := &pb.Expression{}
  out.Primitive = toPB_Primitive(in.Primitive)
  out.BoolExpression = toPB_BoolExpression(in.BoolExpression)
  return out
}

func fromPB_Expression(in *pb.Expression) query.Expression {
  var out query.Expression
  if in == nil { return out }
  out.Primitive = fromPB_Primitive(in.Primitive)
  out.BoolExpression = fromPB_BoolExpression(in.BoolExpression)
  return out
}
func toPB_HashedValueComparator(in evm2.HashedValueComparator) *pb.HashedValueComparator {
  out := &pb.HashedValueComparator{}
  // domain []T -> pb [][]byte (T may be fixed [N]byte)
  if in.Values != nil {
    out.Values = make([][]byte, len(in.Values))
    for i := range in.Values {
      out.Values[i] = in.Values[i][:]
    }
  }
  out.Operator = int64(in.Operator)
  return out
}

func fromPB_HashedValueComparator(in *pb.HashedValueComparator) evm2.HashedValueComparator {
  var out evm2.HashedValueComparator
  if in == nil { return out }
  // pb [][]byte -> domain []T (T may be fixed [N]byte)
  if in.Values != nil {
    out.Values = make([]evm.Hash, len(in.Values))
    for i := range in.Values {
      var e evm.Hash
      // Length-check omitted here to keep converter pure; client/server paths enforce it and can return error.
      copy(e[:], in.Values[i])
      out.Values[i] = e
    }
  }
  out.Operator = primitives.ComparisonOperator(in.Operator)
  return out
}
func toPB_MyStruct(in testdata.MyStruct) *pb.MyStruct {
  out := &pb.MyStruct{}
  out.B = in.B
  out.Prim = string(in.Prim)
  out.Expr = toPB_Expression(in.Expr)
  return out
}

func fromPB_MyStruct(in *pb.MyStruct) testdata.MyStruct {
  var out testdata.MyStruct
  if in == nil { return out }
  // pb []byte -> domain []byte
  out.B = in.B
  out.Prim = primitives.ConfidenceLevel(in.Prim)
  out.Expr = fromPB_Expression(in.Expr)
  return out
}
func toPB_NestedStruct(in testdata.NestedStruct) *pb.NestedStruct {
  out := &pb.NestedStruct{}
  out.F1 = toPB_MyStruct(in.F1)
  out.F2 = toPB_MyStruct(in.F2)
  return out
}

func fromPB_NestedStruct(in *pb.NestedStruct) testdata.NestedStruct {
  var out testdata.NestedStruct
  if in == nil { return out }
  out.F1 = fromPB_MyStruct(in.F1)
  out.F2 = fromPB_MyStruct(in.F2)
  return out
}
func toPB_Primitive(in primitives.Primitive) *pb.Primitive {
  if in == nil { return nil }
  switch v := in.(type) {
  case *evm2.Address:
    return &pb.Primitive{
      Kind: &pb.Primitive_Address{ Address: toPB_Address(*v) },
    }
  case *evm2.EventByTopic:
    return &pb.Primitive{
      Kind: &pb.Primitive_EventByTopic{ EventByTopic: toPB_EventByTopic(*v) },
    }
  default:
    return nil
  }
}

func fromPB_Primitive(in *pb.Primitive) primitives.Primitive {
  if in == nil { return nil }
  switch k := in.Kind.(type) {
  case *pb.Primitive_Address:
    {
      v := fromPB_Address(k.Address)
      return &v
    }
  case *pb.Primitive_EventByTopic:
    {
      v := fromPB_EventByTopic(k.EventByTopic)
      return &v
    }
  default:
    return nil
  }
}

// ---- Optional helpers for fixed-size arrays (with length checks) ----

// toAddress converts a byte slice into an evm.Address with length check.
func toAddress(b []byte) (evm.Address, error) {
  var out evm.Address
  if len(b) != len(out) { return out, fmt.Errorf("invalid evm.Address length: got %d want %d", len(b), len(out)) }
  copy(out[:], b)
  return out, nil
}

// toHash converts a byte slice into an evm.Hash with length check.
func toHash(b []byte) (evm.Hash, error) {
  var out evm.Hash
  if len(b) != len(out) { return out, fmt.Errorf("invalid evm.Hash length: got %d want %d", len(b), len(out)) }
  copy(out[:], b)
  return out, nil
}

// server
type Server struct {
  pb.UnimplementedTestServer
  impl interface{
    GetBytes(ctx context.Context, b []byte) ([]byte, error)
    GetInt(ctx context.Context) (uint64, error)
    GetIntArr(ctx context.Context) ([10]int, error)
    GetIntSlice(ctx context.Context) ([]int, error)
    SendNested(ctx context.Context, ns testdata.NestedStruct) (testdata.NestedStruct, error)
    SendStruct(ctx context.Context, ms testdata.MyStruct) (testdata.MyStruct, error)
  }
}

func NewServer(impl any) *Server {
  return &Server{impl: impl.(interface{
    GetBytes(ctx context.Context, b []byte) ([]byte, error)
    GetInt(ctx context.Context) (uint64, error)
    GetIntArr(ctx context.Context) ([10]int, error)
    GetIntSlice(ctx context.Context) ([]int, error)
    SendNested(ctx context.Context, ns testdata.NestedStruct) (testdata.NestedStruct, error)
    SendStruct(ctx context.Context, ms testdata.MyStruct) (testdata.MyStruct, error)
  })}
}


func (s *Server) GetBytes(ctx context.Context, req *pb.GetBytesRequest) (*pb.GetBytesReply, error) {
  var b []byte = req.B
  res, err := s.impl.GetBytes(ctx, b)
  if err != nil { return nil, err }
  rep := &pb.GetBytesReply{}
  rep.Result = res
  return rep, nil
}

func (s *Server) GetInt(ctx context.Context, req *pb.GetIntRequest) (*pb.GetIntReply, error) {
  res, err := s.impl.GetInt(ctx)
  if err != nil { return nil, err }
  rep := &pb.GetIntReply{}
  rep.Result = uint64(res)
  return rep, nil
}

func (s *Server) GetIntArr(ctx context.Context, req *pb.GetIntArrRequest) (*pb.GetIntArrReply, error) {
  res, err := s.impl.GetIntArr(ctx)
  if err != nil { return nil, err }
  rep := &pb.GetIntArrReply{}
  // domain [N]T -> pb []scalar (array cannot be nil)
  rep.Result = make([]int64, len(res))
  for i := range res { rep.Result[i] = int64(res[i]) }
  return rep, nil
}

func (s *Server) GetIntSlice(ctx context.Context, req *pb.GetIntSliceRequest) (*pb.GetIntSliceReply, error) {
  res, err := s.impl.GetIntSlice(ctx)
  if err != nil { return nil, err }
  rep := &pb.GetIntSliceReply{}
  // domain slice -> pb slice (scalar)
  if res != nil {
    rep.Result = make([]int64, len(res))
    for i := range res { rep.Result[i] = int64(res[i]) }
  }
  return rep, nil
}

func (s *Server) SendNested(ctx context.Context, req *pb.SendNestedRequest) (*pb.SendNestedReply, error) {
  var ns testdata.NestedStruct = fromPB_NestedStruct(req.Ns)
  res, err := s.impl.SendNested(ctx, ns)
  if err != nil { return nil, err }
  rep := &pb.SendNestedReply{}
  rep.Result = toPB_NestedStruct(res)
  return rep, nil
}

func (s *Server) SendStruct(ctx context.Context, req *pb.SendStructRequest) (*pb.SendStructReply, error) {
  var ms testdata.MyStruct = fromPB_MyStruct(req.Ms)
  res, err := s.impl.SendStruct(ctx, ms)
  if err != nil { return nil, err }
  rep := &pb.SendStructReply{}
  rep.Result = toPB_MyStruct(res)
  return rep, nil
}


