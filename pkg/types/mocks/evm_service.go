// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	context "context"
	big "math/big"

	evm "github.com/smartcontractkit/chainlink-common/pkg/types/chains/evm"
	mock "github.com/stretchr/testify/mock"

	primitives "github.com/smartcontractkit/chainlink-common/pkg/types/query/primitives"

	query "github.com/smartcontractkit/chainlink-common/pkg/types/query"

	types "github.com/smartcontractkit/chainlink-common/pkg/types"
)

// EVMService is an autogenerated mock type for the EVMService type
type EVMService struct {
	mock.Mock
}

type EVMService_Expecter struct {
	mock *mock.Mock
}

func (_m *EVMService) EXPECT() *EVMService_Expecter {
	return &EVMService_Expecter{mock: &_m.Mock}
}

// BalanceAt provides a mock function with given fields: ctx, account, blockNumber
func (_m *EVMService) BalanceAt(ctx context.Context, account [20]byte, blockNumber *big.Int) (*big.Int, error) {
	ret := _m.Called(ctx, account, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for BalanceAt")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, [20]byte, *big.Int) (*big.Int, error)); ok {
		return rf(ctx, account, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, [20]byte, *big.Int) *big.Int); ok {
		r0 = rf(ctx, account, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, [20]byte, *big.Int) error); ok {
		r1 = rf(ctx, account, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMService_BalanceAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BalanceAt'
type EVMService_BalanceAt_Call struct {
	*mock.Call
}

// BalanceAt is a helper method to define mock.On call
//   - ctx context.Context
//   - account [20]byte
//   - blockNumber *big.Int
func (_e *EVMService_Expecter) BalanceAt(ctx interface{}, account interface{}, blockNumber interface{}) *EVMService_BalanceAt_Call {
	return &EVMService_BalanceAt_Call{Call: _e.mock.On("BalanceAt", ctx, account, blockNumber)}
}

func (_c *EVMService_BalanceAt_Call) Run(run func(ctx context.Context, account [20]byte, blockNumber *big.Int)) *EVMService_BalanceAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([20]byte), args[2].(*big.Int))
	})
	return _c
}

func (_c *EVMService_BalanceAt_Call) Return(_a0 *big.Int, _a1 error) *EVMService_BalanceAt_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMService_BalanceAt_Call) RunAndReturn(run func(context.Context, [20]byte, *big.Int) (*big.Int, error)) *EVMService_BalanceAt_Call {
	_c.Call.Return(run)
	return _c
}

// CallContract provides a mock function with given fields: ctx, msg, blockNumber
func (_m *EVMService) CallContract(ctx context.Context, msg *evm.CallMsg, blockNumber *big.Int) ([]byte, error) {
	ret := _m.Called(ctx, msg, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for CallContract")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *evm.CallMsg, *big.Int) ([]byte, error)); ok {
		return rf(ctx, msg, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *evm.CallMsg, *big.Int) []byte); ok {
		r0 = rf(ctx, msg, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *evm.CallMsg, *big.Int) error); ok {
		r1 = rf(ctx, msg, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMService_CallContract_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CallContract'
type EVMService_CallContract_Call struct {
	*mock.Call
}

// CallContract is a helper method to define mock.On call
//   - ctx context.Context
//   - msg *evm.CallMsg
//   - blockNumber *big.Int
func (_e *EVMService_Expecter) CallContract(ctx interface{}, msg interface{}, blockNumber interface{}) *EVMService_CallContract_Call {
	return &EVMService_CallContract_Call{Call: _e.mock.On("CallContract", ctx, msg, blockNumber)}
}

func (_c *EVMService_CallContract_Call) Run(run func(ctx context.Context, msg *evm.CallMsg, blockNumber *big.Int)) *EVMService_CallContract_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*evm.CallMsg), args[2].(*big.Int))
	})
	return _c
}

func (_c *EVMService_CallContract_Call) Return(_a0 []byte, _a1 error) *EVMService_CallContract_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMService_CallContract_Call) RunAndReturn(run func(context.Context, *evm.CallMsg, *big.Int) ([]byte, error)) *EVMService_CallContract_Call {
	_c.Call.Return(run)
	return _c
}

// EstimateGas provides a mock function with given fields: ctx, call
func (_m *EVMService) EstimateGas(ctx context.Context, call *evm.CallMsg) (uint64, error) {
	ret := _m.Called(ctx, call)

	if len(ret) == 0 {
		panic("no return value specified for EstimateGas")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *evm.CallMsg) (uint64, error)); ok {
		return rf(ctx, call)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *evm.CallMsg) uint64); ok {
		r0 = rf(ctx, call)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *evm.CallMsg) error); ok {
		r1 = rf(ctx, call)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMService_EstimateGas_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EstimateGas'
type EVMService_EstimateGas_Call struct {
	*mock.Call
}

// EstimateGas is a helper method to define mock.On call
//   - ctx context.Context
//   - call *evm.CallMsg
func (_e *EVMService_Expecter) EstimateGas(ctx interface{}, call interface{}) *EVMService_EstimateGas_Call {
	return &EVMService_EstimateGas_Call{Call: _e.mock.On("EstimateGas", ctx, call)}
}

func (_c *EVMService_EstimateGas_Call) Run(run func(ctx context.Context, call *evm.CallMsg)) *EVMService_EstimateGas_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*evm.CallMsg))
	})
	return _c
}

func (_c *EVMService_EstimateGas_Call) Return(_a0 uint64, _a1 error) *EVMService_EstimateGas_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMService_EstimateGas_Call) RunAndReturn(run func(context.Context, *evm.CallMsg) (uint64, error)) *EVMService_EstimateGas_Call {
	_c.Call.Return(run)
	return _c
}

// FilterLogs provides a mock function with given fields: ctx, filterQuery
func (_m *EVMService) FilterLogs(ctx context.Context, filterQuery evm.FilterQuery) ([]*evm.Log, error) {
	ret := _m.Called(ctx, filterQuery)

	if len(ret) == 0 {
		panic("no return value specified for FilterLogs")
	}

	var r0 []*evm.Log
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, evm.FilterQuery) ([]*evm.Log, error)); ok {
		return rf(ctx, filterQuery)
	}
	if rf, ok := ret.Get(0).(func(context.Context, evm.FilterQuery) []*evm.Log); ok {
		r0 = rf(ctx, filterQuery)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*evm.Log)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, evm.FilterQuery) error); ok {
		r1 = rf(ctx, filterQuery)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMService_FilterLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterLogs'
type EVMService_FilterLogs_Call struct {
	*mock.Call
}

// FilterLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - filterQuery evm.FilterQuery
func (_e *EVMService_Expecter) FilterLogs(ctx interface{}, filterQuery interface{}) *EVMService_FilterLogs_Call {
	return &EVMService_FilterLogs_Call{Call: _e.mock.On("FilterLogs", ctx, filterQuery)}
}

func (_c *EVMService_FilterLogs_Call) Run(run func(ctx context.Context, filterQuery evm.FilterQuery)) *EVMService_FilterLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(evm.FilterQuery))
	})
	return _c
}

func (_c *EVMService_FilterLogs_Call) Return(_a0 []*evm.Log, _a1 error) *EVMService_FilterLogs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMService_FilterLogs_Call) RunAndReturn(run func(context.Context, evm.FilterQuery) ([]*evm.Log, error)) *EVMService_FilterLogs_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionByHash provides a mock function with given fields: ctx, hash
func (_m *EVMService) GetTransactionByHash(ctx context.Context, hash [32]byte) (*evm.Transaction, error) {
	ret := _m.Called(ctx, hash)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionByHash")
	}

	var r0 *evm.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, [32]byte) (*evm.Transaction, error)); ok {
		return rf(ctx, hash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, [32]byte) *evm.Transaction); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*evm.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, [32]byte) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMService_GetTransactionByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionByHash'
type EVMService_GetTransactionByHash_Call struct {
	*mock.Call
}

// GetTransactionByHash is a helper method to define mock.On call
//   - ctx context.Context
//   - hash [32]byte
func (_e *EVMService_Expecter) GetTransactionByHash(ctx interface{}, hash interface{}) *EVMService_GetTransactionByHash_Call {
	return &EVMService_GetTransactionByHash_Call{Call: _e.mock.On("GetTransactionByHash", ctx, hash)}
}

func (_c *EVMService_GetTransactionByHash_Call) Run(run func(ctx context.Context, hash [32]byte)) *EVMService_GetTransactionByHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([32]byte))
	})
	return _c
}

func (_c *EVMService_GetTransactionByHash_Call) Return(_a0 *evm.Transaction, _a1 error) *EVMService_GetTransactionByHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMService_GetTransactionByHash_Call) RunAndReturn(run func(context.Context, [32]byte) (*evm.Transaction, error)) *EVMService_GetTransactionByHash_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionFee provides a mock function with given fields: ctx, transactionID
func (_m *EVMService) GetTransactionFee(ctx context.Context, transactionID string) (*evm.TransactionFee, error) {
	ret := _m.Called(ctx, transactionID)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionFee")
	}

	var r0 *evm.TransactionFee
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*evm.TransactionFee, error)); ok {
		return rf(ctx, transactionID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *evm.TransactionFee); ok {
		r0 = rf(ctx, transactionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*evm.TransactionFee)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, transactionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMService_GetTransactionFee_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionFee'
type EVMService_GetTransactionFee_Call struct {
	*mock.Call
}

// GetTransactionFee is a helper method to define mock.On call
//   - ctx context.Context
//   - transactionID string
func (_e *EVMService_Expecter) GetTransactionFee(ctx interface{}, transactionID interface{}) *EVMService_GetTransactionFee_Call {
	return &EVMService_GetTransactionFee_Call{Call: _e.mock.On("GetTransactionFee", ctx, transactionID)}
}

func (_c *EVMService_GetTransactionFee_Call) Run(run func(ctx context.Context, transactionID string)) *EVMService_GetTransactionFee_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *EVMService_GetTransactionFee_Call) Return(_a0 *evm.TransactionFee, _a1 error) *EVMService_GetTransactionFee_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMService_GetTransactionFee_Call) RunAndReturn(run func(context.Context, string) (*evm.TransactionFee, error)) *EVMService_GetTransactionFee_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionReceipt provides a mock function with given fields: ctx, txHash
func (_m *EVMService) GetTransactionReceipt(ctx context.Context, txHash [32]byte) (*evm.Receipt, error) {
	ret := _m.Called(ctx, txHash)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionReceipt")
	}

	var r0 *evm.Receipt
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, [32]byte) (*evm.Receipt, error)); ok {
		return rf(ctx, txHash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, [32]byte) *evm.Receipt); ok {
		r0 = rf(ctx, txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*evm.Receipt)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, [32]byte) error); ok {
		r1 = rf(ctx, txHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMService_GetTransactionReceipt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionReceipt'
type EVMService_GetTransactionReceipt_Call struct {
	*mock.Call
}

// GetTransactionReceipt is a helper method to define mock.On call
//   - ctx context.Context
//   - txHash [32]byte
func (_e *EVMService_Expecter) GetTransactionReceipt(ctx interface{}, txHash interface{}) *EVMService_GetTransactionReceipt_Call {
	return &EVMService_GetTransactionReceipt_Call{Call: _e.mock.On("GetTransactionReceipt", ctx, txHash)}
}

func (_c *EVMService_GetTransactionReceipt_Call) Run(run func(ctx context.Context, txHash [32]byte)) *EVMService_GetTransactionReceipt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([32]byte))
	})
	return _c
}

func (_c *EVMService_GetTransactionReceipt_Call) Return(_a0 *evm.Receipt, _a1 error) *EVMService_GetTransactionReceipt_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMService_GetTransactionReceipt_Call) RunAndReturn(run func(context.Context, [32]byte) (*evm.Receipt, error)) *EVMService_GetTransactionReceipt_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionStatus provides a mock function with given fields: ctx, transactionID
func (_m *EVMService) GetTransactionStatus(ctx context.Context, transactionID string) (types.TransactionStatus, error) {
	ret := _m.Called(ctx, transactionID)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionStatus")
	}

	var r0 types.TransactionStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (types.TransactionStatus, error)); ok {
		return rf(ctx, transactionID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) types.TransactionStatus); ok {
		r0 = rf(ctx, transactionID)
	} else {
		r0 = ret.Get(0).(types.TransactionStatus)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, transactionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMService_GetTransactionStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionStatus'
type EVMService_GetTransactionStatus_Call struct {
	*mock.Call
}

// GetTransactionStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - transactionID string
func (_e *EVMService_Expecter) GetTransactionStatus(ctx interface{}, transactionID interface{}) *EVMService_GetTransactionStatus_Call {
	return &EVMService_GetTransactionStatus_Call{Call: _e.mock.On("GetTransactionStatus", ctx, transactionID)}
}

func (_c *EVMService_GetTransactionStatus_Call) Run(run func(ctx context.Context, transactionID string)) *EVMService_GetTransactionStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *EVMService_GetTransactionStatus_Call) Return(_a0 types.TransactionStatus, _a1 error) *EVMService_GetTransactionStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMService_GetTransactionStatus_Call) RunAndReturn(run func(context.Context, string) (types.TransactionStatus, error)) *EVMService_GetTransactionStatus_Call {
	_c.Call.Return(run)
	return _c
}

// LatestAndFinalizedHead provides a mock function with given fields: ctx
func (_m *EVMService) LatestAndFinalizedHead(ctx context.Context) (evm.Head, evm.Head, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for LatestAndFinalizedHead")
	}

	var r0 evm.Head
	var r1 evm.Head
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context) (evm.Head, evm.Head, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) evm.Head); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(evm.Head)
	}

	if rf, ok := ret.Get(1).(func(context.Context) evm.Head); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Get(1).(evm.Head)
	}

	if rf, ok := ret.Get(2).(func(context.Context) error); ok {
		r2 = rf(ctx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// EVMService_LatestAndFinalizedHead_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LatestAndFinalizedHead'
type EVMService_LatestAndFinalizedHead_Call struct {
	*mock.Call
}

// LatestAndFinalizedHead is a helper method to define mock.On call
//   - ctx context.Context
func (_e *EVMService_Expecter) LatestAndFinalizedHead(ctx interface{}) *EVMService_LatestAndFinalizedHead_Call {
	return &EVMService_LatestAndFinalizedHead_Call{Call: _e.mock.On("LatestAndFinalizedHead", ctx)}
}

func (_c *EVMService_LatestAndFinalizedHead_Call) Run(run func(ctx context.Context)) *EVMService_LatestAndFinalizedHead_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *EVMService_LatestAndFinalizedHead_Call) Return(latest evm.Head, finalized evm.Head, err error) *EVMService_LatestAndFinalizedHead_Call {
	_c.Call.Return(latest, finalized, err)
	return _c
}

func (_c *EVMService_LatestAndFinalizedHead_Call) RunAndReturn(run func(context.Context) (evm.Head, evm.Head, error)) *EVMService_LatestAndFinalizedHead_Call {
	_c.Call.Return(run)
	return _c
}

// QueryTrackedLogs provides a mock function with given fields: ctx, filterQuery, limitAndSort, confidenceLevel
func (_m *EVMService) QueryTrackedLogs(ctx context.Context, filterQuery []query.Expression, limitAndSort query.LimitAndSort, confidenceLevel primitives.ConfidenceLevel) ([]*evm.Log, error) {
	ret := _m.Called(ctx, filterQuery, limitAndSort, confidenceLevel)

	if len(ret) == 0 {
		panic("no return value specified for QueryTrackedLogs")
	}

	var r0 []*evm.Log
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []query.Expression, query.LimitAndSort, primitives.ConfidenceLevel) ([]*evm.Log, error)); ok {
		return rf(ctx, filterQuery, limitAndSort, confidenceLevel)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []query.Expression, query.LimitAndSort, primitives.ConfidenceLevel) []*evm.Log); ok {
		r0 = rf(ctx, filterQuery, limitAndSort, confidenceLevel)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*evm.Log)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []query.Expression, query.LimitAndSort, primitives.ConfidenceLevel) error); ok {
		r1 = rf(ctx, filterQuery, limitAndSort, confidenceLevel)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMService_QueryTrackedLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryTrackedLogs'
type EVMService_QueryTrackedLogs_Call struct {
	*mock.Call
}

// QueryTrackedLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - filterQuery []query.Expression
//   - limitAndSort query.LimitAndSort
//   - confidenceLevel primitives.ConfidenceLevel
func (_e *EVMService_Expecter) QueryTrackedLogs(ctx interface{}, filterQuery interface{}, limitAndSort interface{}, confidenceLevel interface{}) *EVMService_QueryTrackedLogs_Call {
	return &EVMService_QueryTrackedLogs_Call{Call: _e.mock.On("QueryTrackedLogs", ctx, filterQuery, limitAndSort, confidenceLevel)}
}

func (_c *EVMService_QueryTrackedLogs_Call) Run(run func(ctx context.Context, filterQuery []query.Expression, limitAndSort query.LimitAndSort, confidenceLevel primitives.ConfidenceLevel)) *EVMService_QueryTrackedLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]query.Expression), args[2].(query.LimitAndSort), args[3].(primitives.ConfidenceLevel))
	})
	return _c
}

func (_c *EVMService_QueryTrackedLogs_Call) Return(_a0 []*evm.Log, _a1 error) *EVMService_QueryTrackedLogs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMService_QueryTrackedLogs_Call) RunAndReturn(run func(context.Context, []query.Expression, query.LimitAndSort, primitives.ConfidenceLevel) ([]*evm.Log, error)) *EVMService_QueryTrackedLogs_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterLogTracking provides a mock function with given fields: ctx, filter
func (_m *EVMService) RegisterLogTracking(ctx context.Context, filter evm.LPFilterQuery) error {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for RegisterLogTracking")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, evm.LPFilterQuery) error); ok {
		r0 = rf(ctx, filter)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// EVMService_RegisterLogTracking_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterLogTracking'
type EVMService_RegisterLogTracking_Call struct {
	*mock.Call
}

// RegisterLogTracking is a helper method to define mock.On call
//   - ctx context.Context
//   - filter evm.LPFilterQuery
func (_e *EVMService_Expecter) RegisterLogTracking(ctx interface{}, filter interface{}) *EVMService_RegisterLogTracking_Call {
	return &EVMService_RegisterLogTracking_Call{Call: _e.mock.On("RegisterLogTracking", ctx, filter)}
}

func (_c *EVMService_RegisterLogTracking_Call) Run(run func(ctx context.Context, filter evm.LPFilterQuery)) *EVMService_RegisterLogTracking_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(evm.LPFilterQuery))
	})
	return _c
}

func (_c *EVMService_RegisterLogTracking_Call) Return(_a0 error) *EVMService_RegisterLogTracking_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *EVMService_RegisterLogTracking_Call) RunAndReturn(run func(context.Context, evm.LPFilterQuery) error) *EVMService_RegisterLogTracking_Call {
	_c.Call.Return(run)
	return _c
}

// UnregisterLogTracking provides a mock function with given fields: ctx, filterName
func (_m *EVMService) UnregisterLogTracking(ctx context.Context, filterName string) error {
	ret := _m.Called(ctx, filterName)

	if len(ret) == 0 {
		panic("no return value specified for UnregisterLogTracking")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, filterName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// EVMService_UnregisterLogTracking_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnregisterLogTracking'
type EVMService_UnregisterLogTracking_Call struct {
	*mock.Call
}

// UnregisterLogTracking is a helper method to define mock.On call
//   - ctx context.Context
//   - filterName string
func (_e *EVMService_Expecter) UnregisterLogTracking(ctx interface{}, filterName interface{}) *EVMService_UnregisterLogTracking_Call {
	return &EVMService_UnregisterLogTracking_Call{Call: _e.mock.On("UnregisterLogTracking", ctx, filterName)}
}

func (_c *EVMService_UnregisterLogTracking_Call) Run(run func(ctx context.Context, filterName string)) *EVMService_UnregisterLogTracking_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *EVMService_UnregisterLogTracking_Call) Return(_a0 error) *EVMService_UnregisterLogTracking_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *EVMService_UnregisterLogTracking_Call) RunAndReturn(run func(context.Context, string) error) *EVMService_UnregisterLogTracking_Call {
	_c.Call.Return(run)
	return _c
}

// NewEVMService creates a new instance of EVMService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEVMService(t interface {
	mock.TestingT
	Cleanup(func())
}) *EVMService {
	mock := &EVMService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
