// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: chainaccessor.proto

package ccipocr3pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ChainAccessor_GetContractAddress_FullMethodName            = "/loop.internal.pb.ccipocr3.ChainAccessor/GetContractAddress"
	ChainAccessor_GetAllConfigsLegacy_FullMethodName           = "/loop.internal.pb.ccipocr3.ChainAccessor/GetAllConfigsLegacy"
	ChainAccessor_GetChainFeeComponents_FullMethodName         = "/loop.internal.pb.ccipocr3.ChainAccessor/GetChainFeeComponents"
	ChainAccessor_Sync_FullMethodName                          = "/loop.internal.pb.ccipocr3.ChainAccessor/Sync"
	ChainAccessor_CommitReportsGTETimestamp_FullMethodName     = "/loop.internal.pb.ccipocr3.ChainAccessor/CommitReportsGTETimestamp"
	ChainAccessor_ExecutedMessages_FullMethodName              = "/loop.internal.pb.ccipocr3.ChainAccessor/ExecutedMessages"
	ChainAccessor_NextSeqNum_FullMethodName                    = "/loop.internal.pb.ccipocr3.ChainAccessor/NextSeqNum"
	ChainAccessor_Nonces_FullMethodName                        = "/loop.internal.pb.ccipocr3.ChainAccessor/Nonces"
	ChainAccessor_GetChainFeePriceUpdate_FullMethodName        = "/loop.internal.pb.ccipocr3.ChainAccessor/GetChainFeePriceUpdate"
	ChainAccessor_GetLatestPriceSeqNr_FullMethodName           = "/loop.internal.pb.ccipocr3.ChainAccessor/GetLatestPriceSeqNr"
	ChainAccessor_MsgsBetweenSeqNums_FullMethodName            = "/loop.internal.pb.ccipocr3.ChainAccessor/MsgsBetweenSeqNums"
	ChainAccessor_LatestMessageTo_FullMethodName               = "/loop.internal.pb.ccipocr3.ChainAccessor/LatestMessageTo"
	ChainAccessor_GetExpectedNextSequenceNumber_FullMethodName = "/loop.internal.pb.ccipocr3.ChainAccessor/GetExpectedNextSequenceNumber"
	ChainAccessor_GetTokenPriceUSD_FullMethodName              = "/loop.internal.pb.ccipocr3.ChainAccessor/GetTokenPriceUSD"
	ChainAccessor_GetFeeQuoterDestChainConfig_FullMethodName   = "/loop.internal.pb.ccipocr3.ChainAccessor/GetFeeQuoterDestChainConfig"
)

// ChainAccessorClient is the client API for ChainAccessor service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ChainAccessor service for all direct chain access
type ChainAccessorClient interface {
	// AllAccessors methods
	GetContractAddress(ctx context.Context, in *GetContractAddressRequest, opts ...grpc.CallOption) (*GetContractAddressResponse, error)
	GetAllConfigsLegacy(ctx context.Context, in *GetAllConfigsLegacyRequest, opts ...grpc.CallOption) (*GetAllConfigsLegacyResponse, error)
	GetChainFeeComponents(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetChainFeeComponentsResponse, error)
	Sync(ctx context.Context, in *SyncRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DestinationAccessor methods
	CommitReportsGTETimestamp(ctx context.Context, in *CommitReportsGTETimestampRequest, opts ...grpc.CallOption) (*CommitReportsGTETimestampResponse, error)
	ExecutedMessages(ctx context.Context, in *ExecutedMessagesRequest, opts ...grpc.CallOption) (*ExecutedMessagesResponse, error)
	NextSeqNum(ctx context.Context, in *NextSeqNumRequest, opts ...grpc.CallOption) (*NextSeqNumResponse, error)
	Nonces(ctx context.Context, in *NoncesRequest, opts ...grpc.CallOption) (*NoncesResponse, error)
	GetChainFeePriceUpdate(ctx context.Context, in *GetChainFeePriceUpdateRequest, opts ...grpc.CallOption) (*GetChainFeePriceUpdateResponse, error)
	GetLatestPriceSeqNr(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetLatestPriceSeqNrResponse, error)
	// SourceAccessor methods
	MsgsBetweenSeqNums(ctx context.Context, in *MsgsBetweenSeqNumsRequest, opts ...grpc.CallOption) (*MsgsBetweenSeqNumsResponse, error)
	LatestMessageTo(ctx context.Context, in *LatestMessageToRequest, opts ...grpc.CallOption) (*LatestMessageToResponse, error)
	GetExpectedNextSequenceNumber(ctx context.Context, in *GetExpectedNextSequenceNumberRequest, opts ...grpc.CallOption) (*GetExpectedNextSequenceNumberResponse, error)
	GetTokenPriceUSD(ctx context.Context, in *GetTokenPriceUSDRequest, opts ...grpc.CallOption) (*GetTokenPriceUSDResponse, error)
	GetFeeQuoterDestChainConfig(ctx context.Context, in *GetFeeQuoterDestChainConfigRequest, opts ...grpc.CallOption) (*GetFeeQuoterDestChainConfigResponse, error)
}

type chainAccessorClient struct {
	cc grpc.ClientConnInterface
}

func NewChainAccessorClient(cc grpc.ClientConnInterface) ChainAccessorClient {
	return &chainAccessorClient{cc}
}

func (c *chainAccessorClient) GetContractAddress(ctx context.Context, in *GetContractAddressRequest, opts ...grpc.CallOption) (*GetContractAddressResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetContractAddressResponse)
	err := c.cc.Invoke(ctx, ChainAccessor_GetContractAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainAccessorClient) GetAllConfigsLegacy(ctx context.Context, in *GetAllConfigsLegacyRequest, opts ...grpc.CallOption) (*GetAllConfigsLegacyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllConfigsLegacyResponse)
	err := c.cc.Invoke(ctx, ChainAccessor_GetAllConfigsLegacy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainAccessorClient) GetChainFeeComponents(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetChainFeeComponentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetChainFeeComponentsResponse)
	err := c.cc.Invoke(ctx, ChainAccessor_GetChainFeeComponents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainAccessorClient) Sync(ctx context.Context, in *SyncRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChainAccessor_Sync_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainAccessorClient) CommitReportsGTETimestamp(ctx context.Context, in *CommitReportsGTETimestampRequest, opts ...grpc.CallOption) (*CommitReportsGTETimestampResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommitReportsGTETimestampResponse)
	err := c.cc.Invoke(ctx, ChainAccessor_CommitReportsGTETimestamp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainAccessorClient) ExecutedMessages(ctx context.Context, in *ExecutedMessagesRequest, opts ...grpc.CallOption) (*ExecutedMessagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecutedMessagesResponse)
	err := c.cc.Invoke(ctx, ChainAccessor_ExecutedMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainAccessorClient) NextSeqNum(ctx context.Context, in *NextSeqNumRequest, opts ...grpc.CallOption) (*NextSeqNumResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NextSeqNumResponse)
	err := c.cc.Invoke(ctx, ChainAccessor_NextSeqNum_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainAccessorClient) Nonces(ctx context.Context, in *NoncesRequest, opts ...grpc.CallOption) (*NoncesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NoncesResponse)
	err := c.cc.Invoke(ctx, ChainAccessor_Nonces_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainAccessorClient) GetChainFeePriceUpdate(ctx context.Context, in *GetChainFeePriceUpdateRequest, opts ...grpc.CallOption) (*GetChainFeePriceUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetChainFeePriceUpdateResponse)
	err := c.cc.Invoke(ctx, ChainAccessor_GetChainFeePriceUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainAccessorClient) GetLatestPriceSeqNr(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetLatestPriceSeqNrResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLatestPriceSeqNrResponse)
	err := c.cc.Invoke(ctx, ChainAccessor_GetLatestPriceSeqNr_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainAccessorClient) MsgsBetweenSeqNums(ctx context.Context, in *MsgsBetweenSeqNumsRequest, opts ...grpc.CallOption) (*MsgsBetweenSeqNumsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgsBetweenSeqNumsResponse)
	err := c.cc.Invoke(ctx, ChainAccessor_MsgsBetweenSeqNums_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainAccessorClient) LatestMessageTo(ctx context.Context, in *LatestMessageToRequest, opts ...grpc.CallOption) (*LatestMessageToResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LatestMessageToResponse)
	err := c.cc.Invoke(ctx, ChainAccessor_LatestMessageTo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainAccessorClient) GetExpectedNextSequenceNumber(ctx context.Context, in *GetExpectedNextSequenceNumberRequest, opts ...grpc.CallOption) (*GetExpectedNextSequenceNumberResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetExpectedNextSequenceNumberResponse)
	err := c.cc.Invoke(ctx, ChainAccessor_GetExpectedNextSequenceNumber_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainAccessorClient) GetTokenPriceUSD(ctx context.Context, in *GetTokenPriceUSDRequest, opts ...grpc.CallOption) (*GetTokenPriceUSDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTokenPriceUSDResponse)
	err := c.cc.Invoke(ctx, ChainAccessor_GetTokenPriceUSD_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainAccessorClient) GetFeeQuoterDestChainConfig(ctx context.Context, in *GetFeeQuoterDestChainConfigRequest, opts ...grpc.CallOption) (*GetFeeQuoterDestChainConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFeeQuoterDestChainConfigResponse)
	err := c.cc.Invoke(ctx, ChainAccessor_GetFeeQuoterDestChainConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChainAccessorServer is the server API for ChainAccessor service.
// All implementations must embed UnimplementedChainAccessorServer
// for forward compatibility.
//
// ChainAccessor service for all direct chain access
type ChainAccessorServer interface {
	// AllAccessors methods
	GetContractAddress(context.Context, *GetContractAddressRequest) (*GetContractAddressResponse, error)
	GetAllConfigsLegacy(context.Context, *GetAllConfigsLegacyRequest) (*GetAllConfigsLegacyResponse, error)
	GetChainFeeComponents(context.Context, *emptypb.Empty) (*GetChainFeeComponentsResponse, error)
	Sync(context.Context, *SyncRequest) (*emptypb.Empty, error)
	// DestinationAccessor methods
	CommitReportsGTETimestamp(context.Context, *CommitReportsGTETimestampRequest) (*CommitReportsGTETimestampResponse, error)
	ExecutedMessages(context.Context, *ExecutedMessagesRequest) (*ExecutedMessagesResponse, error)
	NextSeqNum(context.Context, *NextSeqNumRequest) (*NextSeqNumResponse, error)
	Nonces(context.Context, *NoncesRequest) (*NoncesResponse, error)
	GetChainFeePriceUpdate(context.Context, *GetChainFeePriceUpdateRequest) (*GetChainFeePriceUpdateResponse, error)
	GetLatestPriceSeqNr(context.Context, *emptypb.Empty) (*GetLatestPriceSeqNrResponse, error)
	// SourceAccessor methods
	MsgsBetweenSeqNums(context.Context, *MsgsBetweenSeqNumsRequest) (*MsgsBetweenSeqNumsResponse, error)
	LatestMessageTo(context.Context, *LatestMessageToRequest) (*LatestMessageToResponse, error)
	GetExpectedNextSequenceNumber(context.Context, *GetExpectedNextSequenceNumberRequest) (*GetExpectedNextSequenceNumberResponse, error)
	GetTokenPriceUSD(context.Context, *GetTokenPriceUSDRequest) (*GetTokenPriceUSDResponse, error)
	GetFeeQuoterDestChainConfig(context.Context, *GetFeeQuoterDestChainConfigRequest) (*GetFeeQuoterDestChainConfigResponse, error)
	mustEmbedUnimplementedChainAccessorServer()
}

// UnimplementedChainAccessorServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChainAccessorServer struct{}

func (UnimplementedChainAccessorServer) GetContractAddress(context.Context, *GetContractAddressRequest) (*GetContractAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetContractAddress not implemented")
}
func (UnimplementedChainAccessorServer) GetAllConfigsLegacy(context.Context, *GetAllConfigsLegacyRequest) (*GetAllConfigsLegacyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllConfigsLegacy not implemented")
}
func (UnimplementedChainAccessorServer) GetChainFeeComponents(context.Context, *emptypb.Empty) (*GetChainFeeComponentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChainFeeComponents not implemented")
}
func (UnimplementedChainAccessorServer) Sync(context.Context, *SyncRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sync not implemented")
}
func (UnimplementedChainAccessorServer) CommitReportsGTETimestamp(context.Context, *CommitReportsGTETimestampRequest) (*CommitReportsGTETimestampResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitReportsGTETimestamp not implemented")
}
func (UnimplementedChainAccessorServer) ExecutedMessages(context.Context, *ExecutedMessagesRequest) (*ExecutedMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecutedMessages not implemented")
}
func (UnimplementedChainAccessorServer) NextSeqNum(context.Context, *NextSeqNumRequest) (*NextSeqNumResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NextSeqNum not implemented")
}
func (UnimplementedChainAccessorServer) Nonces(context.Context, *NoncesRequest) (*NoncesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Nonces not implemented")
}
func (UnimplementedChainAccessorServer) GetChainFeePriceUpdate(context.Context, *GetChainFeePriceUpdateRequest) (*GetChainFeePriceUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChainFeePriceUpdate not implemented")
}
func (UnimplementedChainAccessorServer) GetLatestPriceSeqNr(context.Context, *emptypb.Empty) (*GetLatestPriceSeqNrResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLatestPriceSeqNr not implemented")
}
func (UnimplementedChainAccessorServer) MsgsBetweenSeqNums(context.Context, *MsgsBetweenSeqNumsRequest) (*MsgsBetweenSeqNumsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MsgsBetweenSeqNums not implemented")
}
func (UnimplementedChainAccessorServer) LatestMessageTo(context.Context, *LatestMessageToRequest) (*LatestMessageToResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LatestMessageTo not implemented")
}
func (UnimplementedChainAccessorServer) GetExpectedNextSequenceNumber(context.Context, *GetExpectedNextSequenceNumberRequest) (*GetExpectedNextSequenceNumberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExpectedNextSequenceNumber not implemented")
}
func (UnimplementedChainAccessorServer) GetTokenPriceUSD(context.Context, *GetTokenPriceUSDRequest) (*GetTokenPriceUSDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenPriceUSD not implemented")
}
func (UnimplementedChainAccessorServer) GetFeeQuoterDestChainConfig(context.Context, *GetFeeQuoterDestChainConfigRequest) (*GetFeeQuoterDestChainConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFeeQuoterDestChainConfig not implemented")
}
func (UnimplementedChainAccessorServer) mustEmbedUnimplementedChainAccessorServer() {}
func (UnimplementedChainAccessorServer) testEmbeddedByValue()                       {}

// UnsafeChainAccessorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChainAccessorServer will
// result in compilation errors.
type UnsafeChainAccessorServer interface {
	mustEmbedUnimplementedChainAccessorServer()
}

func RegisterChainAccessorServer(s grpc.ServiceRegistrar, srv ChainAccessorServer) {
	// If the following call pancis, it indicates UnimplementedChainAccessorServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ChainAccessor_ServiceDesc, srv)
}

func _ChainAccessor_GetContractAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetContractAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainAccessorServer).GetContractAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChainAccessor_GetContractAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainAccessorServer).GetContractAddress(ctx, req.(*GetContractAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainAccessor_GetAllConfigsLegacy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllConfigsLegacyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainAccessorServer).GetAllConfigsLegacy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChainAccessor_GetAllConfigsLegacy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainAccessorServer).GetAllConfigsLegacy(ctx, req.(*GetAllConfigsLegacyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainAccessor_GetChainFeeComponents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainAccessorServer).GetChainFeeComponents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChainAccessor_GetChainFeeComponents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainAccessorServer).GetChainFeeComponents(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainAccessor_Sync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainAccessorServer).Sync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChainAccessor_Sync_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainAccessorServer).Sync(ctx, req.(*SyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainAccessor_CommitReportsGTETimestamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitReportsGTETimestampRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainAccessorServer).CommitReportsGTETimestamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChainAccessor_CommitReportsGTETimestamp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainAccessorServer).CommitReportsGTETimestamp(ctx, req.(*CommitReportsGTETimestampRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainAccessor_ExecutedMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutedMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainAccessorServer).ExecutedMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChainAccessor_ExecutedMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainAccessorServer).ExecutedMessages(ctx, req.(*ExecutedMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainAccessor_NextSeqNum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NextSeqNumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainAccessorServer).NextSeqNum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChainAccessor_NextSeqNum_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainAccessorServer).NextSeqNum(ctx, req.(*NextSeqNumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainAccessor_Nonces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoncesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainAccessorServer).Nonces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChainAccessor_Nonces_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainAccessorServer).Nonces(ctx, req.(*NoncesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainAccessor_GetChainFeePriceUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChainFeePriceUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainAccessorServer).GetChainFeePriceUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChainAccessor_GetChainFeePriceUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainAccessorServer).GetChainFeePriceUpdate(ctx, req.(*GetChainFeePriceUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainAccessor_GetLatestPriceSeqNr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainAccessorServer).GetLatestPriceSeqNr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChainAccessor_GetLatestPriceSeqNr_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainAccessorServer).GetLatestPriceSeqNr(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainAccessor_MsgsBetweenSeqNums_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgsBetweenSeqNumsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainAccessorServer).MsgsBetweenSeqNums(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChainAccessor_MsgsBetweenSeqNums_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainAccessorServer).MsgsBetweenSeqNums(ctx, req.(*MsgsBetweenSeqNumsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainAccessor_LatestMessageTo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LatestMessageToRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainAccessorServer).LatestMessageTo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChainAccessor_LatestMessageTo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainAccessorServer).LatestMessageTo(ctx, req.(*LatestMessageToRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainAccessor_GetExpectedNextSequenceNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExpectedNextSequenceNumberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainAccessorServer).GetExpectedNextSequenceNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChainAccessor_GetExpectedNextSequenceNumber_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainAccessorServer).GetExpectedNextSequenceNumber(ctx, req.(*GetExpectedNextSequenceNumberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainAccessor_GetTokenPriceUSD_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenPriceUSDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainAccessorServer).GetTokenPriceUSD(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChainAccessor_GetTokenPriceUSD_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainAccessorServer).GetTokenPriceUSD(ctx, req.(*GetTokenPriceUSDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainAccessor_GetFeeQuoterDestChainConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFeeQuoterDestChainConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainAccessorServer).GetFeeQuoterDestChainConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChainAccessor_GetFeeQuoterDestChainConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainAccessorServer).GetFeeQuoterDestChainConfig(ctx, req.(*GetFeeQuoterDestChainConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChainAccessor_ServiceDesc is the grpc.ServiceDesc for ChainAccessor service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChainAccessor_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.internal.pb.ccipocr3.ChainAccessor",
	HandlerType: (*ChainAccessorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetContractAddress",
			Handler:    _ChainAccessor_GetContractAddress_Handler,
		},
		{
			MethodName: "GetAllConfigsLegacy",
			Handler:    _ChainAccessor_GetAllConfigsLegacy_Handler,
		},
		{
			MethodName: "GetChainFeeComponents",
			Handler:    _ChainAccessor_GetChainFeeComponents_Handler,
		},
		{
			MethodName: "Sync",
			Handler:    _ChainAccessor_Sync_Handler,
		},
		{
			MethodName: "CommitReportsGTETimestamp",
			Handler:    _ChainAccessor_CommitReportsGTETimestamp_Handler,
		},
		{
			MethodName: "ExecutedMessages",
			Handler:    _ChainAccessor_ExecutedMessages_Handler,
		},
		{
			MethodName: "NextSeqNum",
			Handler:    _ChainAccessor_NextSeqNum_Handler,
		},
		{
			MethodName: "Nonces",
			Handler:    _ChainAccessor_Nonces_Handler,
		},
		{
			MethodName: "GetChainFeePriceUpdate",
			Handler:    _ChainAccessor_GetChainFeePriceUpdate_Handler,
		},
		{
			MethodName: "GetLatestPriceSeqNr",
			Handler:    _ChainAccessor_GetLatestPriceSeqNr_Handler,
		},
		{
			MethodName: "MsgsBetweenSeqNums",
			Handler:    _ChainAccessor_MsgsBetweenSeqNums_Handler,
		},
		{
			MethodName: "LatestMessageTo",
			Handler:    _ChainAccessor_LatestMessageTo_Handler,
		},
		{
			MethodName: "GetExpectedNextSequenceNumber",
			Handler:    _ChainAccessor_GetExpectedNextSequenceNumber_Handler,
		},
		{
			MethodName: "GetTokenPriceUSD",
			Handler:    _ChainAccessor_GetTokenPriceUSD_Handler,
		},
		{
			MethodName: "GetFeeQuoterDestChainConfig",
			Handler:    _ChainAccessor_GetFeeQuoterDestChainConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "chainaccessor.proto",
}
