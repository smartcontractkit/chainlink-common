// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: loop/internal/pb/relayerset/relayerset.proto

package relayerset

import (
	context "context"
	chain_service "github.com/smartcontractkit/chainlink-common/pkg/loop/chain-capabilities/evm/chain-service"
	pb "github.com/smartcontractkit/chainlink-common/pkg/loop/internal/pb"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	RelayerSet_Get_FullMethodName                                      = "/loop.relayerset.RelayerSet/Get"
	RelayerSet_List_FullMethodName                                     = "/loop.relayerset.RelayerSet/List"
	RelayerSet_NewPluginProvider_FullMethodName                        = "/loop.relayerset.RelayerSet/NewPluginProvider"
	RelayerSet_NewContractReader_FullMethodName                        = "/loop.relayerset.RelayerSet/NewContractReader"
	RelayerSet_NewContractWriter_FullMethodName                        = "/loop.relayerset.RelayerSet/NewContractWriter"
	RelayerSet_StartRelayer_FullMethodName                             = "/loop.relayerset.RelayerSet/StartRelayer"
	RelayerSet_CloseRelayer_FullMethodName                             = "/loop.relayerset.RelayerSet/CloseRelayer"
	RelayerSet_RelayerReady_FullMethodName                             = "/loop.relayerset.RelayerSet/RelayerReady"
	RelayerSet_RelayerHealthReport_FullMethodName                      = "/loop.relayerset.RelayerSet/RelayerHealthReport"
	RelayerSet_RelayerName_FullMethodName                              = "/loop.relayerset.RelayerSet/RelayerName"
	RelayerSet_RelayerLatestHead_FullMethodName                        = "/loop.relayerset.RelayerSet/RelayerLatestHead"
	RelayerSet_ContractReaderGetLatestValue_FullMethodName             = "/loop.relayerset.RelayerSet/ContractReaderGetLatestValue"
	RelayerSet_ContractReaderGetLatestValueWithHeadData_FullMethodName = "/loop.relayerset.RelayerSet/ContractReaderGetLatestValueWithHeadData"
	RelayerSet_ContractReaderBatchGetLatestValues_FullMethodName       = "/loop.relayerset.RelayerSet/ContractReaderBatchGetLatestValues"
	RelayerSet_ContractReaderQueryKey_FullMethodName                   = "/loop.relayerset.RelayerSet/ContractReaderQueryKey"
	RelayerSet_ContractReaderQueryKeys_FullMethodName                  = "/loop.relayerset.RelayerSet/ContractReaderQueryKeys"
	RelayerSet_ContractReaderBind_FullMethodName                       = "/loop.relayerset.RelayerSet/ContractReaderBind"
	RelayerSet_ContractReaderUnbind_FullMethodName                     = "/loop.relayerset.RelayerSet/ContractReaderUnbind"
	RelayerSet_ContractReaderStart_FullMethodName                      = "/loop.relayerset.RelayerSet/ContractReaderStart"
	RelayerSet_ContractReaderClose_FullMethodName                      = "/loop.relayerset.RelayerSet/ContractReaderClose"
)

// RelayerSetClient is the client API for RelayerSet service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RelayerSetClient interface {
	Get(ctx context.Context, in *GetRelayerRequest, opts ...grpc.CallOption) (*GetRelayerResponse, error)
	List(ctx context.Context, in *ListAllRelayersRequest, opts ...grpc.CallOption) (*ListAllRelayersResponse, error)
	NewPluginProvider(ctx context.Context, in *NewPluginProviderRequest, opts ...grpc.CallOption) (*NewPluginProviderResponse, error)
	NewContractReader(ctx context.Context, in *NewContractReaderRequest, opts ...grpc.CallOption) (*NewContractReaderResponse, error)
	NewContractWriter(ctx context.Context, in *NewContractWriterRequest, opts ...grpc.CallOption) (*NewContractWriterResponse, error)
	StartRelayer(ctx context.Context, in *RelayerId, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CloseRelayer(ctx context.Context, in *RelayerId, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RelayerReady(ctx context.Context, in *RelayerId, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RelayerHealthReport(ctx context.Context, in *RelayerId, opts ...grpc.CallOption) (*RelayerHealthReportResponse, error)
	RelayerName(ctx context.Context, in *RelayerId, opts ...grpc.CallOption) (*RelayerNameResponse, error)
	RelayerLatestHead(ctx context.Context, in *LatestHeadRequest, opts ...grpc.CallOption) (*LatestHeadResponse, error)
	ContractReaderGetLatestValue(ctx context.Context, in *ContractReaderGetLatestValueRequest, opts ...grpc.CallOption) (*pb.GetLatestValueReply, error)
	ContractReaderGetLatestValueWithHeadData(ctx context.Context, in *ContractReaderGetLatestValueRequest, opts ...grpc.CallOption) (*pb.GetLatestValueWithHeadDataReply, error)
	ContractReaderBatchGetLatestValues(ctx context.Context, in *ContractReaderBatchGetLatestValuesRequest, opts ...grpc.CallOption) (*pb.BatchGetLatestValuesReply, error)
	ContractReaderQueryKey(ctx context.Context, in *ContractReaderQueryKeyRequest, opts ...grpc.CallOption) (*pb.QueryKeyReply, error)
	ContractReaderQueryKeys(ctx context.Context, in *ContractReaderQueryKeysRequest, opts ...grpc.CallOption) (*pb.QueryKeysReply, error)
	ContractReaderBind(ctx context.Context, in *ContractReaderBindRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ContractReaderUnbind(ctx context.Context, in *ContractReaderUnbindRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ContractReaderStart(ctx context.Context, in *ContractReaderStartRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ContractReaderClose(ctx context.Context, in *ContractReaderCloseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type relayerSetClient struct {
	cc grpc.ClientConnInterface
}

func NewRelayerSetClient(cc grpc.ClientConnInterface) RelayerSetClient {
	return &relayerSetClient{cc}
}

func (c *relayerSetClient) Get(ctx context.Context, in *GetRelayerRequest, opts ...grpc.CallOption) (*GetRelayerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRelayerResponse)
	err := c.cc.Invoke(ctx, RelayerSet_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerSetClient) List(ctx context.Context, in *ListAllRelayersRequest, opts ...grpc.CallOption) (*ListAllRelayersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAllRelayersResponse)
	err := c.cc.Invoke(ctx, RelayerSet_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerSetClient) NewPluginProvider(ctx context.Context, in *NewPluginProviderRequest, opts ...grpc.CallOption) (*NewPluginProviderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NewPluginProviderResponse)
	err := c.cc.Invoke(ctx, RelayerSet_NewPluginProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerSetClient) NewContractReader(ctx context.Context, in *NewContractReaderRequest, opts ...grpc.CallOption) (*NewContractReaderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NewContractReaderResponse)
	err := c.cc.Invoke(ctx, RelayerSet_NewContractReader_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerSetClient) NewContractWriter(ctx context.Context, in *NewContractWriterRequest, opts ...grpc.CallOption) (*NewContractWriterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NewContractWriterResponse)
	err := c.cc.Invoke(ctx, RelayerSet_NewContractWriter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerSetClient) StartRelayer(ctx context.Context, in *RelayerId, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RelayerSet_StartRelayer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerSetClient) CloseRelayer(ctx context.Context, in *RelayerId, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RelayerSet_CloseRelayer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerSetClient) RelayerReady(ctx context.Context, in *RelayerId, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RelayerSet_RelayerReady_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerSetClient) RelayerHealthReport(ctx context.Context, in *RelayerId, opts ...grpc.CallOption) (*RelayerHealthReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RelayerHealthReportResponse)
	err := c.cc.Invoke(ctx, RelayerSet_RelayerHealthReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerSetClient) RelayerName(ctx context.Context, in *RelayerId, opts ...grpc.CallOption) (*RelayerNameResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RelayerNameResponse)
	err := c.cc.Invoke(ctx, RelayerSet_RelayerName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerSetClient) RelayerLatestHead(ctx context.Context, in *LatestHeadRequest, opts ...grpc.CallOption) (*LatestHeadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LatestHeadResponse)
	err := c.cc.Invoke(ctx, RelayerSet_RelayerLatestHead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerSetClient) ContractReaderGetLatestValue(ctx context.Context, in *ContractReaderGetLatestValueRequest, opts ...grpc.CallOption) (*pb.GetLatestValueReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(pb.GetLatestValueReply)
	err := c.cc.Invoke(ctx, RelayerSet_ContractReaderGetLatestValue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerSetClient) ContractReaderGetLatestValueWithHeadData(ctx context.Context, in *ContractReaderGetLatestValueRequest, opts ...grpc.CallOption) (*pb.GetLatestValueWithHeadDataReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(pb.GetLatestValueWithHeadDataReply)
	err := c.cc.Invoke(ctx, RelayerSet_ContractReaderGetLatestValueWithHeadData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerSetClient) ContractReaderBatchGetLatestValues(ctx context.Context, in *ContractReaderBatchGetLatestValuesRequest, opts ...grpc.CallOption) (*pb.BatchGetLatestValuesReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(pb.BatchGetLatestValuesReply)
	err := c.cc.Invoke(ctx, RelayerSet_ContractReaderBatchGetLatestValues_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerSetClient) ContractReaderQueryKey(ctx context.Context, in *ContractReaderQueryKeyRequest, opts ...grpc.CallOption) (*pb.QueryKeyReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(pb.QueryKeyReply)
	err := c.cc.Invoke(ctx, RelayerSet_ContractReaderQueryKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerSetClient) ContractReaderQueryKeys(ctx context.Context, in *ContractReaderQueryKeysRequest, opts ...grpc.CallOption) (*pb.QueryKeysReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(pb.QueryKeysReply)
	err := c.cc.Invoke(ctx, RelayerSet_ContractReaderQueryKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerSetClient) ContractReaderBind(ctx context.Context, in *ContractReaderBindRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RelayerSet_ContractReaderBind_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerSetClient) ContractReaderUnbind(ctx context.Context, in *ContractReaderUnbindRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RelayerSet_ContractReaderUnbind_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerSetClient) ContractReaderStart(ctx context.Context, in *ContractReaderStartRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RelayerSet_ContractReaderStart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerSetClient) ContractReaderClose(ctx context.Context, in *ContractReaderCloseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RelayerSet_ContractReaderClose_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RelayerSetServer is the server API for RelayerSet service.
// All implementations must embed UnimplementedRelayerSetServer
// for forward compatibility.
type RelayerSetServer interface {
	Get(context.Context, *GetRelayerRequest) (*GetRelayerResponse, error)
	List(context.Context, *ListAllRelayersRequest) (*ListAllRelayersResponse, error)
	NewPluginProvider(context.Context, *NewPluginProviderRequest) (*NewPluginProviderResponse, error)
	NewContractReader(context.Context, *NewContractReaderRequest) (*NewContractReaderResponse, error)
	NewContractWriter(context.Context, *NewContractWriterRequest) (*NewContractWriterResponse, error)
	StartRelayer(context.Context, *RelayerId) (*emptypb.Empty, error)
	CloseRelayer(context.Context, *RelayerId) (*emptypb.Empty, error)
	RelayerReady(context.Context, *RelayerId) (*emptypb.Empty, error)
	RelayerHealthReport(context.Context, *RelayerId) (*RelayerHealthReportResponse, error)
	RelayerName(context.Context, *RelayerId) (*RelayerNameResponse, error)
	RelayerLatestHead(context.Context, *LatestHeadRequest) (*LatestHeadResponse, error)
	ContractReaderGetLatestValue(context.Context, *ContractReaderGetLatestValueRequest) (*pb.GetLatestValueReply, error)
	ContractReaderGetLatestValueWithHeadData(context.Context, *ContractReaderGetLatestValueRequest) (*pb.GetLatestValueWithHeadDataReply, error)
	ContractReaderBatchGetLatestValues(context.Context, *ContractReaderBatchGetLatestValuesRequest) (*pb.BatchGetLatestValuesReply, error)
	ContractReaderQueryKey(context.Context, *ContractReaderQueryKeyRequest) (*pb.QueryKeyReply, error)
	ContractReaderQueryKeys(context.Context, *ContractReaderQueryKeysRequest) (*pb.QueryKeysReply, error)
	ContractReaderBind(context.Context, *ContractReaderBindRequest) (*emptypb.Empty, error)
	ContractReaderUnbind(context.Context, *ContractReaderUnbindRequest) (*emptypb.Empty, error)
	ContractReaderStart(context.Context, *ContractReaderStartRequest) (*emptypb.Empty, error)
	ContractReaderClose(context.Context, *ContractReaderCloseRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedRelayerSetServer()
}

// UnimplementedRelayerSetServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRelayerSetServer struct{}

func (UnimplementedRelayerSetServer) Get(context.Context, *GetRelayerRequest) (*GetRelayerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRelayerSetServer) List(context.Context, *ListAllRelayersRequest) (*ListAllRelayersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRelayerSetServer) NewPluginProvider(context.Context, *NewPluginProviderRequest) (*NewPluginProviderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewPluginProvider not implemented")
}
func (UnimplementedRelayerSetServer) NewContractReader(context.Context, *NewContractReaderRequest) (*NewContractReaderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewContractReader not implemented")
}
func (UnimplementedRelayerSetServer) NewContractWriter(context.Context, *NewContractWriterRequest) (*NewContractWriterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewContractWriter not implemented")
}
func (UnimplementedRelayerSetServer) StartRelayer(context.Context, *RelayerId) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartRelayer not implemented")
}
func (UnimplementedRelayerSetServer) CloseRelayer(context.Context, *RelayerId) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseRelayer not implemented")
}
func (UnimplementedRelayerSetServer) RelayerReady(context.Context, *RelayerId) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RelayerReady not implemented")
}
func (UnimplementedRelayerSetServer) RelayerHealthReport(context.Context, *RelayerId) (*RelayerHealthReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RelayerHealthReport not implemented")
}
func (UnimplementedRelayerSetServer) RelayerName(context.Context, *RelayerId) (*RelayerNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RelayerName not implemented")
}
func (UnimplementedRelayerSetServer) RelayerLatestHead(context.Context, *LatestHeadRequest) (*LatestHeadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RelayerLatestHead not implemented")
}
func (UnimplementedRelayerSetServer) ContractReaderGetLatestValue(context.Context, *ContractReaderGetLatestValueRequest) (*pb.GetLatestValueReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractReaderGetLatestValue not implemented")
}
func (UnimplementedRelayerSetServer) ContractReaderGetLatestValueWithHeadData(context.Context, *ContractReaderGetLatestValueRequest) (*pb.GetLatestValueWithHeadDataReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractReaderGetLatestValueWithHeadData not implemented")
}
func (UnimplementedRelayerSetServer) ContractReaderBatchGetLatestValues(context.Context, *ContractReaderBatchGetLatestValuesRequest) (*pb.BatchGetLatestValuesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractReaderBatchGetLatestValues not implemented")
}
func (UnimplementedRelayerSetServer) ContractReaderQueryKey(context.Context, *ContractReaderQueryKeyRequest) (*pb.QueryKeyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractReaderQueryKey not implemented")
}
func (UnimplementedRelayerSetServer) ContractReaderQueryKeys(context.Context, *ContractReaderQueryKeysRequest) (*pb.QueryKeysReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractReaderQueryKeys not implemented")
}
func (UnimplementedRelayerSetServer) ContractReaderBind(context.Context, *ContractReaderBindRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractReaderBind not implemented")
}
func (UnimplementedRelayerSetServer) ContractReaderUnbind(context.Context, *ContractReaderUnbindRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractReaderUnbind not implemented")
}
func (UnimplementedRelayerSetServer) ContractReaderStart(context.Context, *ContractReaderStartRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractReaderStart not implemented")
}
func (UnimplementedRelayerSetServer) ContractReaderClose(context.Context, *ContractReaderCloseRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractReaderClose not implemented")
}
func (UnimplementedRelayerSetServer) mustEmbedUnimplementedRelayerSetServer() {}
func (UnimplementedRelayerSetServer) testEmbeddedByValue()                    {}

// UnsafeRelayerSetServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RelayerSetServer will
// result in compilation errors.
type UnsafeRelayerSetServer interface {
	mustEmbedUnimplementedRelayerSetServer()
}

func RegisterRelayerSetServer(s grpc.ServiceRegistrar, srv RelayerSetServer) {
	// If the following call pancis, it indicates UnimplementedRelayerSetServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RelayerSet_ServiceDesc, srv)
}

func _RelayerSet_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRelayerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).Get(ctx, req.(*GetRelayerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerSet_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAllRelayersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).List(ctx, req.(*ListAllRelayersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerSet_NewPluginProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewPluginProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).NewPluginProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_NewPluginProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).NewPluginProvider(ctx, req.(*NewPluginProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerSet_NewContractReader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewContractReaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).NewContractReader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_NewContractReader_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).NewContractReader(ctx, req.(*NewContractReaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerSet_NewContractWriter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewContractWriterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).NewContractWriter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_NewContractWriter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).NewContractWriter(ctx, req.(*NewContractWriterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerSet_StartRelayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RelayerId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).StartRelayer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_StartRelayer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).StartRelayer(ctx, req.(*RelayerId))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerSet_CloseRelayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RelayerId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).CloseRelayer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_CloseRelayer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).CloseRelayer(ctx, req.(*RelayerId))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerSet_RelayerReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RelayerId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).RelayerReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_RelayerReady_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).RelayerReady(ctx, req.(*RelayerId))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerSet_RelayerHealthReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RelayerId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).RelayerHealthReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_RelayerHealthReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).RelayerHealthReport(ctx, req.(*RelayerId))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerSet_RelayerName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RelayerId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).RelayerName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_RelayerName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).RelayerName(ctx, req.(*RelayerId))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerSet_RelayerLatestHead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LatestHeadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).RelayerLatestHead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_RelayerLatestHead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).RelayerLatestHead(ctx, req.(*LatestHeadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerSet_ContractReaderGetLatestValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractReaderGetLatestValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).ContractReaderGetLatestValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_ContractReaderGetLatestValue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).ContractReaderGetLatestValue(ctx, req.(*ContractReaderGetLatestValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerSet_ContractReaderGetLatestValueWithHeadData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractReaderGetLatestValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).ContractReaderGetLatestValueWithHeadData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_ContractReaderGetLatestValueWithHeadData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).ContractReaderGetLatestValueWithHeadData(ctx, req.(*ContractReaderGetLatestValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerSet_ContractReaderBatchGetLatestValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractReaderBatchGetLatestValuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).ContractReaderBatchGetLatestValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_ContractReaderBatchGetLatestValues_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).ContractReaderBatchGetLatestValues(ctx, req.(*ContractReaderBatchGetLatestValuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerSet_ContractReaderQueryKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractReaderQueryKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).ContractReaderQueryKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_ContractReaderQueryKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).ContractReaderQueryKey(ctx, req.(*ContractReaderQueryKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerSet_ContractReaderQueryKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractReaderQueryKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).ContractReaderQueryKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_ContractReaderQueryKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).ContractReaderQueryKeys(ctx, req.(*ContractReaderQueryKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerSet_ContractReaderBind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractReaderBindRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).ContractReaderBind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_ContractReaderBind_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).ContractReaderBind(ctx, req.(*ContractReaderBindRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerSet_ContractReaderUnbind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractReaderUnbindRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).ContractReaderUnbind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_ContractReaderUnbind_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).ContractReaderUnbind(ctx, req.(*ContractReaderUnbindRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerSet_ContractReaderStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractReaderStartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).ContractReaderStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_ContractReaderStart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).ContractReaderStart(ctx, req.(*ContractReaderStartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerSet_ContractReaderClose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractReaderCloseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerSetServer).ContractReaderClose(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerSet_ContractReaderClose_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerSetServer).ContractReaderClose(ctx, req.(*ContractReaderCloseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RelayerSet_ServiceDesc is the grpc.ServiceDesc for RelayerSet service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RelayerSet_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.relayerset.RelayerSet",
	HandlerType: (*RelayerSetServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _RelayerSet_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RelayerSet_List_Handler,
		},
		{
			MethodName: "NewPluginProvider",
			Handler:    _RelayerSet_NewPluginProvider_Handler,
		},
		{
			MethodName: "NewContractReader",
			Handler:    _RelayerSet_NewContractReader_Handler,
		},
		{
			MethodName: "NewContractWriter",
			Handler:    _RelayerSet_NewContractWriter_Handler,
		},
		{
			MethodName: "StartRelayer",
			Handler:    _RelayerSet_StartRelayer_Handler,
		},
		{
			MethodName: "CloseRelayer",
			Handler:    _RelayerSet_CloseRelayer_Handler,
		},
		{
			MethodName: "RelayerReady",
			Handler:    _RelayerSet_RelayerReady_Handler,
		},
		{
			MethodName: "RelayerHealthReport",
			Handler:    _RelayerSet_RelayerHealthReport_Handler,
		},
		{
			MethodName: "RelayerName",
			Handler:    _RelayerSet_RelayerName_Handler,
		},
		{
			MethodName: "RelayerLatestHead",
			Handler:    _RelayerSet_RelayerLatestHead_Handler,
		},
		{
			MethodName: "ContractReaderGetLatestValue",
			Handler:    _RelayerSet_ContractReaderGetLatestValue_Handler,
		},
		{
			MethodName: "ContractReaderGetLatestValueWithHeadData",
			Handler:    _RelayerSet_ContractReaderGetLatestValueWithHeadData_Handler,
		},
		{
			MethodName: "ContractReaderBatchGetLatestValues",
			Handler:    _RelayerSet_ContractReaderBatchGetLatestValues_Handler,
		},
		{
			MethodName: "ContractReaderQueryKey",
			Handler:    _RelayerSet_ContractReaderQueryKey_Handler,
		},
		{
			MethodName: "ContractReaderQueryKeys",
			Handler:    _RelayerSet_ContractReaderQueryKeys_Handler,
		},
		{
			MethodName: "ContractReaderBind",
			Handler:    _RelayerSet_ContractReaderBind_Handler,
		},
		{
			MethodName: "ContractReaderUnbind",
			Handler:    _RelayerSet_ContractReaderUnbind_Handler,
		},
		{
			MethodName: "ContractReaderStart",
			Handler:    _RelayerSet_ContractReaderStart_Handler,
		},
		{
			MethodName: "ContractReaderClose",
			Handler:    _RelayerSet_ContractReaderClose_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "loop/internal/pb/relayerset/relayerset.proto",
}

const (
	EVMRelayerSet_GetTransactionFee_FullMethodName      = "/loop.relayerset.EVMRelayerSet/GetTransactionFee"
	EVMRelayerSet_CallContract_FullMethodName           = "/loop.relayerset.EVMRelayerSet/CallContract"
	EVMRelayerSet_FilterLogs_FullMethodName             = "/loop.relayerset.EVMRelayerSet/FilterLogs"
	EVMRelayerSet_BalanceAt_FullMethodName              = "/loop.relayerset.EVMRelayerSet/BalanceAt"
	EVMRelayerSet_EstimateGas_FullMethodName            = "/loop.relayerset.EVMRelayerSet/EstimateGas"
	EVMRelayerSet_GetTransactionByHash_FullMethodName   = "/loop.relayerset.EVMRelayerSet/GetTransactionByHash"
	EVMRelayerSet_GetTransactionReceipt_FullMethodName  = "/loop.relayerset.EVMRelayerSet/GetTransactionReceipt"
	EVMRelayerSet_LatestAndFinalizedHead_FullMethodName = "/loop.relayerset.EVMRelayerSet/LatestAndFinalizedHead"
	EVMRelayerSet_QueryTrackedLogs_FullMethodName       = "/loop.relayerset.EVMRelayerSet/QueryTrackedLogs"
	EVMRelayerSet_RegisterLogTracking_FullMethodName    = "/loop.relayerset.EVMRelayerSet/RegisterLogTracking"
	EVMRelayerSet_UnregisterLogTracking_FullMethodName  = "/loop.relayerset.EVMRelayerSet/UnregisterLogTracking"
	EVMRelayerSet_GetTransactionStatus_FullMethodName   = "/loop.relayerset.EVMRelayerSet/GetTransactionStatus"
)

// EVMRelayerSetClient is the client API for EVMRelayerSet service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EVMRelayerSetClient interface {
	GetTransactionFee(ctx context.Context, in *GetTransactionFeeRequest, opts ...grpc.CallOption) (*chain_service.GetTransactionFeeReply, error)
	CallContract(ctx context.Context, in *CallContractRequest, opts ...grpc.CallOption) (*chain_service.CallContractReply, error)
	FilterLogs(ctx context.Context, in *FilterLogsRequest, opts ...grpc.CallOption) (*chain_service.FilterLogsReply, error)
	BalanceAt(ctx context.Context, in *BalanceAtRequest, opts ...grpc.CallOption) (*chain_service.BalanceAtReply, error)
	EstimateGas(ctx context.Context, in *EstimateGasRequest, opts ...grpc.CallOption) (*chain_service.EstimateGasReply, error)
	GetTransactionByHash(ctx context.Context, in *GetTransactionByHashRequest, opts ...grpc.CallOption) (*chain_service.GetTransactionByHashReply, error)
	GetTransactionReceipt(ctx context.Context, in *GetTransactionReceiptRequest, opts ...grpc.CallOption) (*chain_service.GetTransactionReceiptReply, error)
	LatestAndFinalizedHead(ctx context.Context, in *LatestHeadRequest, opts ...grpc.CallOption) (*chain_service.LatestAndFinalizedHeadReply, error)
	QueryTrackedLogs(ctx context.Context, in *QueryTrackedLogsRequest, opts ...grpc.CallOption) (*chain_service.QueryTrackedLogsReply, error)
	RegisterLogTracking(ctx context.Context, in *RegisterLogTrackingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UnregisterLogTracking(ctx context.Context, in *UnregisterLogTrackingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetTransactionStatus(ctx context.Context, in *GetTransactionStatusRequest, opts ...grpc.CallOption) (*pb.GetTransactionStatusReply, error)
}

type eVMRelayerSetClient struct {
	cc grpc.ClientConnInterface
}

func NewEVMRelayerSetClient(cc grpc.ClientConnInterface) EVMRelayerSetClient {
	return &eVMRelayerSetClient{cc}
}

func (c *eVMRelayerSetClient) GetTransactionFee(ctx context.Context, in *GetTransactionFeeRequest, opts ...grpc.CallOption) (*chain_service.GetTransactionFeeReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(chain_service.GetTransactionFeeReply)
	err := c.cc.Invoke(ctx, EVMRelayerSet_GetTransactionFee_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eVMRelayerSetClient) CallContract(ctx context.Context, in *CallContractRequest, opts ...grpc.CallOption) (*chain_service.CallContractReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(chain_service.CallContractReply)
	err := c.cc.Invoke(ctx, EVMRelayerSet_CallContract_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eVMRelayerSetClient) FilterLogs(ctx context.Context, in *FilterLogsRequest, opts ...grpc.CallOption) (*chain_service.FilterLogsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(chain_service.FilterLogsReply)
	err := c.cc.Invoke(ctx, EVMRelayerSet_FilterLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eVMRelayerSetClient) BalanceAt(ctx context.Context, in *BalanceAtRequest, opts ...grpc.CallOption) (*chain_service.BalanceAtReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(chain_service.BalanceAtReply)
	err := c.cc.Invoke(ctx, EVMRelayerSet_BalanceAt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eVMRelayerSetClient) EstimateGas(ctx context.Context, in *EstimateGasRequest, opts ...grpc.CallOption) (*chain_service.EstimateGasReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(chain_service.EstimateGasReply)
	err := c.cc.Invoke(ctx, EVMRelayerSet_EstimateGas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eVMRelayerSetClient) GetTransactionByHash(ctx context.Context, in *GetTransactionByHashRequest, opts ...grpc.CallOption) (*chain_service.GetTransactionByHashReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(chain_service.GetTransactionByHashReply)
	err := c.cc.Invoke(ctx, EVMRelayerSet_GetTransactionByHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eVMRelayerSetClient) GetTransactionReceipt(ctx context.Context, in *GetTransactionReceiptRequest, opts ...grpc.CallOption) (*chain_service.GetTransactionReceiptReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(chain_service.GetTransactionReceiptReply)
	err := c.cc.Invoke(ctx, EVMRelayerSet_GetTransactionReceipt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eVMRelayerSetClient) LatestAndFinalizedHead(ctx context.Context, in *LatestHeadRequest, opts ...grpc.CallOption) (*chain_service.LatestAndFinalizedHeadReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(chain_service.LatestAndFinalizedHeadReply)
	err := c.cc.Invoke(ctx, EVMRelayerSet_LatestAndFinalizedHead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eVMRelayerSetClient) QueryTrackedLogs(ctx context.Context, in *QueryTrackedLogsRequest, opts ...grpc.CallOption) (*chain_service.QueryTrackedLogsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(chain_service.QueryTrackedLogsReply)
	err := c.cc.Invoke(ctx, EVMRelayerSet_QueryTrackedLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eVMRelayerSetClient) RegisterLogTracking(ctx context.Context, in *RegisterLogTrackingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, EVMRelayerSet_RegisterLogTracking_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eVMRelayerSetClient) UnregisterLogTracking(ctx context.Context, in *UnregisterLogTrackingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, EVMRelayerSet_UnregisterLogTracking_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eVMRelayerSetClient) GetTransactionStatus(ctx context.Context, in *GetTransactionStatusRequest, opts ...grpc.CallOption) (*pb.GetTransactionStatusReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(pb.GetTransactionStatusReply)
	err := c.cc.Invoke(ctx, EVMRelayerSet_GetTransactionStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EVMRelayerSetServer is the server API for EVMRelayerSet service.
// All implementations must embed UnimplementedEVMRelayerSetServer
// for forward compatibility.
type EVMRelayerSetServer interface {
	GetTransactionFee(context.Context, *GetTransactionFeeRequest) (*chain_service.GetTransactionFeeReply, error)
	CallContract(context.Context, *CallContractRequest) (*chain_service.CallContractReply, error)
	FilterLogs(context.Context, *FilterLogsRequest) (*chain_service.FilterLogsReply, error)
	BalanceAt(context.Context, *BalanceAtRequest) (*chain_service.BalanceAtReply, error)
	EstimateGas(context.Context, *EstimateGasRequest) (*chain_service.EstimateGasReply, error)
	GetTransactionByHash(context.Context, *GetTransactionByHashRequest) (*chain_service.GetTransactionByHashReply, error)
	GetTransactionReceipt(context.Context, *GetTransactionReceiptRequest) (*chain_service.GetTransactionReceiptReply, error)
	LatestAndFinalizedHead(context.Context, *LatestHeadRequest) (*chain_service.LatestAndFinalizedHeadReply, error)
	QueryTrackedLogs(context.Context, *QueryTrackedLogsRequest) (*chain_service.QueryTrackedLogsReply, error)
	RegisterLogTracking(context.Context, *RegisterLogTrackingRequest) (*emptypb.Empty, error)
	UnregisterLogTracking(context.Context, *UnregisterLogTrackingRequest) (*emptypb.Empty, error)
	GetTransactionStatus(context.Context, *GetTransactionStatusRequest) (*pb.GetTransactionStatusReply, error)
	mustEmbedUnimplementedEVMRelayerSetServer()
}

// UnimplementedEVMRelayerSetServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEVMRelayerSetServer struct{}

func (UnimplementedEVMRelayerSetServer) GetTransactionFee(context.Context, *GetTransactionFeeRequest) (*chain_service.GetTransactionFeeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionFee not implemented")
}
func (UnimplementedEVMRelayerSetServer) CallContract(context.Context, *CallContractRequest) (*chain_service.CallContractReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallContract not implemented")
}
func (UnimplementedEVMRelayerSetServer) FilterLogs(context.Context, *FilterLogsRequest) (*chain_service.FilterLogsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FilterLogs not implemented")
}
func (UnimplementedEVMRelayerSetServer) BalanceAt(context.Context, *BalanceAtRequest) (*chain_service.BalanceAtReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BalanceAt not implemented")
}
func (UnimplementedEVMRelayerSetServer) EstimateGas(context.Context, *EstimateGasRequest) (*chain_service.EstimateGasReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateGas not implemented")
}
func (UnimplementedEVMRelayerSetServer) GetTransactionByHash(context.Context, *GetTransactionByHashRequest) (*chain_service.GetTransactionByHashReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionByHash not implemented")
}
func (UnimplementedEVMRelayerSetServer) GetTransactionReceipt(context.Context, *GetTransactionReceiptRequest) (*chain_service.GetTransactionReceiptReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionReceipt not implemented")
}
func (UnimplementedEVMRelayerSetServer) LatestAndFinalizedHead(context.Context, *LatestHeadRequest) (*chain_service.LatestAndFinalizedHeadReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LatestAndFinalizedHead not implemented")
}
func (UnimplementedEVMRelayerSetServer) QueryTrackedLogs(context.Context, *QueryTrackedLogsRequest) (*chain_service.QueryTrackedLogsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTrackedLogs not implemented")
}
func (UnimplementedEVMRelayerSetServer) RegisterLogTracking(context.Context, *RegisterLogTrackingRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterLogTracking not implemented")
}
func (UnimplementedEVMRelayerSetServer) UnregisterLogTracking(context.Context, *UnregisterLogTrackingRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterLogTracking not implemented")
}
func (UnimplementedEVMRelayerSetServer) GetTransactionStatus(context.Context, *GetTransactionStatusRequest) (*pb.GetTransactionStatusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionStatus not implemented")
}
func (UnimplementedEVMRelayerSetServer) mustEmbedUnimplementedEVMRelayerSetServer() {}
func (UnimplementedEVMRelayerSetServer) testEmbeddedByValue()                       {}

// UnsafeEVMRelayerSetServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EVMRelayerSetServer will
// result in compilation errors.
type UnsafeEVMRelayerSetServer interface {
	mustEmbedUnimplementedEVMRelayerSetServer()
}

func RegisterEVMRelayerSetServer(s grpc.ServiceRegistrar, srv EVMRelayerSetServer) {
	// If the following call pancis, it indicates UnimplementedEVMRelayerSetServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EVMRelayerSet_ServiceDesc, srv)
}

func _EVMRelayerSet_GetTransactionFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMRelayerSetServer).GetTransactionFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVMRelayerSet_GetTransactionFee_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMRelayerSetServer).GetTransactionFee(ctx, req.(*GetTransactionFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EVMRelayerSet_CallContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallContractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMRelayerSetServer).CallContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVMRelayerSet_CallContract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMRelayerSetServer).CallContract(ctx, req.(*CallContractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EVMRelayerSet_FilterLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FilterLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMRelayerSetServer).FilterLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVMRelayerSet_FilterLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMRelayerSetServer).FilterLogs(ctx, req.(*FilterLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EVMRelayerSet_BalanceAt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BalanceAtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMRelayerSetServer).BalanceAt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVMRelayerSet_BalanceAt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMRelayerSetServer).BalanceAt(ctx, req.(*BalanceAtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EVMRelayerSet_EstimateGas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstimateGasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMRelayerSetServer).EstimateGas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVMRelayerSet_EstimateGas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMRelayerSetServer).EstimateGas(ctx, req.(*EstimateGasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EVMRelayerSet_GetTransactionByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMRelayerSetServer).GetTransactionByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVMRelayerSet_GetTransactionByHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMRelayerSetServer).GetTransactionByHash(ctx, req.(*GetTransactionByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EVMRelayerSet_GetTransactionReceipt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionReceiptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMRelayerSetServer).GetTransactionReceipt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVMRelayerSet_GetTransactionReceipt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMRelayerSetServer).GetTransactionReceipt(ctx, req.(*GetTransactionReceiptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EVMRelayerSet_LatestAndFinalizedHead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LatestHeadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMRelayerSetServer).LatestAndFinalizedHead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVMRelayerSet_LatestAndFinalizedHead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMRelayerSetServer).LatestAndFinalizedHead(ctx, req.(*LatestHeadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EVMRelayerSet_QueryTrackedLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTrackedLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMRelayerSetServer).QueryTrackedLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVMRelayerSet_QueryTrackedLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMRelayerSetServer).QueryTrackedLogs(ctx, req.(*QueryTrackedLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EVMRelayerSet_RegisterLogTracking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterLogTrackingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMRelayerSetServer).RegisterLogTracking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVMRelayerSet_RegisterLogTracking_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMRelayerSetServer).RegisterLogTracking(ctx, req.(*RegisterLogTrackingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EVMRelayerSet_UnregisterLogTracking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterLogTrackingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMRelayerSetServer).UnregisterLogTracking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVMRelayerSet_UnregisterLogTracking_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMRelayerSetServer).UnregisterLogTracking(ctx, req.(*UnregisterLogTrackingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EVMRelayerSet_GetTransactionStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMRelayerSetServer).GetTransactionStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVMRelayerSet_GetTransactionStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMRelayerSetServer).GetTransactionStatus(ctx, req.(*GetTransactionStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EVMRelayerSet_ServiceDesc is the grpc.ServiceDesc for EVMRelayerSet service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EVMRelayerSet_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.relayerset.EVMRelayerSet",
	HandlerType: (*EVMRelayerSetServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTransactionFee",
			Handler:    _EVMRelayerSet_GetTransactionFee_Handler,
		},
		{
			MethodName: "CallContract",
			Handler:    _EVMRelayerSet_CallContract_Handler,
		},
		{
			MethodName: "FilterLogs",
			Handler:    _EVMRelayerSet_FilterLogs_Handler,
		},
		{
			MethodName: "BalanceAt",
			Handler:    _EVMRelayerSet_BalanceAt_Handler,
		},
		{
			MethodName: "EstimateGas",
			Handler:    _EVMRelayerSet_EstimateGas_Handler,
		},
		{
			MethodName: "GetTransactionByHash",
			Handler:    _EVMRelayerSet_GetTransactionByHash_Handler,
		},
		{
			MethodName: "GetTransactionReceipt",
			Handler:    _EVMRelayerSet_GetTransactionReceipt_Handler,
		},
		{
			MethodName: "LatestAndFinalizedHead",
			Handler:    _EVMRelayerSet_LatestAndFinalizedHead_Handler,
		},
		{
			MethodName: "QueryTrackedLogs",
			Handler:    _EVMRelayerSet_QueryTrackedLogs_Handler,
		},
		{
			MethodName: "RegisterLogTracking",
			Handler:    _EVMRelayerSet_RegisterLogTracking_Handler,
		},
		{
			MethodName: "UnregisterLogTracking",
			Handler:    _EVMRelayerSet_UnregisterLogTracking_Handler,
		},
		{
			MethodName: "GetTransactionStatus",
			Handler:    _EVMRelayerSet_GetTransactionStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "loop/internal/pb/relayerset/relayerset.proto",
}
