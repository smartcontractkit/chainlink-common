// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: codec.proto

package ccipocr3pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ChainSpecificAddressCodec_AddressBytesToString_FullMethodName     = "/loop.internal.pb.ccipocr3.ChainSpecificAddressCodec/AddressBytesToString"
	ChainSpecificAddressCodec_AddressStringToBytes_FullMethodName     = "/loop.internal.pb.ccipocr3.ChainSpecificAddressCodec/AddressStringToBytes"
	ChainSpecificAddressCodec_OracleIDAsAddressBytes_FullMethodName   = "/loop.internal.pb.ccipocr3.ChainSpecificAddressCodec/OracleIDAsAddressBytes"
	ChainSpecificAddressCodec_TransmitterBytesToString_FullMethodName = "/loop.internal.pb.ccipocr3.ChainSpecificAddressCodec/TransmitterBytesToString"
)

// ChainSpecificAddressCodecClient is the client API for ChainSpecificAddressCodec service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ChainSpecificAddressCodec service for address encoding/decoding
type ChainSpecificAddressCodecClient interface {
	AddressBytesToString(ctx context.Context, in *AddressBytesToStringRequest, opts ...grpc.CallOption) (*AddressBytesToStringResponse, error)
	AddressStringToBytes(ctx context.Context, in *AddressStringToBytesRequest, opts ...grpc.CallOption) (*AddressStringToBytesResponse, error)
	OracleIDAsAddressBytes(ctx context.Context, in *OracleIDAsAddressBytesRequest, opts ...grpc.CallOption) (*OracleIDAsAddressBytesResponse, error)
	TransmitterBytesToString(ctx context.Context, in *TransmitterBytesToStringRequest, opts ...grpc.CallOption) (*TransmitterBytesToStringResponse, error)
}

type chainSpecificAddressCodecClient struct {
	cc grpc.ClientConnInterface
}

func NewChainSpecificAddressCodecClient(cc grpc.ClientConnInterface) ChainSpecificAddressCodecClient {
	return &chainSpecificAddressCodecClient{cc}
}

func (c *chainSpecificAddressCodecClient) AddressBytesToString(ctx context.Context, in *AddressBytesToStringRequest, opts ...grpc.CallOption) (*AddressBytesToStringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddressBytesToStringResponse)
	err := c.cc.Invoke(ctx, ChainSpecificAddressCodec_AddressBytesToString_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainSpecificAddressCodecClient) AddressStringToBytes(ctx context.Context, in *AddressStringToBytesRequest, opts ...grpc.CallOption) (*AddressStringToBytesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddressStringToBytesResponse)
	err := c.cc.Invoke(ctx, ChainSpecificAddressCodec_AddressStringToBytes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainSpecificAddressCodecClient) OracleIDAsAddressBytes(ctx context.Context, in *OracleIDAsAddressBytesRequest, opts ...grpc.CallOption) (*OracleIDAsAddressBytesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OracleIDAsAddressBytesResponse)
	err := c.cc.Invoke(ctx, ChainSpecificAddressCodec_OracleIDAsAddressBytes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainSpecificAddressCodecClient) TransmitterBytesToString(ctx context.Context, in *TransmitterBytesToStringRequest, opts ...grpc.CallOption) (*TransmitterBytesToStringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransmitterBytesToStringResponse)
	err := c.cc.Invoke(ctx, ChainSpecificAddressCodec_TransmitterBytesToString_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChainSpecificAddressCodecServer is the server API for ChainSpecificAddressCodec service.
// All implementations must embed UnimplementedChainSpecificAddressCodecServer
// for forward compatibility.
//
// ChainSpecificAddressCodec service for address encoding/decoding
type ChainSpecificAddressCodecServer interface {
	AddressBytesToString(context.Context, *AddressBytesToStringRequest) (*AddressBytesToStringResponse, error)
	AddressStringToBytes(context.Context, *AddressStringToBytesRequest) (*AddressStringToBytesResponse, error)
	OracleIDAsAddressBytes(context.Context, *OracleIDAsAddressBytesRequest) (*OracleIDAsAddressBytesResponse, error)
	TransmitterBytesToString(context.Context, *TransmitterBytesToStringRequest) (*TransmitterBytesToStringResponse, error)
	mustEmbedUnimplementedChainSpecificAddressCodecServer()
}

// UnimplementedChainSpecificAddressCodecServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChainSpecificAddressCodecServer struct{}

func (UnimplementedChainSpecificAddressCodecServer) AddressBytesToString(context.Context, *AddressBytesToStringRequest) (*AddressBytesToStringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddressBytesToString not implemented")
}
func (UnimplementedChainSpecificAddressCodecServer) AddressStringToBytes(context.Context, *AddressStringToBytesRequest) (*AddressStringToBytesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddressStringToBytes not implemented")
}
func (UnimplementedChainSpecificAddressCodecServer) OracleIDAsAddressBytes(context.Context, *OracleIDAsAddressBytesRequest) (*OracleIDAsAddressBytesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OracleIDAsAddressBytes not implemented")
}
func (UnimplementedChainSpecificAddressCodecServer) TransmitterBytesToString(context.Context, *TransmitterBytesToStringRequest) (*TransmitterBytesToStringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransmitterBytesToString not implemented")
}
func (UnimplementedChainSpecificAddressCodecServer) mustEmbedUnimplementedChainSpecificAddressCodecServer() {
}
func (UnimplementedChainSpecificAddressCodecServer) testEmbeddedByValue() {}

// UnsafeChainSpecificAddressCodecServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChainSpecificAddressCodecServer will
// result in compilation errors.
type UnsafeChainSpecificAddressCodecServer interface {
	mustEmbedUnimplementedChainSpecificAddressCodecServer()
}

func RegisterChainSpecificAddressCodecServer(s grpc.ServiceRegistrar, srv ChainSpecificAddressCodecServer) {
	// If the following call pancis, it indicates UnimplementedChainSpecificAddressCodecServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ChainSpecificAddressCodec_ServiceDesc, srv)
}

func _ChainSpecificAddressCodec_AddressBytesToString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressBytesToStringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainSpecificAddressCodecServer).AddressBytesToString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChainSpecificAddressCodec_AddressBytesToString_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainSpecificAddressCodecServer).AddressBytesToString(ctx, req.(*AddressBytesToStringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainSpecificAddressCodec_AddressStringToBytes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressStringToBytesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainSpecificAddressCodecServer).AddressStringToBytes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChainSpecificAddressCodec_AddressStringToBytes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainSpecificAddressCodecServer).AddressStringToBytes(ctx, req.(*AddressStringToBytesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainSpecificAddressCodec_OracleIDAsAddressBytes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OracleIDAsAddressBytesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainSpecificAddressCodecServer).OracleIDAsAddressBytes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChainSpecificAddressCodec_OracleIDAsAddressBytes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainSpecificAddressCodecServer).OracleIDAsAddressBytes(ctx, req.(*OracleIDAsAddressBytesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainSpecificAddressCodec_TransmitterBytesToString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransmitterBytesToStringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainSpecificAddressCodecServer).TransmitterBytesToString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChainSpecificAddressCodec_TransmitterBytesToString_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainSpecificAddressCodecServer).TransmitterBytesToString(ctx, req.(*TransmitterBytesToStringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChainSpecificAddressCodec_ServiceDesc is the grpc.ServiceDesc for ChainSpecificAddressCodec service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChainSpecificAddressCodec_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.internal.pb.ccipocr3.ChainSpecificAddressCodec",
	HandlerType: (*ChainSpecificAddressCodecServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddressBytesToString",
			Handler:    _ChainSpecificAddressCodec_AddressBytesToString_Handler,
		},
		{
			MethodName: "AddressStringToBytes",
			Handler:    _ChainSpecificAddressCodec_AddressStringToBytes_Handler,
		},
		{
			MethodName: "OracleIDAsAddressBytes",
			Handler:    _ChainSpecificAddressCodec_OracleIDAsAddressBytes_Handler,
		},
		{
			MethodName: "TransmitterBytesToString",
			Handler:    _ChainSpecificAddressCodec_TransmitterBytesToString_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "codec.proto",
}

const (
	ExecutePluginCodec_Encode_FullMethodName = "/loop.internal.pb.ccipocr3.ExecutePluginCodec/Encode"
	ExecutePluginCodec_Decode_FullMethodName = "/loop.internal.pb.ccipocr3.ExecutePluginCodec/Decode"
)

// ExecutePluginCodecClient is the client API for ExecutePluginCodec service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ExecutePluginCodec service for execute plugin report encoding/decoding
type ExecutePluginCodecClient interface {
	Encode(ctx context.Context, in *EncodeExecutePluginReportRequest, opts ...grpc.CallOption) (*EncodeExecutePluginReportResponse, error)
	Decode(ctx context.Context, in *DecodeExecutePluginReportRequest, opts ...grpc.CallOption) (*DecodeExecutePluginReportResponse, error)
}

type executePluginCodecClient struct {
	cc grpc.ClientConnInterface
}

func NewExecutePluginCodecClient(cc grpc.ClientConnInterface) ExecutePluginCodecClient {
	return &executePluginCodecClient{cc}
}

func (c *executePluginCodecClient) Encode(ctx context.Context, in *EncodeExecutePluginReportRequest, opts ...grpc.CallOption) (*EncodeExecutePluginReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EncodeExecutePluginReportResponse)
	err := c.cc.Invoke(ctx, ExecutePluginCodec_Encode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executePluginCodecClient) Decode(ctx context.Context, in *DecodeExecutePluginReportRequest, opts ...grpc.CallOption) (*DecodeExecutePluginReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecodeExecutePluginReportResponse)
	err := c.cc.Invoke(ctx, ExecutePluginCodec_Decode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExecutePluginCodecServer is the server API for ExecutePluginCodec service.
// All implementations must embed UnimplementedExecutePluginCodecServer
// for forward compatibility.
//
// ExecutePluginCodec service for execute plugin report encoding/decoding
type ExecutePluginCodecServer interface {
	Encode(context.Context, *EncodeExecutePluginReportRequest) (*EncodeExecutePluginReportResponse, error)
	Decode(context.Context, *DecodeExecutePluginReportRequest) (*DecodeExecutePluginReportResponse, error)
	mustEmbedUnimplementedExecutePluginCodecServer()
}

// UnimplementedExecutePluginCodecServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedExecutePluginCodecServer struct{}

func (UnimplementedExecutePluginCodecServer) Encode(context.Context, *EncodeExecutePluginReportRequest) (*EncodeExecutePluginReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Encode not implemented")
}
func (UnimplementedExecutePluginCodecServer) Decode(context.Context, *DecodeExecutePluginReportRequest) (*DecodeExecutePluginReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Decode not implemented")
}
func (UnimplementedExecutePluginCodecServer) mustEmbedUnimplementedExecutePluginCodecServer() {}
func (UnimplementedExecutePluginCodecServer) testEmbeddedByValue()                            {}

// UnsafeExecutePluginCodecServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExecutePluginCodecServer will
// result in compilation errors.
type UnsafeExecutePluginCodecServer interface {
	mustEmbedUnimplementedExecutePluginCodecServer()
}

func RegisterExecutePluginCodecServer(s grpc.ServiceRegistrar, srv ExecutePluginCodecServer) {
	// If the following call pancis, it indicates UnimplementedExecutePluginCodecServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ExecutePluginCodec_ServiceDesc, srv)
}

func _ExecutePluginCodec_Encode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncodeExecutePluginReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutePluginCodecServer).Encode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExecutePluginCodec_Encode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutePluginCodecServer).Encode(ctx, req.(*EncodeExecutePluginReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExecutePluginCodec_Decode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecodeExecutePluginReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutePluginCodecServer).Decode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExecutePluginCodec_Decode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutePluginCodecServer).Decode(ctx, req.(*DecodeExecutePluginReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ExecutePluginCodec_ServiceDesc is the grpc.ServiceDesc for ExecutePluginCodec service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExecutePluginCodec_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.internal.pb.ccipocr3.ExecutePluginCodec",
	HandlerType: (*ExecutePluginCodecServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Encode",
			Handler:    _ExecutePluginCodec_Encode_Handler,
		},
		{
			MethodName: "Decode",
			Handler:    _ExecutePluginCodec_Decode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "codec.proto",
}

const (
	TokenDataEncoder_EncodeUSDC_FullMethodName = "/loop.internal.pb.ccipocr3.TokenDataEncoder/EncodeUSDC"
)

// TokenDataEncoderClient is the client API for TokenDataEncoder service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// TokenDataEncoder service for encoding offchain token data
type TokenDataEncoderClient interface {
	EncodeUSDC(ctx context.Context, in *EncodeUSDCRequest, opts ...grpc.CallOption) (*EncodeUSDCResponse, error)
}

type tokenDataEncoderClient struct {
	cc grpc.ClientConnInterface
}

func NewTokenDataEncoderClient(cc grpc.ClientConnInterface) TokenDataEncoderClient {
	return &tokenDataEncoderClient{cc}
}

func (c *tokenDataEncoderClient) EncodeUSDC(ctx context.Context, in *EncodeUSDCRequest, opts ...grpc.CallOption) (*EncodeUSDCResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EncodeUSDCResponse)
	err := c.cc.Invoke(ctx, TokenDataEncoder_EncodeUSDC_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TokenDataEncoderServer is the server API for TokenDataEncoder service.
// All implementations must embed UnimplementedTokenDataEncoderServer
// for forward compatibility.
//
// TokenDataEncoder service for encoding offchain token data
type TokenDataEncoderServer interface {
	EncodeUSDC(context.Context, *EncodeUSDCRequest) (*EncodeUSDCResponse, error)
	mustEmbedUnimplementedTokenDataEncoderServer()
}

// UnimplementedTokenDataEncoderServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTokenDataEncoderServer struct{}

func (UnimplementedTokenDataEncoderServer) EncodeUSDC(context.Context, *EncodeUSDCRequest) (*EncodeUSDCResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncodeUSDC not implemented")
}
func (UnimplementedTokenDataEncoderServer) mustEmbedUnimplementedTokenDataEncoderServer() {}
func (UnimplementedTokenDataEncoderServer) testEmbeddedByValue()                          {}

// UnsafeTokenDataEncoderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TokenDataEncoderServer will
// result in compilation errors.
type UnsafeTokenDataEncoderServer interface {
	mustEmbedUnimplementedTokenDataEncoderServer()
}

func RegisterTokenDataEncoderServer(s grpc.ServiceRegistrar, srv TokenDataEncoderServer) {
	// If the following call pancis, it indicates UnimplementedTokenDataEncoderServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TokenDataEncoder_ServiceDesc, srv)
}

func _TokenDataEncoder_EncodeUSDC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncodeUSDCRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenDataEncoderServer).EncodeUSDC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TokenDataEncoder_EncodeUSDC_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenDataEncoderServer).EncodeUSDC(ctx, req.(*EncodeUSDCRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TokenDataEncoder_ServiceDesc is the grpc.ServiceDesc for TokenDataEncoder service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TokenDataEncoder_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.internal.pb.ccipocr3.TokenDataEncoder",
	HandlerType: (*TokenDataEncoderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EncodeUSDC",
			Handler:    _TokenDataEncoder_EncodeUSDC_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "codec.proto",
}

const (
	SourceChainExtraDataCodec_DecodeExtraArgsToMap_FullMethodName    = "/loop.internal.pb.ccipocr3.SourceChainExtraDataCodec/DecodeExtraArgsToMap"
	SourceChainExtraDataCodec_DecodeDestExecDataToMap_FullMethodName = "/loop.internal.pb.ccipocr3.SourceChainExtraDataCodec/DecodeDestExecDataToMap"
)

// SourceChainExtraDataCodecClient is the client API for SourceChainExtraDataCodec service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// SourceChainExtraDataCodec service for decoding source chain specific data
type SourceChainExtraDataCodecClient interface {
	DecodeExtraArgsToMap(ctx context.Context, in *DecodeExtraArgsToMapRequest, opts ...grpc.CallOption) (*DecodeExtraArgsToMapResponse, error)
	DecodeDestExecDataToMap(ctx context.Context, in *DecodeDestExecDataToMapRequest, opts ...grpc.CallOption) (*DecodeDestExecDataToMapResponse, error)
}

type sourceChainExtraDataCodecClient struct {
	cc grpc.ClientConnInterface
}

func NewSourceChainExtraDataCodecClient(cc grpc.ClientConnInterface) SourceChainExtraDataCodecClient {
	return &sourceChainExtraDataCodecClient{cc}
}

func (c *sourceChainExtraDataCodecClient) DecodeExtraArgsToMap(ctx context.Context, in *DecodeExtraArgsToMapRequest, opts ...grpc.CallOption) (*DecodeExtraArgsToMapResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecodeExtraArgsToMapResponse)
	err := c.cc.Invoke(ctx, SourceChainExtraDataCodec_DecodeExtraArgsToMap_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sourceChainExtraDataCodecClient) DecodeDestExecDataToMap(ctx context.Context, in *DecodeDestExecDataToMapRequest, opts ...grpc.CallOption) (*DecodeDestExecDataToMapResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecodeDestExecDataToMapResponse)
	err := c.cc.Invoke(ctx, SourceChainExtraDataCodec_DecodeDestExecDataToMap_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SourceChainExtraDataCodecServer is the server API for SourceChainExtraDataCodec service.
// All implementations must embed UnimplementedSourceChainExtraDataCodecServer
// for forward compatibility.
//
// SourceChainExtraDataCodec service for decoding source chain specific data
type SourceChainExtraDataCodecServer interface {
	DecodeExtraArgsToMap(context.Context, *DecodeExtraArgsToMapRequest) (*DecodeExtraArgsToMapResponse, error)
	DecodeDestExecDataToMap(context.Context, *DecodeDestExecDataToMapRequest) (*DecodeDestExecDataToMapResponse, error)
	mustEmbedUnimplementedSourceChainExtraDataCodecServer()
}

// UnimplementedSourceChainExtraDataCodecServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSourceChainExtraDataCodecServer struct{}

func (UnimplementedSourceChainExtraDataCodecServer) DecodeExtraArgsToMap(context.Context, *DecodeExtraArgsToMapRequest) (*DecodeExtraArgsToMapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecodeExtraArgsToMap not implemented")
}
func (UnimplementedSourceChainExtraDataCodecServer) DecodeDestExecDataToMap(context.Context, *DecodeDestExecDataToMapRequest) (*DecodeDestExecDataToMapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecodeDestExecDataToMap not implemented")
}
func (UnimplementedSourceChainExtraDataCodecServer) mustEmbedUnimplementedSourceChainExtraDataCodecServer() {
}
func (UnimplementedSourceChainExtraDataCodecServer) testEmbeddedByValue() {}

// UnsafeSourceChainExtraDataCodecServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SourceChainExtraDataCodecServer will
// result in compilation errors.
type UnsafeSourceChainExtraDataCodecServer interface {
	mustEmbedUnimplementedSourceChainExtraDataCodecServer()
}

func RegisterSourceChainExtraDataCodecServer(s grpc.ServiceRegistrar, srv SourceChainExtraDataCodecServer) {
	// If the following call pancis, it indicates UnimplementedSourceChainExtraDataCodecServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SourceChainExtraDataCodec_ServiceDesc, srv)
}

func _SourceChainExtraDataCodec_DecodeExtraArgsToMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecodeExtraArgsToMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SourceChainExtraDataCodecServer).DecodeExtraArgsToMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SourceChainExtraDataCodec_DecodeExtraArgsToMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SourceChainExtraDataCodecServer).DecodeExtraArgsToMap(ctx, req.(*DecodeExtraArgsToMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SourceChainExtraDataCodec_DecodeDestExecDataToMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecodeDestExecDataToMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SourceChainExtraDataCodecServer).DecodeDestExecDataToMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SourceChainExtraDataCodec_DecodeDestExecDataToMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SourceChainExtraDataCodecServer).DecodeDestExecDataToMap(ctx, req.(*DecodeDestExecDataToMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SourceChainExtraDataCodec_ServiceDesc is the grpc.ServiceDesc for SourceChainExtraDataCodec service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SourceChainExtraDataCodec_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.internal.pb.ccipocr3.SourceChainExtraDataCodec",
	HandlerType: (*SourceChainExtraDataCodecServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DecodeExtraArgsToMap",
			Handler:    _SourceChainExtraDataCodec_DecodeExtraArgsToMap_Handler,
		},
		{
			MethodName: "DecodeDestExecDataToMap",
			Handler:    _SourceChainExtraDataCodec_DecodeDestExecDataToMap_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "codec.proto",
}

const (
	ExtraDataCodecBundle_DecodeExtraArgs_FullMethodName               = "/loop.internal.pb.ccipocr3.ExtraDataCodecBundle/DecodeExtraArgs"
	ExtraDataCodecBundle_DecodeTokenAmountDestExecData_FullMethodName = "/loop.internal.pb.ccipocr3.ExtraDataCodecBundle/DecodeTokenAmountDestExecData"
)

// ExtraDataCodecBundleClient is the client API for ExtraDataCodecBundle service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ExtraDataCodecBundle service for decoding extra args and dest exec data with chain selector
type ExtraDataCodecBundleClient interface {
	DecodeExtraArgs(ctx context.Context, in *DecodeExtraArgsWithChainSelectorRequest, opts ...grpc.CallOption) (*DecodeExtraArgsWithChainSelectorResponse, error)
	DecodeTokenAmountDestExecData(ctx context.Context, in *DecodeTokenAmountDestExecDataRequest, opts ...grpc.CallOption) (*DecodeTokenAmountDestExecDataResponse, error)
}

type extraDataCodecBundleClient struct {
	cc grpc.ClientConnInterface
}

func NewExtraDataCodecBundleClient(cc grpc.ClientConnInterface) ExtraDataCodecBundleClient {
	return &extraDataCodecBundleClient{cc}
}

func (c *extraDataCodecBundleClient) DecodeExtraArgs(ctx context.Context, in *DecodeExtraArgsWithChainSelectorRequest, opts ...grpc.CallOption) (*DecodeExtraArgsWithChainSelectorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecodeExtraArgsWithChainSelectorResponse)
	err := c.cc.Invoke(ctx, ExtraDataCodecBundle_DecodeExtraArgs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extraDataCodecBundleClient) DecodeTokenAmountDestExecData(ctx context.Context, in *DecodeTokenAmountDestExecDataRequest, opts ...grpc.CallOption) (*DecodeTokenAmountDestExecDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecodeTokenAmountDestExecDataResponse)
	err := c.cc.Invoke(ctx, ExtraDataCodecBundle_DecodeTokenAmountDestExecData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExtraDataCodecBundleServer is the server API for ExtraDataCodecBundle service.
// All implementations must embed UnimplementedExtraDataCodecBundleServer
// for forward compatibility.
//
// ExtraDataCodecBundle service for decoding extra args and dest exec data with chain selector
type ExtraDataCodecBundleServer interface {
	DecodeExtraArgs(context.Context, *DecodeExtraArgsWithChainSelectorRequest) (*DecodeExtraArgsWithChainSelectorResponse, error)
	DecodeTokenAmountDestExecData(context.Context, *DecodeTokenAmountDestExecDataRequest) (*DecodeTokenAmountDestExecDataResponse, error)
	mustEmbedUnimplementedExtraDataCodecBundleServer()
}

// UnimplementedExtraDataCodecBundleServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedExtraDataCodecBundleServer struct{}

func (UnimplementedExtraDataCodecBundleServer) DecodeExtraArgs(context.Context, *DecodeExtraArgsWithChainSelectorRequest) (*DecodeExtraArgsWithChainSelectorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecodeExtraArgs not implemented")
}
func (UnimplementedExtraDataCodecBundleServer) DecodeTokenAmountDestExecData(context.Context, *DecodeTokenAmountDestExecDataRequest) (*DecodeTokenAmountDestExecDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecodeTokenAmountDestExecData not implemented")
}
func (UnimplementedExtraDataCodecBundleServer) mustEmbedUnimplementedExtraDataCodecBundleServer() {}
func (UnimplementedExtraDataCodecBundleServer) testEmbeddedByValue()                              {}

// UnsafeExtraDataCodecBundleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExtraDataCodecBundleServer will
// result in compilation errors.
type UnsafeExtraDataCodecBundleServer interface {
	mustEmbedUnimplementedExtraDataCodecBundleServer()
}

func RegisterExtraDataCodecBundleServer(s grpc.ServiceRegistrar, srv ExtraDataCodecBundleServer) {
	// If the following call pancis, it indicates UnimplementedExtraDataCodecBundleServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ExtraDataCodecBundle_ServiceDesc, srv)
}

func _ExtraDataCodecBundle_DecodeExtraArgs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecodeExtraArgsWithChainSelectorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtraDataCodecBundleServer).DecodeExtraArgs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExtraDataCodecBundle_DecodeExtraArgs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtraDataCodecBundleServer).DecodeExtraArgs(ctx, req.(*DecodeExtraArgsWithChainSelectorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExtraDataCodecBundle_DecodeTokenAmountDestExecData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecodeTokenAmountDestExecDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtraDataCodecBundleServer).DecodeTokenAmountDestExecData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExtraDataCodecBundle_DecodeTokenAmountDestExecData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtraDataCodecBundleServer).DecodeTokenAmountDestExecData(ctx, req.(*DecodeTokenAmountDestExecDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ExtraDataCodecBundle_ServiceDesc is the grpc.ServiceDesc for ExtraDataCodecBundle service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExtraDataCodecBundle_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.internal.pb.ccipocr3.ExtraDataCodecBundle",
	HandlerType: (*ExtraDataCodecBundleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DecodeExtraArgs",
			Handler:    _ExtraDataCodecBundle_DecodeExtraArgs_Handler,
		},
		{
			MethodName: "DecodeTokenAmountDestExecData",
			Handler:    _ExtraDataCodecBundle_DecodeTokenAmountDestExecData_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "codec.proto",
}
