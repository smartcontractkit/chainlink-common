// Code generated by github.com/smartcontractkit/chainlink-common/pkg/capabilities/v2/protoc, DO NOT EDIT.

package server

import (
	"context"
	"fmt"
	"time"

	"google.golang.org/protobuf/types/known/emptypb"

	pb1 "github.com/smartcontractkit/chainlink-common/pkg/workflows/sdk/v2/pb"

	"github.com/smartcontractkit/chainlink-common/pkg/capabilities"
	"github.com/smartcontractkit/chainlink-common/pkg/types/core"
)

// Avoid unused imports if there is configuration type
var _ = emptypb.Empty{}

type ConsensusCapability interface {
	Simple(ctx context.Context, metadata capabilities.RequestMetadata, input *pb1.SimpleConsensusInputs) (*pb1.ConsensusOutputs, error)

	Start(ctx context.Context) error
	Close() error
	HealthReport() map[string]error
	Name() string
	Description() string
	Ready() error
	Initialise(ctx context.Context, config string, telemetryService core.TelemetryService, store core.KeyValueStore, errorLog core.ErrorLog, pipelineRunner core.PipelineRunnerService, relayerSet core.RelayerSet, oracleFactory core.OracleFactory, gatewayConnector core.GatewayConnector, p2pKeystore core.Keystore) error
}

func NewConsensusServer(capability ConsensusCapability) *ConsensusServer {
	stopCh := make(chan struct{})
	return &ConsensusServer{
		consensusCapability: consensusCapability{ConsensusCapability: capability, stopCh: stopCh},
		stopCh:              stopCh,
	}
}

type ConsensusServer struct {
	consensusCapability
	capabilityRegistry core.CapabilitiesRegistry
	stopCh             chan struct{}
}

func (cs *ConsensusServer) Initialise(ctx context.Context, config string, telemetryService core.TelemetryService, store core.KeyValueStore, capabilityRegistry core.CapabilitiesRegistry, errorLog core.ErrorLog, pipelineRunner core.PipelineRunnerService, relayerSet core.RelayerSet, oracleFactory core.OracleFactory, gatewayConnector core.GatewayConnector, p2pKeystore core.Keystore) error {
	if err := cs.ConsensusCapability.Initialise(ctx, config, telemetryService, store, errorLog, pipelineRunner, relayerSet, oracleFactory, gatewayConnector, p2pKeystore); err != nil {
		return fmt.Errorf("error when initializing capability: %w", err)
	}

	cs.capabilityRegistry = capabilityRegistry

	if err := capabilityRegistry.Add(ctx, &consensusCapability{
		ConsensusCapability: cs.ConsensusCapability,
	}); err != nil {
		return fmt.Errorf("error when adding kv store action to the registry: %w", err)
	}

	return nil
}

func (cs *ConsensusServer) Close() error {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()

	if cs.capabilityRegistry != nil {
		if err := cs.capabilityRegistry.Remove(ctx, "consensus@1.0.0-alpha"); err != nil {
			return err
		}
	}

	if cs.stopCh != nil {
		close(cs.stopCh)
	}

	return cs.consensusCapability.Close()
}

func (cs *ConsensusServer) Infos(ctx context.Context) ([]capabilities.CapabilityInfo, error) {
	info, err := cs.consensusCapability.Info(ctx)
	if err != nil {
		return nil, err
	}
	return []capabilities.CapabilityInfo{info}, nil
}

type consensusCapability struct {
	ConsensusCapability
	stopCh chan struct{}
}

func (c *consensusCapability) Info(ctx context.Context) (capabilities.CapabilityInfo, error) {
	// Maybe we do need to split it out, even if the user doesn't see it
	return capabilities.NewCapabilityInfo("consensus@1.0.0-alpha", capabilities.CapabilityTypeCombined, c.ConsensusCapability.Description())
}

var _ capabilities.ExecutableAndTriggerCapability = (*consensusCapability)(nil)

const ConsensusID = "consensus@1.0.0-alpha"

func (c *consensusCapability) RegisterTrigger(ctx context.Context, request capabilities.TriggerRegistrationRequest) (<-chan capabilities.TriggerResponse, error) {
	return nil, fmt.Errorf("trigger %s not found", request.Method)
}

func (c *consensusCapability) UnregisterTrigger(ctx context.Context, request capabilities.TriggerRegistrationRequest) error {
	return fmt.Errorf("trigger %s not found", request.Method)
}

func (c *consensusCapability) RegisterToWorkflow(ctx context.Context, request capabilities.RegisterToWorkflowRequest) error {
	return nil
}

func (c *consensusCapability) UnregisterFromWorkflow(ctx context.Context, request capabilities.UnregisterFromWorkflowRequest) error {
	return nil
}

func (c *consensusCapability) Execute(ctx context.Context, request capabilities.CapabilityRequest) (capabilities.CapabilityResponse, error) {
	response := capabilities.CapabilityResponse{}
	switch request.Method {
	case "Simple":
		input := &pb1.SimpleConsensusInputs{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *pb1.SimpleConsensusInputs, _ *emptypb.Empty) (*pb1.ConsensusOutputs, error) {
			return c.ConsensusCapability.Simple(ctx, metadata, input)
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	default:
		return response, fmt.Errorf("method %s not found", request.Method)
	}
}
