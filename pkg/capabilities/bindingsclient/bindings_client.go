package bindings_client

import (
	"context"
	"fmt"
	"math/big"

	"github.com/smartcontractkit/chainlink-common/pkg/capabilities/bindings"
	evmpb "github.com/smartcontractkit/chainlink-common/pkg/capabilities/v2/chain-capabilities/evm/chain-service"
	chaincommonpb "github.com/smartcontractkit/chainlink-common/pkg/loop/chain-common"
)

func simpleUX() {
	//TODO: Not as part of the DD but we need to define a common SDK for chains and define itâ€™s shape to represent chain selectors / chain families.
	const targetChainID = 100
	dataStorage, _ := bindings.NewDataStorage(bindings.ContractInitInputs{
		ChainID: targetChainID,
		Address: evmpb.Address{
			Address: []byte("some address"),
		},
		Options: &bindings.ContractInitOptions{ //Optional configuration - We need to set a gas limit to use a WriteReport op.
			GasConfig: &evmpb.GasConfig{
				GasLimit: 100000000,
			},
		},
	})

	// Encode input to use directly with EVM capability
	readDataArgs := bindings.ReadDataArgs{
		User: evmpb.Address{Address: []byte("another address")},
		Key:  "some string",
	}

	// #1 - Execute read operation over DataStorage.readData(..)
	dataRead, _ := dataStorage.ReadDataAccessor().ReadData(context.Background(), readDataArgs, nil)
	println("We can directly access the read data " + dataRead)

	userData := bindings.UserDataStruct{
		Key:   "key",
		Value: "value",
	}

	// #2 - WriteReport targeting DataStorage IReceiver interface passing a UserDataStruct instance as data
	txHash, err := dataStorage.UserDataStructAccessor().WriteReport(context.Background(), userData, nil)
	if err != nil {
		//Error handling scenarios for WriteReport - In case the transaction failed to make it on chain or if the receiver smart contract failed to execute
		switch e := err.(type) {
		case *bindings.ReceiverContractError:
			fmt.Println("TX was successful but receiver contract failed to execute. Tx Hash", e.TxHash)
		case *bindings.TxFatalError:
			//TODO we are missing a meaningful error message
			fmt.Println("TX couldn't be written to the chain at all.")
		// #3 - Support custom errors from receiver smart contract
		case *bindings.DataNotFoundError:
			//TODO this seems possible if we change keystone_forwarder to capture the error from the receiver contract and we put it in a custom event that holds the encoded data of the error and then we
			//get the event.
			fmt.Println("Error raised from receiver smart contract.")
		default:
			fmt.Println("Other error:", err)
		}
	} else {
		//At this point the TX was successful and also the receiver smart contract execution
		println("TX Hash: " + txHash.String())
	}

	// #4 - Support for logs
	// Register tracking of logs DataStored event in DataStorage contract
	dataStorage.DataStoredLogAccessor().RegisterLogTracking(context.Background(), nil)
	//Unregister tracking of logs DataStored event in DataStorage contract
	dataStorage.DataStoredLogAccessor().UnregisterLogTracking(context.Background())
	//Fetch tracked logs generated by DataStored event in DataStorage contract - Get next 10
	var logs []bindings.ParsedLog[bindings.DataStoredLog]
	logs, _ = dataStorage.DataStoredLogAccessor().QueryTrackedLogs(context.Background(), nil)
	println("Logs data are already parsed: key: " + logs[0].LogData.Key + " , value: " + logs[0].LogData.Value + ", but you also have access to the raw log: " + logs[0].RawLog.BlockHash.String())
	//Direct access to fetch logs API
	logs, _ = dataStorage.DataStoredLogAccessor().FilterLogs(context.Background(), &bindings.FilterOptions{
		FromBlock: big.NewInt(10),
		ToBlock:   big.NewInt(20),
	})
	// Data types between FilterLogs and QueryTrackedLogs are the same.
	println("Logs data are already parsed: key: " + logs[0].LogData.Key + " , value: " + logs[0].LogData.Value + ", but you also have access to the raw log: " + logs[0].RawLog.BlockHash.String())
}

func simpleUXWithOptions() {
	const targetChainID = 100
	dataStorage, _ := bindings.NewDataStorage(bindings.ContractInitInputs{
		ChainID: targetChainID,
		Address: evmpb.Address{
			Address: []byte("some address"),
		},
		Options: &bindings.ContractInitOptions{ //Optional configuration - We need to set a gas limit to use a WriteReport op.
			GasConfig: &evmpb.GasConfig{
				GasLimit: 100000000,
			},
		},
	})


	// #1 - Execute read operation over DataStorage.readData(..) - use options to configure from which block to read.
	dataRead, _ := dataStorage.ReadDataAccessor().ReadData(context.Background(), bindings.ReadDataArgs{
		User: evmpb.Address{Address: []byte("another address")},
		Key:  "some string",
	}, &bindings.ReadOptions{
		BlockNumber: big.NewInt(10000),
	},
	)
	println("We can directly access the read data " + dataRead)

	// #2 - WriteReport targeting DataStorage IReceiver interface passing a UserDataStruct instance as data - Using options to customize
	// gas limit and what's the expected transaction status when getting a reply from this method
	txHash, _ := dataStorage.UserDataStructAccessor().WriteReport(context.Background(), bindings.UserDataStruct{
		Key:   "key",
		Value: "value",
	}, &bindings.WriteOptions{
		GasConfig: &evmpb.GasConfig{
			GasLimit: 200000000,
		},
		BlockDepth: bindings.CONFIRMED, //Until confirmed - Default is finalized
	})

	//Register tracking of logs DataStored event in DataStorage contract
	dataStorage.DataStoredLogAccessor().RegisterLogTracking(context.Background(), &bindings.LogTrackingOptions{
		MaxLogsKept:   10000,
		RetentionTime: 6000,
		LogsPerBlock:  10,
		Topic2:        []*evmpb.Hash{&evmpb.Hash{Hash: []byte("some other filter")}},
	})

	// #4 - Support for logs 
	//Unregister tracking of logs for DataStored event in DataStorage contract
	dataStorage.DataStoredLogAccessor().UnregisterLogTracking(context.Background())

	//Fetch tracked logs generated by DataStored event in DataStorage contract - addition options for sorting and limit
	//TODO: How do we get the cursor to use it in future invocations?
	var logs []bindings.ParsedLog[bindings.DataStoredLog]
	logs, _ = dataStorage.DataStoredLogAccessor().QueryTrackedLogs(context.Background(), &bindings.QueryTrackedLogsOptions{
		SortBy: []*chaincommonpb.SortBy{
			&chaincommonpb.SortBy{
				SortType: chaincommonpb.SortType_SortTimestamp,
			},
		},
		Limit: &chaincommonpb.Limit{
			Count: 10,
		},
	})
	println("Logs data are already parsed: key: " + logs[0].LogData.Key + " , value: " + logs[0].LogData.Value + ", but you also have access to the raw log: " + logs[0].RawLog.BlockHash.String())

	//Direct access to fetch logs API from RPC for simple use cases that do not require to track logs - adding options for block hash instead of range
	logs, _ = dataStorage.DataStoredLogAccessor().FilterLogs(context.Background(), &bindings.FilterOptions{
		BlockHash: txHash,
	})

	// Data types between FilterLogs and QueryTrackedLogs are the same.
	println("Logs data are already parsed: key: " + logs[0].LogData.Key + " , value: " + logs[0].LogData.Value + ", but you also have access to the raw log: " + logs[0].RawLog.BlockHash.String())

}

func advanceUXUsingEVMCapability() {
	const targetChainID = 100
	dataStorage, _ := bindings.NewDataStorage(bindings.ContractInitInputs{
		ChainID: targetChainID,
		Address: evmpb.Address{
			Address: []byte("some address"),
		},
		Options: &bindings.ContractInitOptions{},
	})

	evmClient := evmpb.NewEVMClient(nil)
	
	readDataArgs := bindings.ReadDataArgs{
		User: evmpb.Address{Address: []byte("another address")},
		Key:  "some string",
	}
	
	// #5 - Encode input args for DataStorage.readData(..)
	//TODO do we really need this use case if we can generate calldata for the whole read operation and not just the input args?
	encodedReadDataArgs, _ := dataStorage.ReadDataAccessor().EncodeInput(readDataArgs)
	
	// Encode calldata to invoke DataStorage.readData(..) using EVM Capability.
	calldata, _ := dataStorage.ReadDataAccessor().EncodeCalldata(readDataArgs)
	callContractReply, _ := evmClient.CallContract(context.Background(), &evmpb.CallContractRequest{
		Call: &evmpb.CallMsg{
			Data: &evmpb.ABIPayload{
				Abi: calldata,
			},
			To: &dataStorage.Address,
		},
	})

	// #6 - Decode output of DataStorage.readData(..)
	outputAsString, _ := dataStorage.ReadDataAccessor().DecodeOutput(callContractReply.Data.Abi)
	print("I can use the decoded output directly: " + outputAsString)
	
	userData := bindings.UserDataStruct{
		Key:   "key",
		Value: "value",
	}

	// #7 - Encode DataStorage.UserData struct in case we want to use it for creating a report manually
	encodedUserData, _ := dataStorage.UserDataStructAccessor().Encode(userData)
	commonReport := bindings.GenerateReport(targetChainID, encodedUserData)
	// Manually write report using the capability and the encoded UserData
	evmClient.WriteReport(context.Background(), &evmpb.WriteReportRequest{
		Receiver: &dataStorage.Address,
		Report: &evmpb.SignedReport{
			RawReport:     commonReport.ReportContext,
			ReportContext: commonReport.ReportContext,
			Signatures:    commonReport.Signatures,
			Id:            commonReport.ID,
		},
	})
	
	// #8 - Get event hash to use in log capabilities
	// Calling the FilterLogs capability to show how to manually decode a DataStorage.DataStored event log
	filterLogsReply, _ := evmClient.FilterLogs(context.Background(), &evmpb.FilterLogsRequest{
		FilterQuery: &evmpb.FilterQuery{
			Addresses: []*evmpb.Address{&evmpb.Address{Address: dataStorage.Address.Address}},
			Topics: []*evmpb.Topics{
				&evmpb.Topics{
					Topic: []*evmpb.Hash{
						dataStorage.DataStoredLogAccessor().Hash,
					}
				},
			},
		},
	})
	// Decoding manually the DataStorage.DataStored event log for advance use cases
	dataStoredLog, _ := dataStorage.DataStoredLogAccessor().Decode(filterLogsReply.Logs[0].Data.Abi) 
	println("Log data is key: " + dataStoredLog.Key + ", value: " + dataStoredLog.Value)
}
