// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: capabilities.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	BaseCapability_Info_FullMethodName = "/capabilities.BaseCapability/Info"
)

// BaseCapabilityClient is the client API for BaseCapability service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BaseCapabilityClient interface {
	Info(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CapabilityInfoReply, error)
}

type baseCapabilityClient struct {
	cc grpc.ClientConnInterface
}

func NewBaseCapabilityClient(cc grpc.ClientConnInterface) BaseCapabilityClient {
	return &baseCapabilityClient{cc}
}

func (c *baseCapabilityClient) Info(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CapabilityInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CapabilityInfoReply)
	err := c.cc.Invoke(ctx, BaseCapability_Info_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BaseCapabilityServer is the server API for BaseCapability service.
// All implementations must embed UnimplementedBaseCapabilityServer
// for forward compatibility.
type BaseCapabilityServer interface {
	Info(context.Context, *emptypb.Empty) (*CapabilityInfoReply, error)
	mustEmbedUnimplementedBaseCapabilityServer()
}

// UnimplementedBaseCapabilityServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBaseCapabilityServer struct{}

func (UnimplementedBaseCapabilityServer) Info(context.Context, *emptypb.Empty) (*CapabilityInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Info not implemented")
}
func (UnimplementedBaseCapabilityServer) mustEmbedUnimplementedBaseCapabilityServer() {}
func (UnimplementedBaseCapabilityServer) testEmbeddedByValue()                        {}

// UnsafeBaseCapabilityServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BaseCapabilityServer will
// result in compilation errors.
type UnsafeBaseCapabilityServer interface {
	mustEmbedUnimplementedBaseCapabilityServer()
}

func RegisterBaseCapabilityServer(s grpc.ServiceRegistrar, srv BaseCapabilityServer) {
	// If the following call pancis, it indicates UnimplementedBaseCapabilityServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BaseCapability_ServiceDesc, srv)
}

func _BaseCapability_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseCapabilityServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BaseCapability_Info_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseCapabilityServer).Info(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// BaseCapability_ServiceDesc is the grpc.ServiceDesc for BaseCapability service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BaseCapability_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "capabilities.BaseCapability",
	HandlerType: (*BaseCapabilityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Info",
			Handler:    _BaseCapability_Info_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "capabilities.proto",
}

const (
	TriggerExecutable_RegisterTrigger_FullMethodName   = "/capabilities.TriggerExecutable/RegisterTrigger"
	TriggerExecutable_UnregisterTrigger_FullMethodName = "/capabilities.TriggerExecutable/UnregisterTrigger"
	TriggerExecutable_AckEvent_FullMethodName          = "/capabilities.TriggerExecutable/AckEvent"
)

// TriggerExecutableClient is the client API for TriggerExecutable service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TriggerExecutableClient interface {
	RegisterTrigger(ctx context.Context, in *TriggerRegistrationRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TriggerResponseMessage], error)
	UnregisterTrigger(ctx context.Context, in *TriggerRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AckEvent(ctx context.Context, in *AckEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type triggerExecutableClient struct {
	cc grpc.ClientConnInterface
}

func NewTriggerExecutableClient(cc grpc.ClientConnInterface) TriggerExecutableClient {
	return &triggerExecutableClient{cc}
}

func (c *triggerExecutableClient) RegisterTrigger(ctx context.Context, in *TriggerRegistrationRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TriggerResponseMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &TriggerExecutable_ServiceDesc.Streams[0], TriggerExecutable_RegisterTrigger_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TriggerRegistrationRequest, TriggerResponseMessage]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TriggerExecutable_RegisterTriggerClient = grpc.ServerStreamingClient[TriggerResponseMessage]

func (c *triggerExecutableClient) UnregisterTrigger(ctx context.Context, in *TriggerRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TriggerExecutable_UnregisterTrigger_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerExecutableClient) AckEvent(ctx context.Context, in *AckEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TriggerExecutable_AckEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TriggerExecutableServer is the server API for TriggerExecutable service.
// All implementations must embed UnimplementedTriggerExecutableServer
// for forward compatibility.
type TriggerExecutableServer interface {
	RegisterTrigger(*TriggerRegistrationRequest, grpc.ServerStreamingServer[TriggerResponseMessage]) error
	UnregisterTrigger(context.Context, *TriggerRegistrationRequest) (*emptypb.Empty, error)
	AckEvent(context.Context, *AckEventRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedTriggerExecutableServer()
}

// UnimplementedTriggerExecutableServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTriggerExecutableServer struct{}

func (UnimplementedTriggerExecutableServer) RegisterTrigger(*TriggerRegistrationRequest, grpc.ServerStreamingServer[TriggerResponseMessage]) error {
	return status.Errorf(codes.Unimplemented, "method RegisterTrigger not implemented")
}
func (UnimplementedTriggerExecutableServer) UnregisterTrigger(context.Context, *TriggerRegistrationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterTrigger not implemented")
}
func (UnimplementedTriggerExecutableServer) AckEvent(context.Context, *AckEventRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AckEvent not implemented")
}
func (UnimplementedTriggerExecutableServer) mustEmbedUnimplementedTriggerExecutableServer() {}
func (UnimplementedTriggerExecutableServer) testEmbeddedByValue()                           {}

// UnsafeTriggerExecutableServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TriggerExecutableServer will
// result in compilation errors.
type UnsafeTriggerExecutableServer interface {
	mustEmbedUnimplementedTriggerExecutableServer()
}

func RegisterTriggerExecutableServer(s grpc.ServiceRegistrar, srv TriggerExecutableServer) {
	// If the following call pancis, it indicates UnimplementedTriggerExecutableServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TriggerExecutable_ServiceDesc, srv)
}

func _TriggerExecutable_RegisterTrigger_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TriggerRegistrationRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TriggerExecutableServer).RegisterTrigger(m, &grpc.GenericServerStream[TriggerRegistrationRequest, TriggerResponseMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TriggerExecutable_RegisterTriggerServer = grpc.ServerStreamingServer[TriggerResponseMessage]

func _TriggerExecutable_UnregisterTrigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TriggerRegistrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerExecutableServer).UnregisterTrigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerExecutable_UnregisterTrigger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerExecutableServer).UnregisterTrigger(ctx, req.(*TriggerRegistrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerExecutable_AckEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerExecutableServer).AckEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerExecutable_AckEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerExecutableServer).AckEvent(ctx, req.(*AckEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TriggerExecutable_ServiceDesc is the grpc.ServiceDesc for TriggerExecutable service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TriggerExecutable_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "capabilities.TriggerExecutable",
	HandlerType: (*TriggerExecutableServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UnregisterTrigger",
			Handler:    _TriggerExecutable_UnregisterTrigger_Handler,
		},
		{
			MethodName: "AckEvent",
			Handler:    _TriggerExecutable_AckEvent_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RegisterTrigger",
			Handler:       _TriggerExecutable_RegisterTrigger_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "capabilities.proto",
}

const (
	Executable_RegisterToWorkflow_FullMethodName     = "/capabilities.Executable/RegisterToWorkflow"
	Executable_UnregisterFromWorkflow_FullMethodName = "/capabilities.Executable/UnregisterFromWorkflow"
	Executable_Execute_FullMethodName                = "/capabilities.Executable/Execute"
)

// ExecutableClient is the client API for Executable service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ExecutableClient interface {
	RegisterToWorkflow(ctx context.Context, in *RegisterToWorkflowRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UnregisterFromWorkflow(ctx context.Context, in *UnregisterFromWorkflowRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Execute(ctx context.Context, in *CapabilityRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CapabilityResponse], error)
}

type executableClient struct {
	cc grpc.ClientConnInterface
}

func NewExecutableClient(cc grpc.ClientConnInterface) ExecutableClient {
	return &executableClient{cc}
}

func (c *executableClient) RegisterToWorkflow(ctx context.Context, in *RegisterToWorkflowRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Executable_RegisterToWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executableClient) UnregisterFromWorkflow(ctx context.Context, in *UnregisterFromWorkflowRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Executable_UnregisterFromWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executableClient) Execute(ctx context.Context, in *CapabilityRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CapabilityResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Executable_ServiceDesc.Streams[0], Executable_Execute_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[CapabilityRequest, CapabilityResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Executable_ExecuteClient = grpc.ServerStreamingClient[CapabilityResponse]

// ExecutableServer is the server API for Executable service.
// All implementations must embed UnimplementedExecutableServer
// for forward compatibility.
type ExecutableServer interface {
	RegisterToWorkflow(context.Context, *RegisterToWorkflowRequest) (*emptypb.Empty, error)
	UnregisterFromWorkflow(context.Context, *UnregisterFromWorkflowRequest) (*emptypb.Empty, error)
	Execute(*CapabilityRequest, grpc.ServerStreamingServer[CapabilityResponse]) error
	mustEmbedUnimplementedExecutableServer()
}

// UnimplementedExecutableServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedExecutableServer struct{}

func (UnimplementedExecutableServer) RegisterToWorkflow(context.Context, *RegisterToWorkflowRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterToWorkflow not implemented")
}
func (UnimplementedExecutableServer) UnregisterFromWorkflow(context.Context, *UnregisterFromWorkflowRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterFromWorkflow not implemented")
}
func (UnimplementedExecutableServer) Execute(*CapabilityRequest, grpc.ServerStreamingServer[CapabilityResponse]) error {
	return status.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (UnimplementedExecutableServer) mustEmbedUnimplementedExecutableServer() {}
func (UnimplementedExecutableServer) testEmbeddedByValue()                    {}

// UnsafeExecutableServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExecutableServer will
// result in compilation errors.
type UnsafeExecutableServer interface {
	mustEmbedUnimplementedExecutableServer()
}

func RegisterExecutableServer(s grpc.ServiceRegistrar, srv ExecutableServer) {
	// If the following call pancis, it indicates UnimplementedExecutableServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Executable_ServiceDesc, srv)
}

func _Executable_RegisterToWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterToWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutableServer).RegisterToWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Executable_RegisterToWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutableServer).RegisterToWorkflow(ctx, req.(*RegisterToWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Executable_UnregisterFromWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterFromWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutableServer).UnregisterFromWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Executable_UnregisterFromWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutableServer).UnregisterFromWorkflow(ctx, req.(*UnregisterFromWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Executable_Execute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CapabilityRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExecutableServer).Execute(m, &grpc.GenericServerStream[CapabilityRequest, CapabilityResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Executable_ExecuteServer = grpc.ServerStreamingServer[CapabilityResponse]

// Executable_ServiceDesc is the grpc.ServiceDesc for Executable service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Executable_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "capabilities.Executable",
	HandlerType: (*ExecutableServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterToWorkflow",
			Handler:    _Executable_RegisterToWorkflow_Handler,
		},
		{
			MethodName: "UnregisterFromWorkflow",
			Handler:    _Executable_UnregisterFromWorkflow_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Execute",
			Handler:       _Executable_Execute_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "capabilities.proto",
}

const (
	StandardCapabilities_Initialise_FullMethodName = "/capabilities.StandardCapabilities/Initialise"
	StandardCapabilities_Infos_FullMethodName      = "/capabilities.StandardCapabilities/Infos"
)

// StandardCapabilitiesClient is the client API for StandardCapabilities service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StandardCapabilitiesClient interface {
	Initialise(ctx context.Context, in *InitialiseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Infos(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CapabilityInfosReply, error)
}

type standardCapabilitiesClient struct {
	cc grpc.ClientConnInterface
}

func NewStandardCapabilitiesClient(cc grpc.ClientConnInterface) StandardCapabilitiesClient {
	return &standardCapabilitiesClient{cc}
}

func (c *standardCapabilitiesClient) Initialise(ctx context.Context, in *InitialiseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, StandardCapabilities_Initialise_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *standardCapabilitiesClient) Infos(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CapabilityInfosReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CapabilityInfosReply)
	err := c.cc.Invoke(ctx, StandardCapabilities_Infos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StandardCapabilitiesServer is the server API for StandardCapabilities service.
// All implementations must embed UnimplementedStandardCapabilitiesServer
// for forward compatibility.
type StandardCapabilitiesServer interface {
	Initialise(context.Context, *InitialiseRequest) (*emptypb.Empty, error)
	Infos(context.Context, *emptypb.Empty) (*CapabilityInfosReply, error)
	mustEmbedUnimplementedStandardCapabilitiesServer()
}

// UnimplementedStandardCapabilitiesServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStandardCapabilitiesServer struct{}

func (UnimplementedStandardCapabilitiesServer) Initialise(context.Context, *InitialiseRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Initialise not implemented")
}
func (UnimplementedStandardCapabilitiesServer) Infos(context.Context, *emptypb.Empty) (*CapabilityInfosReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Infos not implemented")
}
func (UnimplementedStandardCapabilitiesServer) mustEmbedUnimplementedStandardCapabilitiesServer() {}
func (UnimplementedStandardCapabilitiesServer) testEmbeddedByValue()                              {}

// UnsafeStandardCapabilitiesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StandardCapabilitiesServer will
// result in compilation errors.
type UnsafeStandardCapabilitiesServer interface {
	mustEmbedUnimplementedStandardCapabilitiesServer()
}

func RegisterStandardCapabilitiesServer(s grpc.ServiceRegistrar, srv StandardCapabilitiesServer) {
	// If the following call pancis, it indicates UnimplementedStandardCapabilitiesServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StandardCapabilities_ServiceDesc, srv)
}

func _StandardCapabilities_Initialise_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitialiseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StandardCapabilitiesServer).Initialise(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StandardCapabilities_Initialise_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StandardCapabilitiesServer).Initialise(ctx, req.(*InitialiseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StandardCapabilities_Infos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StandardCapabilitiesServer).Infos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StandardCapabilities_Infos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StandardCapabilitiesServer).Infos(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// StandardCapabilities_ServiceDesc is the grpc.ServiceDesc for StandardCapabilities service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StandardCapabilities_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "capabilities.StandardCapabilities",
	HandlerType: (*StandardCapabilitiesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Initialise",
			Handler:    _StandardCapabilities_Initialise_Handler,
		},
		{
			MethodName: "Infos",
			Handler:    _StandardCapabilities_Infos_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "capabilities.proto",
}

const (
	Settings_Subscribe_FullMethodName = "/capabilities.Settings/Subscribe"
)

// SettingsClient is the client API for Settings service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SettingsClient interface {
	Subscribe(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SettingsUpdate], error)
}

type settingsClient struct {
	cc grpc.ClientConnInterface
}

func NewSettingsClient(cc grpc.ClientConnInterface) SettingsClient {
	return &settingsClient{cc}
}

func (c *settingsClient) Subscribe(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SettingsUpdate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Settings_ServiceDesc.Streams[0], Settings_Subscribe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[emptypb.Empty, SettingsUpdate]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Settings_SubscribeClient = grpc.ServerStreamingClient[SettingsUpdate]

// SettingsServer is the server API for Settings service.
// All implementations must embed UnimplementedSettingsServer
// for forward compatibility.
type SettingsServer interface {
	Subscribe(*emptypb.Empty, grpc.ServerStreamingServer[SettingsUpdate]) error
	mustEmbedUnimplementedSettingsServer()
}

// UnimplementedSettingsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSettingsServer struct{}

func (UnimplementedSettingsServer) Subscribe(*emptypb.Empty, grpc.ServerStreamingServer[SettingsUpdate]) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedSettingsServer) mustEmbedUnimplementedSettingsServer() {}
func (UnimplementedSettingsServer) testEmbeddedByValue()                  {}

// UnsafeSettingsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SettingsServer will
// result in compilation errors.
type UnsafeSettingsServer interface {
	mustEmbedUnimplementedSettingsServer()
}

func RegisterSettingsServer(s grpc.ServiceRegistrar, srv SettingsServer) {
	// If the following call pancis, it indicates UnimplementedSettingsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Settings_ServiceDesc, srv)
}

func _Settings_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SettingsServer).Subscribe(m, &grpc.GenericServerStream[emptypb.Empty, SettingsUpdate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Settings_SubscribeServer = grpc.ServerStreamingServer[SettingsUpdate]

// Settings_ServiceDesc is the grpc.ServiceDesc for Settings service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Settings_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "capabilities.Settings",
	HandlerType: (*SettingsServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _Settings_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "capabilities.proto",
}
