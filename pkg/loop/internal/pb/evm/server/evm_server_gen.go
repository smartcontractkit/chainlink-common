// Code generated by github.com/smartcontractkit/chainlink-common/pkg/capabilities/v2/protoc, DO NOT EDIT.

package server

import (
	"context"
	"fmt"
	"time"

	"google.golang.org/protobuf/types/known/emptypb"

	"github.com/smartcontractkit/chainlink-common/pkg/loop/internal/pb"
	"github.com/smartcontractkit/chainlink-common/pkg/loop/internal/pb/evm"

	"github.com/smartcontractkit/chainlink-common/pkg/capabilities"
	"github.com/smartcontractkit/chainlink-common/pkg/loop"
	"github.com/smartcontractkit/chainlink-common/pkg/types/core"
)

// Avoid unused imports if there is configuration type
var _ = emptypb.Empty{}

type EVMCapability interface {
	GetTransactionFee(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.GetTransactionFeeRequest) (*evm.GetTransactionFeeReply, error)

	CallContract(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.CallContractRequest) (*evm.CallContractReply, error)

	GetLogs(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.GetLogsRequest) (*evm.GetLogsReply, error)

	BalanceAt(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.BalanceAtRequest) (*evm.BalanceAtReply, error)

	EstimateGas(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.EstimateGasRequest) (*evm.EstimateGasReply, error)

	GetTransactionByHash(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.GetTransactionByHashRequest) (*evm.GetTransactionByHashReply, error)

	GetTransactionReceipt(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.GetReceiptRequest) (*evm.GetReceiptReply, error)

	LatestAndFinalizedHead(ctx context.Context, metadata capabilities.RequestMetadata, input *emptypb.Empty) (*evm.LatestAndFinalizedHeadReply, error)

	QueryLogsFromCache(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.QueryLogsFromCacheRequest) (*evm.QueryLogsFromCacheReply, error)

	RegisterLogTracking(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.RegisterLogTrackingRequest) (*emptypb.Empty, error)

	UnregisterLogTracking(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.UnregisterLogTrackingRequest) (*emptypb.Empty, error)

	GetTransactionStatus(ctx context.Context, metadata capabilities.RequestMetadata, input *pb.GetTransactionStatusRequest) (*pb.GetTransactionStatusReply, error)
	Start(ctx context.Context) error
	Close() error
	HealthReport() map[string]error
	Name() string
	Description() string
	Ready() error
	Initialise(ctx context.Context, config string, telemetryService core.TelemetryService, store core.KeyValueStore, errorLog core.ErrorLog, pipelineRunner core.PipelineRunnerService, relayerSet core.RelayerSet, oracleFactory core.OracleFactory) error
}

func NewEVMServer(capability EVMCapability) loop.StandardCapabilities {
	return &eVMServer{
		eVMCapability: eVMCapability{EVMCapability: capability},
	}
}

type eVMServer struct {
	eVMCapability
	capabilityRegistry core.CapabilitiesRegistry
}

func (cs *eVMServer) Initialise(ctx context.Context, config string, telemetryService core.TelemetryService, store core.KeyValueStore, capabilityRegistry core.CapabilitiesRegistry, errorLog core.ErrorLog, pipelineRunner core.PipelineRunnerService, relayerSet core.RelayerSet, oracleFactory core.OracleFactory) error {
	if err := cs.EVMCapability.Initialise(ctx, config, telemetryService, store, errorLog, pipelineRunner, relayerSet, oracleFactory); err != nil {
		return fmt.Errorf("error when initializing capability: %w", err)
	}

	cs.capabilityRegistry = capabilityRegistry

	if err := capabilityRegistry.Add(ctx, &eVMCapability{
		EVMCapability: cs.EVMCapability,
	}); err != nil {
		return fmt.Errorf("error when adding kv store action to the registry: %w", err)
	}

	return nil
}

func (cs *eVMServer) Close() error {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()
	if err := cs.capabilityRegistry.Remove(ctx, "mainnet-evm@1.0.0"); err != nil {
		return err
	}

	return cs.eVMCapability.Close()
}

func (cs *eVMServer) Infos(ctx context.Context) ([]capabilities.CapabilityInfo, error) {
	info, err := cs.eVMCapability.Info(ctx)
	if err != nil {
		return nil, err
	}
	return []capabilities.CapabilityInfo{info}, nil
}

type eVMCapability struct {
	EVMCapability
}

func (c *eVMCapability) Info(ctx context.Context) (capabilities.CapabilityInfo, error) {
	// Maybe we do need to split it out, even if the user doesn't see it
	return capabilities.NewCapabilityInfo("mainnet-evm@1.0.0", capabilities.CapabilityTypeV2, c.EVMCapability.Description())
}

var _ capabilities.ExecutableAndTriggerCapability = (*eVMCapability)(nil)

func (c *eVMCapability) RegisterTrigger(ctx context.Context, request capabilities.TriggerRegistrationRequest) (<-chan capabilities.TriggerResponse, error) {
	return nil, fmt.Errorf("trigger %s not found", request.Method)
}

func (c *eVMCapability) UnregisterTrigger(ctx context.Context, request capabilities.TriggerRegistrationRequest) error {
	return fmt.Errorf("trigger %s not found", request.Method)
}

func (c *eVMCapability) RegisterToWorkflow(ctx context.Context, request capabilities.RegisterToWorkflowRequest) error {
	return nil
}

func (c *eVMCapability) UnregisterFromWorkflow(ctx context.Context, request capabilities.UnregisterFromWorkflowRequest) error {
	return nil
}

func (c *eVMCapability) Execute(ctx context.Context, request capabilities.CapabilityRequest) (capabilities.CapabilityResponse, error) {
	response := capabilities.CapabilityResponse{}
	switch request.Method {
	case "GetTransactionFee":
		input := &evm.GetTransactionFeeRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.GetTransactionFeeRequest, _ *emptypb.Empty) (*evm.GetTransactionFeeReply, error) {
			return c.EVMCapability.GetTransactionFee(ctx, metadata, input)
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	case "CallContract":
		input := &evm.CallContractRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.CallContractRequest, _ *emptypb.Empty) (*evm.CallContractReply, error) {
			return c.EVMCapability.CallContract(ctx, metadata, input)
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	case "GetLogs":
		input := &evm.GetLogsRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.GetLogsRequest, _ *emptypb.Empty) (*evm.GetLogsReply, error) {
			return c.EVMCapability.GetLogs(ctx, metadata, input)
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	case "BalanceAt":
		input := &evm.BalanceAtRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.BalanceAtRequest, _ *emptypb.Empty) (*evm.BalanceAtReply, error) {
			return c.EVMCapability.BalanceAt(ctx, metadata, input)
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	case "EstimateGas":
		input := &evm.EstimateGasRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.EstimateGasRequest, _ *emptypb.Empty) (*evm.EstimateGasReply, error) {
			return c.EVMCapability.EstimateGas(ctx, metadata, input)
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	case "GetTransactionByHash":
		input := &evm.GetTransactionByHashRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.GetTransactionByHashRequest, _ *emptypb.Empty) (*evm.GetTransactionByHashReply, error) {
			return c.EVMCapability.GetTransactionByHash(ctx, metadata, input)
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	case "GetTransactionReceipt":
		input := &evm.GetReceiptRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.GetReceiptRequest, _ *emptypb.Empty) (*evm.GetReceiptReply, error) {
			return c.EVMCapability.GetTransactionReceipt(ctx, metadata, input)
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	case "LatestAndFinalizedHead":
		input := &emptypb.Empty{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *emptypb.Empty, _ *emptypb.Empty) (*evm.LatestAndFinalizedHeadReply, error) {
			return c.EVMCapability.LatestAndFinalizedHead(ctx, metadata, input)
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	case "QueryLogsFromCache":
		input := &evm.QueryLogsFromCacheRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.QueryLogsFromCacheRequest, _ *emptypb.Empty) (*evm.QueryLogsFromCacheReply, error) {
			return c.EVMCapability.QueryLogsFromCache(ctx, metadata, input)
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	case "RegisterLogTracking":
		input := &evm.RegisterLogTrackingRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.RegisterLogTrackingRequest, _ *emptypb.Empty) (*emptypb.Empty, error) {
			return c.EVMCapability.RegisterLogTracking(ctx, metadata, input)
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	case "UnregisterLogTracking":
		input := &evm.UnregisterLogTrackingRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.UnregisterLogTrackingRequest, _ *emptypb.Empty) (*emptypb.Empty, error) {
			return c.EVMCapability.UnregisterLogTracking(ctx, metadata, input)
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	case "GetTransactionStatus":
		input := &pb.GetTransactionStatusRequest{}
		config := &emptypb.Empty{}
		wrapped := func(ctx context.Context, metadata capabilities.RequestMetadata, input *pb.GetTransactionStatusRequest, _ *emptypb.Empty) (*pb.GetTransactionStatusReply, error) {
			return c.EVMCapability.GetTransactionStatus(ctx, metadata, input)
		}
		return capabilities.Execute(ctx, request, input, config, wrapped)
	default:
		return response, fmt.Errorf("method %s not found", request.Method)
	}
}
