// Code generated by github.com/smartcontractkit/chainlink-common/pkg/capabilities/v2/protoc, DO NOT EDIT.

package cronmock

import (
	"context"
	"fmt"
	"testing"

	"google.golang.org/protobuf/types/known/anypb"

	"github.com/smartcontractkit/chainlink-common/pkg/capabilities/v2/triggers/cron"

	sdkpb "github.com/smartcontractkit/chainlink-common/pkg/workflows/sdk/v2/pb"
	"github.com/smartcontractkit/chainlink-common/pkg/workflows/sdk/v2/testutils/registry"
)

// avoid unused imports
var _ = registry.Registry{}

func NewCronCapability(t testing.TB) (*CronCapability, error) {
	c := &CronCapability{}
	reg := registry.GetRegistry(t)
	err := reg.RegisterCapability(c)
	return c, err
}

type CronCapability struct {
	Trigger func(ctx context.Context, input *cron.Config) (*cron.Payload, error)

	LegacyTrigger func(ctx context.Context, input *cron.Config) (*cron.LegacyPayload, error)
}

func (cap *CronCapability) Invoke(ctx context.Context, request *sdkpb.CapabilityRequest) *sdkpb.CapabilityResponse {
	capResp := &sdkpb.CapabilityResponse{}
	capResp.Response = &sdkpb.CapabilityResponse_Error{Error: fmt.Sprintf("method %s not found", request.Method)}
	return capResp
}

func (cap *CronCapability) InvokeTrigger(ctx context.Context, request *sdkpb.TriggerSubscription) (*sdkpb.Trigger, error) {
	trigger := &sdkpb.Trigger{}
	switch request.Method {
	case "Trigger":
		input := &cron.Config{}
		if err := request.Payload.UnmarshalTo(input); err != nil {
			return nil, err
		}

		if cap.Trigger == nil {
			return nil, registry.ErrNoTriggerStub("Trigger")
		}

		resp, err := cap.Trigger(ctx, input)
		if err != nil {
			return nil, err
		} else {
			if resp == nil {
				return nil, nil
			}

			payload, err := anypb.New(resp)
			if err != nil {
				return nil, err
			}
			trigger.Payload = payload
		}
	case "LegacyTrigger":
		input := &cron.Config{}
		if err := request.Payload.UnmarshalTo(input); err != nil {
			return nil, err
		}

		if cap.LegacyTrigger == nil {
			return nil, registry.ErrNoTriggerStub("LegacyTrigger")
		}

		resp, err := cap.LegacyTrigger(ctx, input)
		if err != nil {
			return nil, err
		} else {
			if resp == nil {
				return nil, nil
			}

			payload, err := anypb.New(resp)
			if err != nil {
				return nil, err
			}
			trigger.Payload = payload
		}
	default:
		return nil, fmt.Errorf("method %s not found", request.Method)
	}
	return trigger, nil
}

func (cap *CronCapability) ID() string {
	return "cron-trigger@1.0.0"
}
