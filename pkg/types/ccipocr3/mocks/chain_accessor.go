// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	context "context"

	ccipocr3 "github.com/smartcontractkit/chainlink-common/pkg/types/ccipocr3"

	mock "github.com/stretchr/testify/mock"

	primitives "github.com/smartcontractkit/chainlink-common/pkg/types/query/primitives"

	time "time"

	types "github.com/smartcontractkit/libocr/offchainreporting2plus/types"
)

// ChainAccessor is an autogenerated mock type for the ChainAccessor type
type ChainAccessor struct {
	mock.Mock
}

type ChainAccessor_Expecter struct {
	mock *mock.Mock
}

func (_m *ChainAccessor) EXPECT() *ChainAccessor_Expecter {
	return &ChainAccessor_Expecter{mock: &_m.Mock}
}

// CommitReportsGTETimestamp provides a mock function with given fields: ctx, ts, confidence, limit
func (_m *ChainAccessor) CommitReportsGTETimestamp(ctx context.Context, ts time.Time, confidence primitives.ConfidenceLevel, limit int) ([]ccipocr3.CommitPluginReportWithMeta, error) {
	ret := _m.Called(ctx, ts, confidence, limit)

	if len(ret) == 0 {
		panic("no return value specified for CommitReportsGTETimestamp")
	}

	var r0 []ccipocr3.CommitPluginReportWithMeta
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, time.Time, primitives.ConfidenceLevel, int) ([]ccipocr3.CommitPluginReportWithMeta, error)); ok {
		return rf(ctx, ts, confidence, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, time.Time, primitives.ConfidenceLevel, int) []ccipocr3.CommitPluginReportWithMeta); ok {
		r0 = rf(ctx, ts, confidence, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ccipocr3.CommitPluginReportWithMeta)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, time.Time, primitives.ConfidenceLevel, int) error); ok {
		r1 = rf(ctx, ts, confidence, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainAccessor_CommitReportsGTETimestamp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CommitReportsGTETimestamp'
type ChainAccessor_CommitReportsGTETimestamp_Call struct {
	*mock.Call
}

// CommitReportsGTETimestamp is a helper method to define mock.On call
//   - ctx context.Context
//   - ts time.Time
//   - confidence primitives.ConfidenceLevel
//   - limit int
func (_e *ChainAccessor_Expecter) CommitReportsGTETimestamp(ctx interface{}, ts interface{}, confidence interface{}, limit interface{}) *ChainAccessor_CommitReportsGTETimestamp_Call {
	return &ChainAccessor_CommitReportsGTETimestamp_Call{Call: _e.mock.On("CommitReportsGTETimestamp", ctx, ts, confidence, limit)}
}

func (_c *ChainAccessor_CommitReportsGTETimestamp_Call) Run(run func(ctx context.Context, ts time.Time, confidence primitives.ConfidenceLevel, limit int)) *ChainAccessor_CommitReportsGTETimestamp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(time.Time), args[2].(primitives.ConfidenceLevel), args[3].(int))
	})
	return _c
}

func (_c *ChainAccessor_CommitReportsGTETimestamp_Call) Return(_a0 []ccipocr3.CommitPluginReportWithMeta, _a1 error) *ChainAccessor_CommitReportsGTETimestamp_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ChainAccessor_CommitReportsGTETimestamp_Call) RunAndReturn(run func(context.Context, time.Time, primitives.ConfidenceLevel, int) ([]ccipocr3.CommitPluginReportWithMeta, error)) *ChainAccessor_CommitReportsGTETimestamp_Call {
	_c.Call.Return(run)
	return _c
}

// ExecutedMessages provides a mock function with given fields: ctx, ranges, confidence
func (_m *ChainAccessor) ExecutedMessages(ctx context.Context, ranges map[ccipocr3.ChainSelector][]ccipocr3.SeqNumRange, confidence primitives.ConfidenceLevel) (map[ccipocr3.ChainSelector][]ccipocr3.SeqNum, error) {
	ret := _m.Called(ctx, ranges, confidence)

	if len(ret) == 0 {
		panic("no return value specified for ExecutedMessages")
	}

	var r0 map[ccipocr3.ChainSelector][]ccipocr3.SeqNum
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, map[ccipocr3.ChainSelector][]ccipocr3.SeqNumRange, primitives.ConfidenceLevel) (map[ccipocr3.ChainSelector][]ccipocr3.SeqNum, error)); ok {
		return rf(ctx, ranges, confidence)
	}
	if rf, ok := ret.Get(0).(func(context.Context, map[ccipocr3.ChainSelector][]ccipocr3.SeqNumRange, primitives.ConfidenceLevel) map[ccipocr3.ChainSelector][]ccipocr3.SeqNum); ok {
		r0 = rf(ctx, ranges, confidence)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[ccipocr3.ChainSelector][]ccipocr3.SeqNum)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, map[ccipocr3.ChainSelector][]ccipocr3.SeqNumRange, primitives.ConfidenceLevel) error); ok {
		r1 = rf(ctx, ranges, confidence)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainAccessor_ExecutedMessages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecutedMessages'
type ChainAccessor_ExecutedMessages_Call struct {
	*mock.Call
}

// ExecutedMessages is a helper method to define mock.On call
//   - ctx context.Context
//   - ranges map[ccipocr3.ChainSelector][]ccipocr3.SeqNumRange
//   - confidence primitives.ConfidenceLevel
func (_e *ChainAccessor_Expecter) ExecutedMessages(ctx interface{}, ranges interface{}, confidence interface{}) *ChainAccessor_ExecutedMessages_Call {
	return &ChainAccessor_ExecutedMessages_Call{Call: _e.mock.On("ExecutedMessages", ctx, ranges, confidence)}
}

func (_c *ChainAccessor_ExecutedMessages_Call) Run(run func(ctx context.Context, ranges map[ccipocr3.ChainSelector][]ccipocr3.SeqNumRange, confidence primitives.ConfidenceLevel)) *ChainAccessor_ExecutedMessages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(map[ccipocr3.ChainSelector][]ccipocr3.SeqNumRange), args[2].(primitives.ConfidenceLevel))
	})
	return _c
}

func (_c *ChainAccessor_ExecutedMessages_Call) Return(_a0 map[ccipocr3.ChainSelector][]ccipocr3.SeqNum, _a1 error) *ChainAccessor_ExecutedMessages_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ChainAccessor_ExecutedMessages_Call) RunAndReturn(run func(context.Context, map[ccipocr3.ChainSelector][]ccipocr3.SeqNumRange, primitives.ConfidenceLevel) (map[ccipocr3.ChainSelector][]ccipocr3.SeqNum, error)) *ChainAccessor_ExecutedMessages_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllConfigLegacySnapshot provides a mock function with given fields: ctx
func (_m *ChainAccessor) GetAllConfigLegacySnapshot(ctx context.Context) (ccipocr3.ChainConfigSnapshot, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAllConfigLegacySnapshot")
	}

	var r0 ccipocr3.ChainConfigSnapshot
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (ccipocr3.ChainConfigSnapshot, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) ccipocr3.ChainConfigSnapshot); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(ccipocr3.ChainConfigSnapshot)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainAccessor_GetAllConfigLegacySnapshot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllConfigLegacySnapshot'
type ChainAccessor_GetAllConfigLegacySnapshot_Call struct {
	*mock.Call
}

// GetAllConfigLegacySnapshot is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ChainAccessor_Expecter) GetAllConfigLegacySnapshot(ctx interface{}) *ChainAccessor_GetAllConfigLegacySnapshot_Call {
	return &ChainAccessor_GetAllConfigLegacySnapshot_Call{Call: _e.mock.On("GetAllConfigLegacySnapshot", ctx)}
}

func (_c *ChainAccessor_GetAllConfigLegacySnapshot_Call) Run(run func(ctx context.Context)) *ChainAccessor_GetAllConfigLegacySnapshot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *ChainAccessor_GetAllConfigLegacySnapshot_Call) Return(_a0 ccipocr3.ChainConfigSnapshot, _a1 error) *ChainAccessor_GetAllConfigLegacySnapshot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ChainAccessor_GetAllConfigLegacySnapshot_Call) RunAndReturn(run func(context.Context) (ccipocr3.ChainConfigSnapshot, error)) *ChainAccessor_GetAllConfigLegacySnapshot_Call {
	_c.Call.Return(run)
	return _c
}

// GetChainFeeComponents provides a mock function with given fields: ctx
func (_m *ChainAccessor) GetChainFeeComponents(ctx context.Context) (ccipocr3.ChainFeeComponents, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetChainFeeComponents")
	}

	var r0 ccipocr3.ChainFeeComponents
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (ccipocr3.ChainFeeComponents, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) ccipocr3.ChainFeeComponents); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(ccipocr3.ChainFeeComponents)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainAccessor_GetChainFeeComponents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetChainFeeComponents'
type ChainAccessor_GetChainFeeComponents_Call struct {
	*mock.Call
}

// GetChainFeeComponents is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ChainAccessor_Expecter) GetChainFeeComponents(ctx interface{}) *ChainAccessor_GetChainFeeComponents_Call {
	return &ChainAccessor_GetChainFeeComponents_Call{Call: _e.mock.On("GetChainFeeComponents", ctx)}
}

func (_c *ChainAccessor_GetChainFeeComponents_Call) Run(run func(ctx context.Context)) *ChainAccessor_GetChainFeeComponents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *ChainAccessor_GetChainFeeComponents_Call) Return(_a0 ccipocr3.ChainFeeComponents, _a1 error) *ChainAccessor_GetChainFeeComponents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ChainAccessor_GetChainFeeComponents_Call) RunAndReturn(run func(context.Context) (ccipocr3.ChainFeeComponents, error)) *ChainAccessor_GetChainFeeComponents_Call {
	_c.Call.Return(run)
	return _c
}

// GetChainFeePriceUpdate provides a mock function with given fields: ctx, selectors
func (_m *ChainAccessor) GetChainFeePriceUpdate(ctx context.Context, selectors []ccipocr3.ChainSelector) map[ccipocr3.ChainSelector]ccipocr3.TimestampedBig {
	ret := _m.Called(ctx, selectors)

	if len(ret) == 0 {
		panic("no return value specified for GetChainFeePriceUpdate")
	}

	var r0 map[ccipocr3.ChainSelector]ccipocr3.TimestampedBig
	if rf, ok := ret.Get(0).(func(context.Context, []ccipocr3.ChainSelector) map[ccipocr3.ChainSelector]ccipocr3.TimestampedBig); ok {
		r0 = rf(ctx, selectors)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[ccipocr3.ChainSelector]ccipocr3.TimestampedBig)
		}
	}

	return r0
}

// ChainAccessor_GetChainFeePriceUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetChainFeePriceUpdate'
type ChainAccessor_GetChainFeePriceUpdate_Call struct {
	*mock.Call
}

// GetChainFeePriceUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - selectors []ccipocr3.ChainSelector
func (_e *ChainAccessor_Expecter) GetChainFeePriceUpdate(ctx interface{}, selectors interface{}) *ChainAccessor_GetChainFeePriceUpdate_Call {
	return &ChainAccessor_GetChainFeePriceUpdate_Call{Call: _e.mock.On("GetChainFeePriceUpdate", ctx, selectors)}
}

func (_c *ChainAccessor_GetChainFeePriceUpdate_Call) Run(run func(ctx context.Context, selectors []ccipocr3.ChainSelector)) *ChainAccessor_GetChainFeePriceUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]ccipocr3.ChainSelector))
	})
	return _c
}

func (_c *ChainAccessor_GetChainFeePriceUpdate_Call) Return(_a0 map[ccipocr3.ChainSelector]ccipocr3.TimestampedBig) *ChainAccessor_GetChainFeePriceUpdate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ChainAccessor_GetChainFeePriceUpdate_Call) RunAndReturn(run func(context.Context, []ccipocr3.ChainSelector) map[ccipocr3.ChainSelector]ccipocr3.TimestampedBig) *ChainAccessor_GetChainFeePriceUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// GetContractAddress provides a mock function with given fields: contractName
func (_m *ChainAccessor) GetContractAddress(contractName string) ([]byte, error) {
	ret := _m.Called(contractName)

	if len(ret) == 0 {
		panic("no return value specified for GetContractAddress")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]byte, error)); ok {
		return rf(contractName)
	}
	if rf, ok := ret.Get(0).(func(string) []byte); ok {
		r0 = rf(contractName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(contractName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainAccessor_GetContractAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetContractAddress'
type ChainAccessor_GetContractAddress_Call struct {
	*mock.Call
}

// GetContractAddress is a helper method to define mock.On call
//   - contractName string
func (_e *ChainAccessor_Expecter) GetContractAddress(contractName interface{}) *ChainAccessor_GetContractAddress_Call {
	return &ChainAccessor_GetContractAddress_Call{Call: _e.mock.On("GetContractAddress", contractName)}
}

func (_c *ChainAccessor_GetContractAddress_Call) Run(run func(contractName string)) *ChainAccessor_GetContractAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *ChainAccessor_GetContractAddress_Call) Return(_a0 []byte, _a1 error) *ChainAccessor_GetContractAddress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ChainAccessor_GetContractAddress_Call) RunAndReturn(run func(string) ([]byte, error)) *ChainAccessor_GetContractAddress_Call {
	_c.Call.Return(run)
	return _c
}

// GetExpectedNextSequenceNumber provides a mock function with given fields: ctx, dest
func (_m *ChainAccessor) GetExpectedNextSequenceNumber(ctx context.Context, dest ccipocr3.ChainSelector) (ccipocr3.SeqNum, error) {
	ret := _m.Called(ctx, dest)

	if len(ret) == 0 {
		panic("no return value specified for GetExpectedNextSequenceNumber")
	}

	var r0 ccipocr3.SeqNum
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ccipocr3.ChainSelector) (ccipocr3.SeqNum, error)); ok {
		return rf(ctx, dest)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ccipocr3.ChainSelector) ccipocr3.SeqNum); ok {
		r0 = rf(ctx, dest)
	} else {
		r0 = ret.Get(0).(ccipocr3.SeqNum)
	}

	if rf, ok := ret.Get(1).(func(context.Context, ccipocr3.ChainSelector) error); ok {
		r1 = rf(ctx, dest)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainAccessor_GetExpectedNextSequenceNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExpectedNextSequenceNumber'
type ChainAccessor_GetExpectedNextSequenceNumber_Call struct {
	*mock.Call
}

// GetExpectedNextSequenceNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - dest ccipocr3.ChainSelector
func (_e *ChainAccessor_Expecter) GetExpectedNextSequenceNumber(ctx interface{}, dest interface{}) *ChainAccessor_GetExpectedNextSequenceNumber_Call {
	return &ChainAccessor_GetExpectedNextSequenceNumber_Call{Call: _e.mock.On("GetExpectedNextSequenceNumber", ctx, dest)}
}

func (_c *ChainAccessor_GetExpectedNextSequenceNumber_Call) Run(run func(ctx context.Context, dest ccipocr3.ChainSelector)) *ChainAccessor_GetExpectedNextSequenceNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ccipocr3.ChainSelector))
	})
	return _c
}

func (_c *ChainAccessor_GetExpectedNextSequenceNumber_Call) Return(_a0 ccipocr3.SeqNum, _a1 error) *ChainAccessor_GetExpectedNextSequenceNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ChainAccessor_GetExpectedNextSequenceNumber_Call) RunAndReturn(run func(context.Context, ccipocr3.ChainSelector) (ccipocr3.SeqNum, error)) *ChainAccessor_GetExpectedNextSequenceNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetFeeQuoterDestChainConfig provides a mock function with given fields: ctx, dest
func (_m *ChainAccessor) GetFeeQuoterDestChainConfig(ctx context.Context, dest ccipocr3.ChainSelector) (ccipocr3.FeeQuoterDestChainConfig, error) {
	ret := _m.Called(ctx, dest)

	if len(ret) == 0 {
		panic("no return value specified for GetFeeQuoterDestChainConfig")
	}

	var r0 ccipocr3.FeeQuoterDestChainConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ccipocr3.ChainSelector) (ccipocr3.FeeQuoterDestChainConfig, error)); ok {
		return rf(ctx, dest)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ccipocr3.ChainSelector) ccipocr3.FeeQuoterDestChainConfig); ok {
		r0 = rf(ctx, dest)
	} else {
		r0 = ret.Get(0).(ccipocr3.FeeQuoterDestChainConfig)
	}

	if rf, ok := ret.Get(1).(func(context.Context, ccipocr3.ChainSelector) error); ok {
		r1 = rf(ctx, dest)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainAccessor_GetFeeQuoterDestChainConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFeeQuoterDestChainConfig'
type ChainAccessor_GetFeeQuoterDestChainConfig_Call struct {
	*mock.Call
}

// GetFeeQuoterDestChainConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - dest ccipocr3.ChainSelector
func (_e *ChainAccessor_Expecter) GetFeeQuoterDestChainConfig(ctx interface{}, dest interface{}) *ChainAccessor_GetFeeQuoterDestChainConfig_Call {
	return &ChainAccessor_GetFeeQuoterDestChainConfig_Call{Call: _e.mock.On("GetFeeQuoterDestChainConfig", ctx, dest)}
}

func (_c *ChainAccessor_GetFeeQuoterDestChainConfig_Call) Run(run func(ctx context.Context, dest ccipocr3.ChainSelector)) *ChainAccessor_GetFeeQuoterDestChainConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ccipocr3.ChainSelector))
	})
	return _c
}

func (_c *ChainAccessor_GetFeeQuoterDestChainConfig_Call) Return(_a0 ccipocr3.FeeQuoterDestChainConfig, _a1 error) *ChainAccessor_GetFeeQuoterDestChainConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ChainAccessor_GetFeeQuoterDestChainConfig_Call) RunAndReturn(run func(context.Context, ccipocr3.ChainSelector) (ccipocr3.FeeQuoterDestChainConfig, error)) *ChainAccessor_GetFeeQuoterDestChainConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestPriceSeqNr provides a mock function with given fields: ctx
func (_m *ChainAccessor) GetLatestPriceSeqNr(ctx context.Context) (uint64, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestPriceSeqNr")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (uint64, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) uint64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainAccessor_GetLatestPriceSeqNr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestPriceSeqNr'
type ChainAccessor_GetLatestPriceSeqNr_Call struct {
	*mock.Call
}

// GetLatestPriceSeqNr is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ChainAccessor_Expecter) GetLatestPriceSeqNr(ctx interface{}) *ChainAccessor_GetLatestPriceSeqNr_Call {
	return &ChainAccessor_GetLatestPriceSeqNr_Call{Call: _e.mock.On("GetLatestPriceSeqNr", ctx)}
}

func (_c *ChainAccessor_GetLatestPriceSeqNr_Call) Run(run func(ctx context.Context)) *ChainAccessor_GetLatestPriceSeqNr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *ChainAccessor_GetLatestPriceSeqNr_Call) Return(_a0 uint64, _a1 error) *ChainAccessor_GetLatestPriceSeqNr_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ChainAccessor_GetLatestPriceSeqNr_Call) RunAndReturn(run func(context.Context) (uint64, error)) *ChainAccessor_GetLatestPriceSeqNr_Call {
	_c.Call.Return(run)
	return _c
}

// GetRMNCurseInfo provides a mock function with given fields: ctx
func (_m *ChainAccessor) GetRMNCurseInfo(ctx context.Context) (ccipocr3.CurseInfo, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetRMNCurseInfo")
	}

	var r0 ccipocr3.CurseInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (ccipocr3.CurseInfo, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) ccipocr3.CurseInfo); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(ccipocr3.CurseInfo)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainAccessor_GetRMNCurseInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRMNCurseInfo'
type ChainAccessor_GetRMNCurseInfo_Call struct {
	*mock.Call
}

// GetRMNCurseInfo is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ChainAccessor_Expecter) GetRMNCurseInfo(ctx interface{}) *ChainAccessor_GetRMNCurseInfo_Call {
	return &ChainAccessor_GetRMNCurseInfo_Call{Call: _e.mock.On("GetRMNCurseInfo", ctx)}
}

func (_c *ChainAccessor_GetRMNCurseInfo_Call) Run(run func(ctx context.Context)) *ChainAccessor_GetRMNCurseInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *ChainAccessor_GetRMNCurseInfo_Call) Return(_a0 ccipocr3.CurseInfo, _a1 error) *ChainAccessor_GetRMNCurseInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ChainAccessor_GetRMNCurseInfo_Call) RunAndReturn(run func(context.Context) (ccipocr3.CurseInfo, error)) *ChainAccessor_GetRMNCurseInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetTokenPriceUSD provides a mock function with given fields: ctx, address
func (_m *ChainAccessor) GetTokenPriceUSD(ctx context.Context, address ccipocr3.UnknownAddress) (ccipocr3.TimestampedUnixBig, error) {
	ret := _m.Called(ctx, address)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenPriceUSD")
	}

	var r0 ccipocr3.TimestampedUnixBig
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ccipocr3.UnknownAddress) (ccipocr3.TimestampedUnixBig, error)); ok {
		return rf(ctx, address)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ccipocr3.UnknownAddress) ccipocr3.TimestampedUnixBig); ok {
		r0 = rf(ctx, address)
	} else {
		r0 = ret.Get(0).(ccipocr3.TimestampedUnixBig)
	}

	if rf, ok := ret.Get(1).(func(context.Context, ccipocr3.UnknownAddress) error); ok {
		r1 = rf(ctx, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainAccessor_GetTokenPriceUSD_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTokenPriceUSD'
type ChainAccessor_GetTokenPriceUSD_Call struct {
	*mock.Call
}

// GetTokenPriceUSD is a helper method to define mock.On call
//   - ctx context.Context
//   - address ccipocr3.UnknownAddress
func (_e *ChainAccessor_Expecter) GetTokenPriceUSD(ctx interface{}, address interface{}) *ChainAccessor_GetTokenPriceUSD_Call {
	return &ChainAccessor_GetTokenPriceUSD_Call{Call: _e.mock.On("GetTokenPriceUSD", ctx, address)}
}

func (_c *ChainAccessor_GetTokenPriceUSD_Call) Run(run func(ctx context.Context, address ccipocr3.UnknownAddress)) *ChainAccessor_GetTokenPriceUSD_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ccipocr3.UnknownAddress))
	})
	return _c
}

func (_c *ChainAccessor_GetTokenPriceUSD_Call) Return(_a0 ccipocr3.TimestampedUnixBig, _a1 error) *ChainAccessor_GetTokenPriceUSD_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ChainAccessor_GetTokenPriceUSD_Call) RunAndReturn(run func(context.Context, ccipocr3.UnknownAddress) (ccipocr3.TimestampedUnixBig, error)) *ChainAccessor_GetTokenPriceUSD_Call {
	_c.Call.Return(run)
	return _c
}

// LatestMessageTo provides a mock function with given fields: ctx, dest
func (_m *ChainAccessor) LatestMessageTo(ctx context.Context, dest ccipocr3.ChainSelector) (ccipocr3.Message, error) {
	ret := _m.Called(ctx, dest)

	if len(ret) == 0 {
		panic("no return value specified for LatestMessageTo")
	}

	var r0 ccipocr3.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ccipocr3.ChainSelector) (ccipocr3.Message, error)); ok {
		return rf(ctx, dest)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ccipocr3.ChainSelector) ccipocr3.Message); ok {
		r0 = rf(ctx, dest)
	} else {
		r0 = ret.Get(0).(ccipocr3.Message)
	}

	if rf, ok := ret.Get(1).(func(context.Context, ccipocr3.ChainSelector) error); ok {
		r1 = rf(ctx, dest)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainAccessor_LatestMessageTo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LatestMessageTo'
type ChainAccessor_LatestMessageTo_Call struct {
	*mock.Call
}

// LatestMessageTo is a helper method to define mock.On call
//   - ctx context.Context
//   - dest ccipocr3.ChainSelector
func (_e *ChainAccessor_Expecter) LatestMessageTo(ctx interface{}, dest interface{}) *ChainAccessor_LatestMessageTo_Call {
	return &ChainAccessor_LatestMessageTo_Call{Call: _e.mock.On("LatestMessageTo", ctx, dest)}
}

func (_c *ChainAccessor_LatestMessageTo_Call) Run(run func(ctx context.Context, dest ccipocr3.ChainSelector)) *ChainAccessor_LatestMessageTo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ccipocr3.ChainSelector))
	})
	return _c
}

func (_c *ChainAccessor_LatestMessageTo_Call) Return(_a0 ccipocr3.Message, _a1 error) *ChainAccessor_LatestMessageTo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ChainAccessor_LatestMessageTo_Call) RunAndReturn(run func(context.Context, ccipocr3.ChainSelector) (ccipocr3.Message, error)) *ChainAccessor_LatestMessageTo_Call {
	_c.Call.Return(run)
	return _c
}

// MsgsBetweenSeqNums provides a mock function with given fields: ctx, dest, seqNumRange
func (_m *ChainAccessor) MsgsBetweenSeqNums(ctx context.Context, dest ccipocr3.ChainSelector, seqNumRange ccipocr3.SeqNumRange) ([]ccipocr3.Message, error) {
	ret := _m.Called(ctx, dest, seqNumRange)

	if len(ret) == 0 {
		panic("no return value specified for MsgsBetweenSeqNums")
	}

	var r0 []ccipocr3.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ccipocr3.ChainSelector, ccipocr3.SeqNumRange) ([]ccipocr3.Message, error)); ok {
		return rf(ctx, dest, seqNumRange)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ccipocr3.ChainSelector, ccipocr3.SeqNumRange) []ccipocr3.Message); ok {
		r0 = rf(ctx, dest, seqNumRange)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ccipocr3.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ccipocr3.ChainSelector, ccipocr3.SeqNumRange) error); ok {
		r1 = rf(ctx, dest, seqNumRange)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainAccessor_MsgsBetweenSeqNums_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MsgsBetweenSeqNums'
type ChainAccessor_MsgsBetweenSeqNums_Call struct {
	*mock.Call
}

// MsgsBetweenSeqNums is a helper method to define mock.On call
//   - ctx context.Context
//   - dest ccipocr3.ChainSelector
//   - seqNumRange ccipocr3.SeqNumRange
func (_e *ChainAccessor_Expecter) MsgsBetweenSeqNums(ctx interface{}, dest interface{}, seqNumRange interface{}) *ChainAccessor_MsgsBetweenSeqNums_Call {
	return &ChainAccessor_MsgsBetweenSeqNums_Call{Call: _e.mock.On("MsgsBetweenSeqNums", ctx, dest, seqNumRange)}
}

func (_c *ChainAccessor_MsgsBetweenSeqNums_Call) Run(run func(ctx context.Context, dest ccipocr3.ChainSelector, seqNumRange ccipocr3.SeqNumRange)) *ChainAccessor_MsgsBetweenSeqNums_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ccipocr3.ChainSelector), args[2].(ccipocr3.SeqNumRange))
	})
	return _c
}

func (_c *ChainAccessor_MsgsBetweenSeqNums_Call) Return(_a0 []ccipocr3.Message, _a1 error) *ChainAccessor_MsgsBetweenSeqNums_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ChainAccessor_MsgsBetweenSeqNums_Call) RunAndReturn(run func(context.Context, ccipocr3.ChainSelector, ccipocr3.SeqNumRange) ([]ccipocr3.Message, error)) *ChainAccessor_MsgsBetweenSeqNums_Call {
	_c.Call.Return(run)
	return _c
}

// NextSeqNum provides a mock function with given fields: ctx, sources
func (_m *ChainAccessor) NextSeqNum(ctx context.Context, sources []ccipocr3.ChainSelector) (map[ccipocr3.ChainSelector]ccipocr3.SeqNum, error) {
	ret := _m.Called(ctx, sources)

	if len(ret) == 0 {
		panic("no return value specified for NextSeqNum")
	}

	var r0 map[ccipocr3.ChainSelector]ccipocr3.SeqNum
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []ccipocr3.ChainSelector) (map[ccipocr3.ChainSelector]ccipocr3.SeqNum, error)); ok {
		return rf(ctx, sources)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []ccipocr3.ChainSelector) map[ccipocr3.ChainSelector]ccipocr3.SeqNum); ok {
		r0 = rf(ctx, sources)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[ccipocr3.ChainSelector]ccipocr3.SeqNum)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []ccipocr3.ChainSelector) error); ok {
		r1 = rf(ctx, sources)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainAccessor_NextSeqNum_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NextSeqNum'
type ChainAccessor_NextSeqNum_Call struct {
	*mock.Call
}

// NextSeqNum is a helper method to define mock.On call
//   - ctx context.Context
//   - sources []ccipocr3.ChainSelector
func (_e *ChainAccessor_Expecter) NextSeqNum(ctx interface{}, sources interface{}) *ChainAccessor_NextSeqNum_Call {
	return &ChainAccessor_NextSeqNum_Call{Call: _e.mock.On("NextSeqNum", ctx, sources)}
}

func (_c *ChainAccessor_NextSeqNum_Call) Run(run func(ctx context.Context, sources []ccipocr3.ChainSelector)) *ChainAccessor_NextSeqNum_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]ccipocr3.ChainSelector))
	})
	return _c
}

func (_c *ChainAccessor_NextSeqNum_Call) Return(_a0 map[ccipocr3.ChainSelector]ccipocr3.SeqNum, _a1 error) *ChainAccessor_NextSeqNum_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ChainAccessor_NextSeqNum_Call) RunAndReturn(run func(context.Context, []ccipocr3.ChainSelector) (map[ccipocr3.ChainSelector]ccipocr3.SeqNum, error)) *ChainAccessor_NextSeqNum_Call {
	_c.Call.Return(run)
	return _c
}

// Nonces provides a mock function with given fields: ctx, addresses
func (_m *ChainAccessor) Nonces(ctx context.Context, addresses map[ccipocr3.ChainSelector][]types.Account) (map[ccipocr3.ChainSelector]map[string]uint64, error) {
	ret := _m.Called(ctx, addresses)

	if len(ret) == 0 {
		panic("no return value specified for Nonces")
	}

	var r0 map[ccipocr3.ChainSelector]map[string]uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, map[ccipocr3.ChainSelector][]types.Account) (map[ccipocr3.ChainSelector]map[string]uint64, error)); ok {
		return rf(ctx, addresses)
	}
	if rf, ok := ret.Get(0).(func(context.Context, map[ccipocr3.ChainSelector][]types.Account) map[ccipocr3.ChainSelector]map[string]uint64); ok {
		r0 = rf(ctx, addresses)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[ccipocr3.ChainSelector]map[string]uint64)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, map[ccipocr3.ChainSelector][]types.Account) error); ok {
		r1 = rf(ctx, addresses)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainAccessor_Nonces_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Nonces'
type ChainAccessor_Nonces_Call struct {
	*mock.Call
}

// Nonces is a helper method to define mock.On call
//   - ctx context.Context
//   - addresses map[ccipocr3.ChainSelector][]types.Account
func (_e *ChainAccessor_Expecter) Nonces(ctx interface{}, addresses interface{}) *ChainAccessor_Nonces_Call {
	return &ChainAccessor_Nonces_Call{Call: _e.mock.On("Nonces", ctx, addresses)}
}

func (_c *ChainAccessor_Nonces_Call) Run(run func(ctx context.Context, addresses map[ccipocr3.ChainSelector][]types.Account)) *ChainAccessor_Nonces_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(map[ccipocr3.ChainSelector][]types.Account))
	})
	return _c
}

func (_c *ChainAccessor_Nonces_Call) Return(_a0 map[ccipocr3.ChainSelector]map[string]uint64, _a1 error) *ChainAccessor_Nonces_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ChainAccessor_Nonces_Call) RunAndReturn(run func(context.Context, map[ccipocr3.ChainSelector][]types.Account) (map[ccipocr3.ChainSelector]map[string]uint64, error)) *ChainAccessor_Nonces_Call {
	_c.Call.Return(run)
	return _c
}

// Sync provides a mock function with given fields: ctx, contractName, contractAddress
func (_m *ChainAccessor) Sync(ctx context.Context, contractName string, contractAddress ccipocr3.UnknownAddress) error {
	ret := _m.Called(ctx, contractName, contractAddress)

	if len(ret) == 0 {
		panic("no return value specified for Sync")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ccipocr3.UnknownAddress) error); ok {
		r0 = rf(ctx, contractName, contractAddress)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ChainAccessor_Sync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Sync'
type ChainAccessor_Sync_Call struct {
	*mock.Call
}

// Sync is a helper method to define mock.On call
//   - ctx context.Context
//   - contractName string
//   - contractAddress ccipocr3.UnknownAddress
func (_e *ChainAccessor_Expecter) Sync(ctx interface{}, contractName interface{}, contractAddress interface{}) *ChainAccessor_Sync_Call {
	return &ChainAccessor_Sync_Call{Call: _e.mock.On("Sync", ctx, contractName, contractAddress)}
}

func (_c *ChainAccessor_Sync_Call) Run(run func(ctx context.Context, contractName string, contractAddress ccipocr3.UnknownAddress)) *ChainAccessor_Sync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(ccipocr3.UnknownAddress))
	})
	return _c
}

func (_c *ChainAccessor_Sync_Call) Return(_a0 error) *ChainAccessor_Sync_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ChainAccessor_Sync_Call) RunAndReturn(run func(context.Context, string, ccipocr3.UnknownAddress) error) *ChainAccessor_Sync_Call {
	_c.Call.Return(run)
	return _c
}

// NewChainAccessor creates a new instance of ChainAccessor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewChainAccessor(t interface {
	mock.TestingT
	Cleanup(func())
}) *ChainAccessor {
	mock := &ChainAccessor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
