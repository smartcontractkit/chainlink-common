package bindings_client

import (
	"context"
	"fmt"
	"math/big"

	"github.com/smartcontractkit/chainlink-common/pkg/capabilities/bindings"
	evmcappb "github.com/smartcontractkit/chainlink-common/pkg/capabilities/v2/chain-capabilities/evm/capability"
	evmpb "github.com/smartcontractkit/chainlink-common/pkg/capabilities/v2/chain-capabilities/evm/chain-service"
	chaincommonpb "github.com/smartcontractkit/chainlink-common/pkg/loop/chain-common"
	"github.com/smartcontractkit/chainlink-common/pkg/workflows/sdk/v2"
)

func simpleUX(runtime sdk.DonRuntime, runner sdk.DonRunner) {
	//TODO: https://smartcontract-it.atlassian.net/browse/ARCH-274 Not as part of the DD but we need to define a common SDK for chains and define itâ€™s shape to represent chain selectors / chain families.
	const targetChainID = 100

	//TODO: We need to support to specify the ChainID/ChainSelector.
	//By allowing contract clients to be created using an EVM instance we can share init configuration for the client across all contracts.
	EVM := evmcappb.EVM{ /* ChainID: targetChainIDd*/ }

	dataStorage, _ := bindings.NewDataStorage(bindings.ContractInputs{
		EVM: EVM,
		Address: evmpb.Address{
			Address: []byte("some address"),
		},
		Options: &bindings.ContractInitOptions{ //Optional configuration - We need to set a gas limit to use a WriteReport op.
			GasConfig: &evmpb.GasConfig{
				GasLimit: 100000000,
			},
		},
	})

	// Encode input to use directly with EVM capability
	readDataArgs := bindings.ReadDataInput{
		User: evmpb.Address{Address: []byte("another address")},
		Key:  "some string",
	}

	// #1 - Execute read operation over DataStorage.readData(..)
	dataRead, _ := dataStorage.ReadData(runtime, readDataArgs, nil)
	println("We can directly access the read data " + dataRead)

	userData := bindings.UserData{
		Key:   "key",
		Value: "value",
	}

	// #2 - WriteReport targeting DataStorage IReceiver interface passing a UserDataStruct instance as data
	txHash, err := dataStorage.WriteReportUserData(runtime, userData, nil)
	if err != nil {
		//Error handling scenarios for WriteReport - In case the transaction failed to make it on chain or if the receiver smart contract failed to execute
		switch e := err.(type) {
		case *bindings.ReceiverContractError:
			fmt.Println("TX was successful but receiver contract failed to execute. Tx Hash", e.TxHash)
		case *bindings.TxFatalError:
			//TODO we are missing a meaningful error message
			fmt.Println("TX couldn't be written to the chain at all.")
		// #3 - Support custom errors from receiver smart contract
		case *bindings.DataNotFoundError:
			//TODO this seems possible if we change keystone_forwarder to capture the error from the receiver contract and we put it in a custom event that holds the encoded data of the error and then we
			//get the event.
			fmt.Println("Error raised from receiver smart contract.")
		default:
			fmt.Println("Other error:", err)
		}
	} else {
		//At this point the TX was successful and also the receiver smart contract execution
		println("TX Hash: " + txHash.String())
	}

	// #4 - Support for logs
	// Register tracking of logs DataStored event in DataStorage contract
	dataStorage.RegisterLogTrackingDataStoredLog(runtime, nil)
	//Unregister tracking of logs DataStored event in DataStorage contract
	dataStorage.UnregisterLogTrackingDataStoredLog(runtime)
	//Fetch tracked logs generated by DataStored event in DataStorage contract - Get next 10
	var logs []bindings.ParsedLog[bindings.DataStored]
	logs, _ = dataStorage.QueryTrackedLogsDataStoredLog(runtime, nil)
	println("Logs data are already parsed: key: " + logs[0].LogData.Key + " , value: " + logs[0].LogData.Value + ", but you also have access to the raw log: " + logs[0].RawLog.BlockHash.String())
	//Direct access to fetch logs API
	logs, _ = dataStorage.FilterLogsDataStoredLog(runtime, &bindings.FilterOptions{
		FromBlock: big.NewInt(10),
		ToBlock:   big.NewInt(20),
	})
	// Data types between FilterLogs and QueryTrackedLogs are the same.
	println("Logs data are already parsed: key: " + logs[0].LogData.Key + " , value: " + logs[0].LogData.Value + ", but you also have access to the raw log: " + logs[0].RawLog.BlockHash.String())
	
}

func onLogTrigger(runtime sdk.DonRuntime, trigger *evmpb.FilterLogsReply) {
	return
}

func simpleUXWithOptions(runtime sdk.DonRuntime) {
	const targetChainID = 100

	EVM := evmcappb.EVM{ /* ChainID: targetChainIDd*/ }
	dataStorage, _ := bindings.NewDataStorage(bindings.ContractInputs{
		EVM: EVM,
		Address: evmpb.Address{
			Address: []byte("some address"),
		},
		Options: &bindings.ContractInitOptions{ //Optional configuration - We need to set a gas limit to use a WriteReport op.
			GasConfig: &evmpb.GasConfig{
				GasLimit: 100000000,
			},
		},
	})

	// #1 - Execute read operation over DataStorage.readData(..) - use options to configure from which block to read.
	dataRead, _ := dataStorage.ReadData(runtime, bindings.ReadDataInput{
		User: evmpb.Address{Address: []byte("another address")},
		Key:  "some string",
	}, &bindings.ReadOptions{
		BlockNumber: big.NewInt(10000),
	},
	)
	println("We can directly access the read data " + dataRead)

	// #2 - WriteReport targeting DataStorage IReceiver interface passing a UserDataStruct instance as data - Using options to customize
	// gas limit and what's the expected transaction status when getting a reply from this method
	txHash, _ := dataStorage.WriteReportUserData(runtime, bindings.UserData{
		Key:   "key",
		Value: "value",
	}, &bindings.WriteOptions{
		GasConfig: &evmpb.GasConfig{
			GasLimit: 200000000,
		},
		BlockDepth: bindings.CONFIRMED, //Until confirmed - Default is finalized
	})

	//Register tracking of logs DataStored event in DataStorage contract
	dataStorage.RegisterLogTrackingDataStoredLog(runtime, &bindings.LogTrackingOptions{
		MaxLogsKept:   10000,
		RetentionTime: 6000,
		LogsPerBlock:  10,
		Topic2:        []*evmpb.Hash{&evmpb.Hash{Hash: []byte("some other filter")}},
	})

	// #4 - Support for logs
	//Unregister tracking of logs for DataStored event in DataStorage contract
	dataStorage.UnregisterLogTrackingDataStoredLog(runtime)

	//Fetch tracked logs generated by DataStored event in DataStorage contract - addition options for sorting and limit
	//TODO: How do we get the cursor to use it in future invocations?
	var logs []bindings.ParsedLog[bindings.DataStored]
	logs, _ = dataStorage.QueryTrackedLogsDataStoredLog(runtime, &bindings.QueryTrackedLogsOptions{
		SortBy: []*chaincommonpb.SortBy{
			&chaincommonpb.SortBy{
				SortType: chaincommonpb.SortType_SortTimestamp,
			},
		},
		Limit: &chaincommonpb.Limit{
			Count: 10,
		},
	})
	println("Logs data are already parsed: key: " + logs[0].LogData.Key + " , value: " + logs[0].LogData.Value + ", but you also have access to the raw log: " + logs[0].RawLog.BlockHash.String())

	//Direct access to fetch logs API from RPC for simple use cases that do not require to track logs - adding options for block hash instead of range
	logs, _ = dataStorage.FilterLogsDataStoredLog(runtime, &bindings.FilterOptions{
		BlockHash: txHash,
	})

	// Data types between FilterLogs and QueryTrackedLogs are the same.
	println("Logs data are already parsed: key: " + logs[0].LogData.Key + " , value: " + logs[0].LogData.Value + ", but you also have access to the raw log: " + logs[0].RawLog.BlockHash.String())

}

func advanceUXUsingEVMCapability() {
	const targetChainID = 100

	EVM := evmcappb.EVM{ /* ChainID: targetChainIDd*/ }
	dataStorage, _ := bindings.NewDataStorage(bindings.ContractInputs{
		EVM: EVM,
		Address: evmpb.Address{
			Address: []byte("some address"),
		},
		Options: &bindings.ContractInitOptions{},
	})
	dataStorageCodec, _ := bindings.NewDataStorageCodec()

	evmClient := evmpb.NewEVMClient(nil)

	readDataArgs := bindings.ReadDataInput{
		User: evmpb.Address{Address: []byte("another address")},
		Key:  "some string",
	}

	// #5 - Encode input args for DataStorage.readData(..)
	//TODO do we really need this use case if we can generate calldata for the whole read operation and not just the input args?
	encodedReadDataArgs, _ := dataStorageCodec.EncodeReadDataMethodInputs(readDataArgs)
	print("Read data inputs encoded %s", encodedReadDataArgs)

	// Encode calldata to invoke DataStorage.readData(..) using EVM Capability.
	calldata, _ := dataStorageCodec.EncodeReadDataMethodCall(readDataArgs)
	callContractReply, _ := evmClient.CallContract(context.Background(), &evmpb.CallContractRequest{
		Call: &evmpb.CallMsg{
			Data: &evmpb.ABIPayload{
				Abi: calldata,
			},
			To: &dataStorage.Address,
		},
	})

	// #6 - Decode output of DataStorage.readData(..)
	outputAsString, _ := dataStorageCodec.DecodeReadDataMethodOutput(callContractReply.Data.Abi)
	print("I can use the decoded output directly: " + outputAsString)

	userData := bindings.UserData{
		Key:   "key",
		Value: "value",
	}

	// #7 - Encode DataStorage.UserData struct in case we want to use it for creating a report manually
	encodedUserData, _ := dataStorage.EncodeUserDataStruct(userData)
	commonReport := bindings.GenerateReport(targetChainID, encodedUserData)
	// Manually write report using the capability and the encoded UserData
	evmClient.WriteReport(context.Background(), &evmpb.WriteReportRequest{
		Receiver: &dataStorage.Address,
		Report: &evmpb.SignedReport{
			RawReport:     commonReport.ReportContext,
			ReportContext: commonReport.ReportContext,
			Signatures:    commonReport.Signatures,
			Id:            commonReport.ID,
		},
	})

	// #8 - Get event hash to use in log capabilities
	// Calling the FilterLogs capability to show how to manually decode a DataStorage.DataStored event log
	filterLogsReply, _ := evmClient.FilterLogs(context.Background(), &evmpb.FilterLogsRequest{
		FilterQuery: &evmpb.FilterQuery{
			Addresses: []*evmpb.Address{&evmpb.Address{Address: dataStorage.Address.Address}},
			Topics: []*evmpb.Topics{
				&evmpb.Topics{
					Topic: []*evmpb.Hash{
						&evmpb.Hash{ Hash: dataStorage.DataStoredLogHash() },
					},
				},
			},
		},
	})
	// Decoding manually the DataStorage.DataStored event log for advance use cases
	dataStoredLog, _ := dataStorage.DecodeDataStoredLog(filterLogsReply.Logs[0].Data.Abi)
	println("Log data is key: " + dataStoredLog.Key + ", value: " + dataStoredLog.Value)
}


func InitWorkflow(wcx *sdk.WorkflowContext[*Config]) (sdk.Workflows[*Config], error) {
	EVM := evmcappb.EVM{ /* ChainID: targetChainIDd*/ }
	config := wcx.Config
	workflows := sdk.Workflows[*Config]{
		sdk.On(
			datastorage.NewIReserveManager(datastorage.ContractInputs{EVM: EVM, Address: address, Options: &datastorage.ContractOptions{}}).LogTriggerDataStoredLog(nil),
			onEvmTrigger,
		),
	}
	return workflows, nil
}

func onDataStored(wcx *sdk.WorkflowContext[*Config], runtime sdk.Runtime, log *bindings.ParsedLog[datastorage.DataStored]) (error) {
	wcx.Logger = wcx.Logger.With("trigger", "evm").With("selector", log.ChainSelector)

	wcx.Logger = wcx.Logger.With("Sender", log.LogData.Sender)
	return nil
}

func InitWorkflowWithOptions(wcx *sdk.WorkflowContext[*Config]) (sdk.Workflows[*Config], error) {
	EVM := evmcappb.EVM{ /* ChainID: targetChainIDd*/ }
	config := wcx.Config
	workflows := sdk.Workflows[*Config]{
		sdk.On(
			datastorage.NewIReserveManager(datastorage.ContractInputs{EVM: EVM, Address: address, Options: &datastorage.ContractOptions{}}).LogTriggerDataStoredLog(&datastore.FilterLogTriggerDataStore{
				BlockDepth: bindings.CONFIRMED,
			}),
			onEvmTrigger,
		),
	}
	return workflows, nil
}

func onDataStoredWithOptions(wcx *sdk.WorkflowContext[*Config], runtime sdk.Runtime, log *bindings.ParsedLog[datastorage.DataStored]) (error) {
	wcx.Logger = wcx.Logger.With("trigger", "evm").With("selector", log.ChainSelector)

	wcx.Logger = wcx.Logger.With("Sender", log.LogData.Sender)
	return nil
}
