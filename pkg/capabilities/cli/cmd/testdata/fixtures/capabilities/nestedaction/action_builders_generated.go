// Code generated by github.com/smartcontractkit/chainlink-common/pkg/capabilities/cli, DO NOT EDIT.

package nestedaction

import (
	"github.com/smartcontractkit/chainlink-common/pkg/capabilities"
	"github.com/smartcontractkit/chainlink-common/pkg/workflows/sdk"
)

func (cfg ActionConfig) New(w *sdk.WorkflowSpecFactory, ref string, input ActionInput) ActionOutputsCap {

	def := sdk.StepDefinition{
		ID: "nested-test-action@1.0.0", Ref: ref,
		Inputs: input.ToSteps(),
		Config: map[string]any{
			"details": cfg.Details,
		},
		CapabilityType: capabilities.CapabilityTypeAction,
	}

	step := sdk.Step[ActionOutputs]{Definition: def}
	return ActionOutputsCapFromStep(w, step)
}

type ActionOutputsCap interface {
	sdk.CapDefinition[ActionOutputs]
	Results() ActionOutputsResultsCap
	private()
}

// ActionOutputsCapFromStep should only be called from generated code to assure type safety
func ActionOutputsCapFromStep(w *sdk.WorkflowSpecFactory, step sdk.Step[ActionOutputs]) ActionOutputsCap {
	raw := step.AddTo(w)
	return &actionOutputs{CapDefinition: raw}
}

type actionOutputs struct {
	sdk.CapDefinition[ActionOutputs]
}

func (*actionOutputs) private() {}
func (c *actionOutputs) Results() ActionOutputsResultsCap {
	return &actionOutputsResults{CapDefinition: sdk.AccessField[ActionOutputs, ActionOutputsResults](c.CapDefinition, "results")}
}

func WrapActionOutputs(cap sdk.CapDefinition[ActionOutputs]) ActionOutputsCap {
	if wrapped, ok := cap.(ActionOutputsCap); ok {
		return wrapped
	}

	// if it was created from accessing an array element, it won't already be wrapped, but is safe to access fields from
	return &actionOutputs{CapDefinition: cap}
}

func NewActionOutputsFromFields(
	results ActionOutputsResultsCap) ActionOutputsCap {
	return &simpleActionOutputs{
		CapDefinition: sdk.ComponentCapDefinition[ActionOutputs]{
			"results": results.Ref(),
		},
		results: results,
	}
}

type simpleActionOutputs struct {
	sdk.CapDefinition[ActionOutputs]
	results ActionOutputsResultsCap
}

func (c *simpleActionOutputs) Results() ActionOutputsResultsCap {
	return c.results
}

func (c *simpleActionOutputs) private() {}

type ActionOutputsResultsCap interface {
	sdk.CapDefinition[ActionOutputsResults]
	AdaptedThing() sdk.CapDefinition[string]
	private()
}

// ActionOutputsResultsCapFromStep should only be called from generated code to assure type safety
func ActionOutputsResultsCapFromStep(w *sdk.WorkflowSpecFactory, step sdk.Step[ActionOutputsResults]) ActionOutputsResultsCap {
	raw := step.AddTo(w)
	return &actionOutputsResults{CapDefinition: raw}
}

type actionOutputsResults struct {
	sdk.CapDefinition[ActionOutputsResults]
}

func (*actionOutputsResults) private() {}
func (c *actionOutputsResults) AdaptedThing() sdk.CapDefinition[string] {
	return sdk.AccessField[ActionOutputsResults, string](c.CapDefinition, "adapted_thing")
}

func WrapActionOutputsResults(cap sdk.CapDefinition[ActionOutputsResults]) ActionOutputsResultsCap {
	if wrapped, ok := cap.(ActionOutputsResultsCap); ok {
		return wrapped
	}

	// if it was created from accessing an array element, it won't already be wrapped, but is safe to access fields from
	return &actionOutputsResults{CapDefinition: cap}
}

func NewActionOutputsResultsFromFields(
	adaptedThing sdk.CapDefinition[string]) ActionOutputsResultsCap {
	return &simpleActionOutputsResults{
		CapDefinition: sdk.ComponentCapDefinition[ActionOutputsResults]{
			"adapted_thing": adaptedThing.Ref(),
		},
		adaptedThing: adaptedThing,
	}
}

type simpleActionOutputsResults struct {
	sdk.CapDefinition[ActionOutputsResults]
	adaptedThing sdk.CapDefinition[string]
}

func (c *simpleActionOutputsResults) AdaptedThing() sdk.CapDefinition[string] {
	return c.adaptedThing
}

func (c *simpleActionOutputsResults) private() {}

type ActionInput struct {
	Metadata sdk.CapDefinition[ActionInputsMetadata]
}

func (input ActionInput) ToSteps() sdk.StepInputs {
	return sdk.StepInputs{
		Mapping: map[string]any{
			"metadata": input.Metadata.Ref(),
		},
	}
}
