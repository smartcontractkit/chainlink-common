// Code generated by github.com/smartcontractkit/chainlink-common/pkg/capabilities/v2/protoc, DO NOT EDIT.

package server

import (
	"context"
	"fmt"
	"time"

	"github.com/smartcontractkit/chainlink-common/pkg/capabilities/v2/triggers/cron"
	"google.golang.org/protobuf/types/known/emptypb"

	"github.com/smartcontractkit/chainlink-common/pkg/capabilities"
	caperrors "github.com/smartcontractkit/chainlink-common/pkg/capabilities/errors"
	"github.com/smartcontractkit/chainlink-common/pkg/types/core"
)

// Avoid unused imports if there is configuration type
var _ = emptypb.Empty{}

type CronCapability interface {
	RegisterTrigger(ctx context.Context, triggerID string, metadata capabilities.RequestMetadata, input *cron.Config) (<-chan capabilities.TriggerAndId[*cron.Payload], caperrors.Error)
	UnregisterTrigger(ctx context.Context, triggerID string, metadata capabilities.RequestMetadata, input *cron.Config) caperrors.Error

	RegisterLegacyTrigger(ctx context.Context, triggerID string, metadata capabilities.RequestMetadata, input *cron.Config) (<-chan capabilities.TriggerAndId[*cron.LegacyPayload], caperrors.Error)
	UnregisterLegacyTrigger(ctx context.Context, triggerID string, metadata capabilities.RequestMetadata, input *cron.Config) caperrors.Error

	Start(ctx context.Context) error
	Close() error
	HealthReport() map[string]error
	Name() string
	Description() string
	Ready() error
	Initialise(ctx context.Context, dependencies core.StandardCapabilitiesDependencies) error
}

func NewCronServer(capability CronCapability) *CronServer {
	stopCh := make(chan struct{})
	return &CronServer{
		cronCapability: cronCapability{CronCapability: capability, stopCh: stopCh},
		stopCh:         stopCh,
	}
}

type CronServer struct {
	cronCapability
	capabilityRegistry core.CapabilitiesRegistry
	stopCh             chan struct{}
}

func (c *CronServer) Initialise(ctx context.Context, dependencies core.StandardCapabilitiesDependencies) error {
	if err := c.CronCapability.Initialise(ctx, dependencies); err != nil {
		return fmt.Errorf("error when initializing capability: %w", err)
	}

	c.capabilityRegistry = dependencies.CapabilityRegistry

	if err := dependencies.CapabilityRegistry.Add(ctx, &cronCapability{
		CronCapability: c.CronCapability,
	}); err != nil {
		return fmt.Errorf("error when adding %s to the registry: %w", "cron-trigger@1.0.0", err)
	}

	return nil
}

func (c *CronServer) Close() error {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()

	if c.capabilityRegistry != nil {
		if err := c.capabilityRegistry.Remove(ctx, "cron-trigger@1.0.0"); err != nil {
			return err
		}
	}

	if c.stopCh != nil {
		close(c.stopCh)
	}

	return c.cronCapability.Close()
}

func (c *CronServer) Infos(ctx context.Context) ([]capabilities.CapabilityInfo, error) {
	info, err := c.cronCapability.Info(ctx)
	if err != nil {
		return nil, err
	}
	return []capabilities.CapabilityInfo{info}, nil
}

type cronCapability struct {
	CronCapability
	stopCh chan struct{}
}

func (c *cronCapability) Info(ctx context.Context) (capabilities.CapabilityInfo, error) {
	// Maybe we do need to split it out, even if the user doesn't see it
	return capabilities.NewCapabilityInfo("cron-trigger@1.0.0", capabilities.CapabilityTypeCombined, c.CronCapability.Description())
}

var _ capabilities.ExecutableAndTriggerCapability = (*cronCapability)(nil)

const CronID = "cron-trigger@1.0.0"

func (c *cronCapability) RegisterTrigger(ctx context.Context, request capabilities.TriggerRegistrationRequest) (<-chan capabilities.TriggerResponse, error) {
	switch request.Method {
	case "Trigger":
		input := &cron.Config{}
		return capabilities.RegisterTrigger(ctx, c.stopCh, "cron-trigger@1.0.0", request, input, c.CronCapability.RegisterTrigger)
	case "":
		input := &cron.Config{}
		return capabilities.RegisterTrigger(ctx, c.stopCh, "cron-trigger@1.0.0", request, input, c.CronCapability.RegisterLegacyTrigger)
	default:
		return nil, fmt.Errorf("trigger %s not found", request.Method)
	}
}

func (c *cronCapability) UnregisterTrigger(ctx context.Context, request capabilities.TriggerRegistrationRequest) error {
	switch request.Method {
	case "Trigger":
		input := &cron.Config{}
		_, err := capabilities.FromValueOrAny(request.Config, request.Payload, input)
		if err != nil {
			return err
		}
		return c.CronCapability.UnregisterTrigger(ctx, request.TriggerID, request.Metadata, input)
	case "":
		input := &cron.Config{}
		_, err := capabilities.FromValueOrAny(request.Config, request.Payload, input)
		if err != nil {
			return err
		}
		return c.CronCapability.UnregisterLegacyTrigger(ctx, request.TriggerID, request.Metadata, input)
	default:
		return fmt.Errorf("method %s not found", request.Method)
	}
}

func (c *cronCapability) RegisterToWorkflow(ctx context.Context, request capabilities.RegisterToWorkflowRequest) error {
	return nil
}

func (c *cronCapability) UnregisterFromWorkflow(ctx context.Context, request capabilities.UnregisterFromWorkflowRequest) error {
	return nil
}

func (c *cronCapability) Execute(ctx context.Context, request capabilities.CapabilityRequest) (capabilities.CapabilityResponse, error) {
	return capabilities.CapabilityResponse{}, fmt.Errorf("method %s not found", request.Method)
}
