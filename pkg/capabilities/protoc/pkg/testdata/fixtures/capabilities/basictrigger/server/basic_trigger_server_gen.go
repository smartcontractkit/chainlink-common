// Code generated by github.com/smartcontractkit/chainlink-common/pkg/capabilities/protoc, DO NOT EDIT.

package server

import (
	"context"
	"fmt"

	"github.com/smartcontractkit/chainlink-common/pkg/capabilities"
	"github.com/smartcontractkit/chainlink-common/pkg/capabilities/protoc/pkg/testdata/fixtures/capabilities/basictrigger"
	"github.com/smartcontractkit/chainlink-common/pkg/loop"
	"github.com/smartcontractkit/chainlink-common/pkg/types/core"
)

type BasicTriggerCapability interface {
	Trigger(ctx context.Context, input *basictrigger.Config /* TODO config */) (*basictrigger.Outputs, error)
	Start(ctx context.Context) error
	Close() error
	HealthReport() map[string]error
	Name() string
	Description() string
	Ready() error
	Initialise(ctx context.Context, config string, telemetryService core.TelemetryService, store core.KeyValueStore, errorLog core.ErrorLog, pipelineRunner core.PipelineRunnerService, relayerSet core.RelayerSet, oracleFactory core.OracleFactory) error
}

func NewBasicTriggerServer(capability BasicTriggerCapability) loop.StandardCapabilities {
	return &basicTriggerServer{
		basicTriggerCapability: basicTriggerCapability{BasicTriggerCapability: capability},
	}
}

type basicTriggerServer struct {
	basicTriggerCapability
	capabilityRegistry core.CapabilitiesRegistry
}

func (cs *basicTriggerServer) Initialise(ctx context.Context, config string, telemetryService core.TelemetryService, store core.KeyValueStore, capabilityRegistry core.CapabilitiesRegistry, errorLog core.ErrorLog, pipelineRunner core.PipelineRunnerService, relayerSet core.RelayerSet, oracleFactory core.OracleFactory) error {
	if err := cs.BasicTriggerCapability.Initialise(ctx, config, telemetryService, store, errorLog, pipelineRunner, relayerSet, oracleFactory); err != nil {
		return fmt.Errorf("error when initializing capability: %w", err)
	}

	cs.capabilityRegistry = capabilityRegistry

	if err := capabilityRegistry.Add(ctx, &basicTriggerCapability{
		BasicTriggerCapability: cs.BasicTriggerCapability,
	}); err != nil {
		return fmt.Errorf("error when adding kv store action to the registry: %w", err)
	}

	return nil
}

func (cs *basicTriggerServer) Infos(ctx context.Context) ([]capabilities.CapabilityInfo, error) {
	// TODO if we get rid of targets in favour of actions that return empty proto, do we need Consensus stil?
	info, err := cs.basicTriggerCapability.Info(ctx)
	if err != nil {
		return nil, err
	}
	return []capabilities.CapabilityInfo{info}, nil
}

type basicTriggerCapability struct {
	BasicTriggerCapability
}

var _ capabilities.ActionCapability = (*basicTriggerCapability)(nil)

func (c *basicTriggerCapability) Info(ctx context.Context) (capabilities.CapabilityInfo, error) {
	return capabilities.NewCapabilityInfo("basic-test-trigger@1.0.0", capabilities.CapabilityTypeAction, c.BasicTriggerCapability.Description())
}

func (c *basicTriggerCapability) RegisterToWorkflow(ctx context.Context, request capabilities.RegisterToWorkflowRequest) error {
	//TODO implement me
	panic("implement me")
}

func (c *basicTriggerCapability) UnregisterFromWorkflow(ctx context.Context, request capabilities.UnregisterFromWorkflowRequest) error {
	//TODO implement me
	panic("implement me")
}

func (c *basicTriggerCapability) Execute(ctx context.Context, request capabilities.CapabilityRequest) (capabilities.CapabilityResponse, error) {
	response := capabilities.CapabilityResponse{}
	switch request.Method {
	case "Trigger":
		// TODO config
		config := &basictrigger.Config{}
		input := &basictrigger.Config{}
		migrated, err := capabilities.UnwrapRequest(request, config, input)
		if err != nil {
			return response, fmt.Errorf("error when unwrapping request: %w", err)
		}

		output, err := c.Trigger(ctx, input /*TODO config */)
		if err != nil {
			return response, err
		}

		if err = capabilities.SetResponse(response, migrated, output); err != nil {
			return response, fmt.Errorf("error when setting response: %w", err)
		}

		return response, nil
	default:
		return response, fmt.Errorf("method %s not found", request.Method)
	}
}
