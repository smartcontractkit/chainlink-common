// Code generated by github.com/smartcontractkit/chainlink-common/pkg/capabilities/protoc, DO NOT EDIT.

package server

import (
	"context"
	"fmt"
	"time"

	"google.golang.org/protobuf/types/known/emptypb"

	"github.com/smartcontractkit/chainlink-common/pkg/capabilities/stubs/don/crosschain"
	"github.com/smartcontractkit/chainlink-common/pkg/capabilities/stubs/don/evm"
	"github.com/smartcontractkit/chainlink-common/pkg/loop"

	"github.com/smartcontractkit/chainlink-common/pkg/capabilities"
	"github.com/smartcontractkit/chainlink-common/pkg/types/core"
)

type ClientCapability interface {
	GetTxResult(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.TxID /* TODO  config evm.TxID*/) (*crosschain.TxResult, error)
	RegisterGetTxResult(ctx context.Context, metadata capabilities.RegistrationMetadata /* TODO config */) error
	UnregisterGetTxResult(ctx context.Context, metadata capabilities.RegistrationMetadata /* TODO config */) error

	ReadMethod(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.ReadMethodRequest /* TODO  config evm.ReadMethodRequest*/) (*crosschain.ByteArray, error)
	RegisterReadMethod(ctx context.Context, metadata capabilities.RegistrationMetadata /* TODO config */) error
	UnregisterReadMethod(ctx context.Context, metadata capabilities.RegistrationMetadata /* TODO config */) error

	QueryLogs(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.QueryLogsRequest /* TODO  config evm.QueryLogsRequest*/) (*evm.LogList, error)
	RegisterQueryLogs(ctx context.Context, metadata capabilities.RegistrationMetadata /* TODO config */) error
	UnregisterQueryLogs(ctx context.Context, metadata capabilities.RegistrationMetadata /* TODO config */) error

	RegisterLogTracking(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.RegisterLogTrackingRequest /* TODO  config evm.RegisterLogTrackingRequest*/) (*emptypb.Empty, error)
	RegisterRegisterLogTracking(ctx context.Context, metadata capabilities.RegistrationMetadata /* TODO config */) error
	UnregisterRegisterLogTracking(ctx context.Context, metadata capabilities.RegistrationMetadata /* TODO config */) error

	UnregisterLogTracking(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.UnregisterLogTrackingRequest /* TODO  config evm.UnregisterLogTrackingRequest*/) (*emptypb.Empty, error)
	RegisterUnregisterLogTracking(ctx context.Context, metadata capabilities.RegistrationMetadata /* TODO config */) error
	UnregisterUnregisterLogTracking(ctx context.Context, metadata capabilities.RegistrationMetadata /* TODO config */) error

	SubmitTransaction(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.SubmitTransactionRequest /* TODO  config evm.SubmitTransactionRequest*/) (*evm.TxID, error)
	RegisterSubmitTransaction(ctx context.Context, metadata capabilities.RegistrationMetadata /* TODO config */) error
	UnregisterSubmitTransaction(ctx context.Context, metadata capabilities.RegistrationMetadata /* TODO config */) error

	WriteAsReport(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.WriteAsReportRequest /* TODO  config evm.WriteAsReportRequest*/) (*evm.WriteAsReportResponse, error)
	RegisterWriteAsReport(ctx context.Context, metadata capabilities.RegistrationMetadata /* TODO config */) error
	UnregisterWriteAsReport(ctx context.Context, metadata capabilities.RegistrationMetadata /* TODO config */) error

	RegisterLogTrigger(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.LogTriggerRequest) (<-chan capabilities.TriggerAndId[*evm.Log], error)
	UnregisterLogTrigger(ctx context.Context, metadata capabilities.RequestMetadata, input *evm.LogTriggerRequest) error

	RegisterOnFinalityViolation(ctx context.Context, metadata capabilities.RequestMetadata, input *emptypb.Empty) (<-chan capabilities.TriggerAndId[*crosschain.BlockRange], error)
	UnregisterOnFinalityViolation(ctx context.Context, metadata capabilities.RequestMetadata, input *emptypb.Empty) error
	Start(ctx context.Context) error
	Close() error
	HealthReport() map[string]error
	Name() string
	Description() string
	Ready() error
	Initialise(ctx context.Context, config string, telemetryService core.TelemetryService, store core.KeyValueStore, errorLog core.ErrorLog, pipelineRunner core.PipelineRunnerService, relayerSet core.RelayerSet, oracleFactory core.OracleFactory) error
}

func NewClientServer(capability ClientCapability) loop.StandardCapabilities {
	return &clientServer{
		clientCapability: clientCapability{ClientCapability: capability},
	}
}

type clientServer struct {
	clientCapability
	capabilityRegistry core.CapabilitiesRegistry
}

func (cs *clientServer) Initialise(ctx context.Context, config string, telemetryService core.TelemetryService, store core.KeyValueStore, capabilityRegistry core.CapabilitiesRegistry, errorLog core.ErrorLog, pipelineRunner core.PipelineRunnerService, relayerSet core.RelayerSet, oracleFactory core.OracleFactory) error {
	if err := cs.ClientCapability.Initialise(ctx, config, telemetryService, store, errorLog, pipelineRunner, relayerSet, oracleFactory); err != nil {
		return fmt.Errorf("error when initializing capability: %w", err)
	}

	cs.capabilityRegistry = capabilityRegistry

	if err := capabilityRegistry.Add(ctx, &clientCapability{
		ClientCapability: cs.ClientCapability,
	}); err != nil {
		return fmt.Errorf("error when adding kv store action to the registry: %w", err)
	}

	return nil
}

func (cs *clientServer) Close() error {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()
	if err := cs.capabilityRegistry.Remove(ctx, "evm@1.0.0"); err != nil {
		return err
	}

	return cs.clientCapability.Close()
}

func (cs *clientServer) Infos(ctx context.Context) ([]capabilities.CapabilityInfo, error) {
	// TODO if we get rid of targets in favour of actions that return empty proto, do we need Consensus stil?
	info, err := cs.clientCapability.Info(ctx)
	if err != nil {
		return nil, err
	}
	return []capabilities.CapabilityInfo{info}, nil
}

type clientCapability struct {
	ClientCapability
}

func (c *clientCapability) Info(ctx context.Context) (capabilities.CapabilityInfo, error) {
	// TODO this is problematic right not because we can do both...?
	// Maybe we do need to split it out, even if the user doesn't see it
	return capabilities.NewCapabilityInfo("evm@1.0.0", capabilities.CapabilityTypeAction, c.ClientCapability.Description())
}

var _ capabilities.TriggerCapability = (*clientCapability)(nil)

func (c *clientCapability) RegisterTrigger(ctx context.Context, request capabilities.TriggerRegistrationRequest) (<-chan capabilities.TriggerResponse, error) {
	switch request.Method {
	case "LogTrigger":
		input := &evm.LogTriggerRequest{}
		return capabilities.RegisterTrigger(ctx, "evm@1.0.0", request, input, c.ClientCapability.RegisterLogTrigger)
	case "OnFinalityViolation":
		input := &emptypb.Empty{}
		return capabilities.RegisterTrigger(ctx, "evm@1.0.0", request, input, c.ClientCapability.RegisterOnFinalityViolation)
	default:
		return nil, fmt.Errorf("method %s not found", request.Method)
	}

}

func (c *clientCapability) UnregisterTrigger(ctx context.Context, request capabilities.TriggerRegistrationRequest) error {
	switch request.Method {
	case "LogTrigger":
		input := &evm.LogTriggerRequest{}
		_, err := capabilities.FromValueOrAny(request.Config, request.Request, input)
		if err != nil {
			return err
		}
		return c.ClientCapability.UnregisterLogTrigger(ctx, request.Metadata, input)
	case "OnFinalityViolation":
		input := &emptypb.Empty{}
		_, err := capabilities.FromValueOrAny(request.Config, request.Request, input)
		if err != nil {
			return err
		}
		return c.ClientCapability.UnregisterOnFinalityViolation(ctx, request.Metadata, input)
	default:
		return fmt.Errorf("method %s not found", request.Method)
	}
}

var _ capabilities.ActionCapability = (*clientCapability)(nil)

func (c *clientCapability) RegisterToWorkflow(ctx context.Context, request capabilities.RegisterToWorkflowRequest) error {
	//TODO implement me
	panic("implement me")
}

func (c *clientCapability) UnregisterFromWorkflow(ctx context.Context, request capabilities.UnregisterFromWorkflowRequest) error {
	//TODO implement me
	panic("implement me")
}

func (c *clientCapability) Execute(ctx context.Context, request capabilities.CapabilityRequest) (capabilities.CapabilityResponse, error) {
	response := capabilities.CapabilityResponse{}
	switch request.Method {
	case "GetTxResult":
		input := &evm.TxID{}
		// TODO config
		return capabilities.Execute(ctx, request, input, c.ClientCapability.GetTxResult)
	case "ReadMethod":
		input := &evm.ReadMethodRequest{}
		// TODO config
		return capabilities.Execute(ctx, request, input, c.ClientCapability.ReadMethod)
	case "QueryLogs":
		input := &evm.QueryLogsRequest{}
		// TODO config
		return capabilities.Execute(ctx, request, input, c.ClientCapability.QueryLogs)
	case "RegisterLogTracking":
		input := &evm.RegisterLogTrackingRequest{}
		// TODO config
		return capabilities.Execute(ctx, request, input, c.ClientCapability.RegisterLogTracking)
	case "UnregisterLogTracking":
		input := &evm.UnregisterLogTrackingRequest{}
		// TODO config
		return capabilities.Execute(ctx, request, input, c.ClientCapability.UnregisterLogTracking)
	case "SubmitTransaction":
		input := &evm.SubmitTransactionRequest{}
		// TODO config
		return capabilities.Execute(ctx, request, input, c.ClientCapability.SubmitTransaction)
	case "WriteAsReport":
		input := &evm.WriteAsReportRequest{}
		// TODO config
		return capabilities.Execute(ctx, request, input, c.ClientCapability.WriteAsReport)
	default:
		return response, fmt.Errorf("method %s not found", request.Method)
	}
}
