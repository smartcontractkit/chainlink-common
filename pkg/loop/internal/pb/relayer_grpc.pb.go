// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.1
// source: relayer.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	PluginRelayer_NewRelayer_FullMethodName = "/loop.PluginRelayer/NewRelayer"
)

// PluginRelayerClient is the client API for PluginRelayer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PluginRelayerClient interface {
	NewRelayer(ctx context.Context, in *NewRelayerRequest, opts ...grpc.CallOption) (*NewRelayerReply, error)
}

type pluginRelayerClient struct {
	cc grpc.ClientConnInterface
}

func NewPluginRelayerClient(cc grpc.ClientConnInterface) PluginRelayerClient {
	return &pluginRelayerClient{cc}
}

func (c *pluginRelayerClient) NewRelayer(ctx context.Context, in *NewRelayerRequest, opts ...grpc.CallOption) (*NewRelayerReply, error) {
	out := new(NewRelayerReply)
	err := c.cc.Invoke(ctx, PluginRelayer_NewRelayer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PluginRelayerServer is the server API for PluginRelayer service.
// All implementations must embed UnimplementedPluginRelayerServer
// for forward compatibility
type PluginRelayerServer interface {
	NewRelayer(context.Context, *NewRelayerRequest) (*NewRelayerReply, error)
	mustEmbedUnimplementedPluginRelayerServer()
}

// UnimplementedPluginRelayerServer must be embedded to have forward compatible implementations.
type UnimplementedPluginRelayerServer struct {
}

func (UnimplementedPluginRelayerServer) NewRelayer(context.Context, *NewRelayerRequest) (*NewRelayerReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewRelayer not implemented")
}
func (UnimplementedPluginRelayerServer) mustEmbedUnimplementedPluginRelayerServer() {}

// UnsafePluginRelayerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PluginRelayerServer will
// result in compilation errors.
type UnsafePluginRelayerServer interface {
	mustEmbedUnimplementedPluginRelayerServer()
}

func RegisterPluginRelayerServer(s grpc.ServiceRegistrar, srv PluginRelayerServer) {
	s.RegisterService(&PluginRelayer_ServiceDesc, srv)
}

func _PluginRelayer_NewRelayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewRelayerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginRelayerServer).NewRelayer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginRelayer_NewRelayer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginRelayerServer).NewRelayer(ctx, req.(*NewRelayerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PluginRelayer_ServiceDesc is the grpc.ServiceDesc for PluginRelayer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PluginRelayer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.PluginRelayer",
	HandlerType: (*PluginRelayerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewRelayer",
			Handler:    _PluginRelayer_NewRelayer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "relayer.proto",
}

const (
	Keystore_Accounts_FullMethodName = "/loop.Keystore/Accounts"
	Keystore_Sign_FullMethodName     = "/loop.Keystore/Sign"
)

// KeystoreClient is the client API for Keystore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KeystoreClient interface {
	Accounts(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AccountsReply, error)
	Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignReply, error)
}

type keystoreClient struct {
	cc grpc.ClientConnInterface
}

func NewKeystoreClient(cc grpc.ClientConnInterface) KeystoreClient {
	return &keystoreClient{cc}
}

func (c *keystoreClient) Accounts(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AccountsReply, error) {
	out := new(AccountsReply)
	err := c.cc.Invoke(ctx, Keystore_Accounts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreClient) Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignReply, error) {
	out := new(SignReply)
	err := c.cc.Invoke(ctx, Keystore_Sign_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KeystoreServer is the server API for Keystore service.
// All implementations must embed UnimplementedKeystoreServer
// for forward compatibility
type KeystoreServer interface {
	Accounts(context.Context, *emptypb.Empty) (*AccountsReply, error)
	Sign(context.Context, *SignRequest) (*SignReply, error)
	mustEmbedUnimplementedKeystoreServer()
}

// UnimplementedKeystoreServer must be embedded to have forward compatible implementations.
type UnimplementedKeystoreServer struct {
}

func (UnimplementedKeystoreServer) Accounts(context.Context, *emptypb.Empty) (*AccountsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Accounts not implemented")
}
func (UnimplementedKeystoreServer) Sign(context.Context, *SignRequest) (*SignReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sign not implemented")
}
func (UnimplementedKeystoreServer) mustEmbedUnimplementedKeystoreServer() {}

// UnsafeKeystoreServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KeystoreServer will
// result in compilation errors.
type UnsafeKeystoreServer interface {
	mustEmbedUnimplementedKeystoreServer()
}

func RegisterKeystoreServer(s grpc.ServiceRegistrar, srv KeystoreServer) {
	s.RegisterService(&Keystore_ServiceDesc, srv)
}

func _Keystore_Accounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServer).Accounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Keystore_Accounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServer).Accounts(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keystore_Sign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServer).Sign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Keystore_Sign_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServer).Sign(ctx, req.(*SignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Keystore_ServiceDesc is the grpc.ServiceDesc for Keystore service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Keystore_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.Keystore",
	HandlerType: (*KeystoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Accounts",
			Handler:    _Keystore_Accounts_Handler,
		},
		{
			MethodName: "Sign",
			Handler:    _Keystore_Sign_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "relayer.proto",
}

const (
	Relayer_NewContractWriter_FullMethodName = "/loop.Relayer/NewContractWriter"
	Relayer_NewContractReader_FullMethodName = "/loop.Relayer/NewContractReader"
	Relayer_NewConfigProvider_FullMethodName = "/loop.Relayer/NewConfigProvider"
	Relayer_NewPluginProvider_FullMethodName = "/loop.Relayer/NewPluginProvider"
	Relayer_LatestHead_FullMethodName        = "/loop.Relayer/LatestHead"
	Relayer_GetChainStatus_FullMethodName    = "/loop.Relayer/GetChainStatus"
	Relayer_ListNodeStatuses_FullMethodName  = "/loop.Relayer/ListNodeStatuses"
	Relayer_Transact_FullMethodName          = "/loop.Relayer/Transact"
)

// RelayerClient is the client API for Relayer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RelayerClient interface {
	NewContractWriter(ctx context.Context, in *NewContractWriterRequest, opts ...grpc.CallOption) (*NewContractWriterReply, error)
	NewContractReader(ctx context.Context, in *NewContractReaderRequest, opts ...grpc.CallOption) (*NewContractReaderReply, error)
	NewConfigProvider(ctx context.Context, in *NewConfigProviderRequest, opts ...grpc.CallOption) (*NewConfigProviderReply, error)
	NewPluginProvider(ctx context.Context, in *NewPluginProviderRequest, opts ...grpc.CallOption) (*NewPluginProviderReply, error)
	LatestHead(ctx context.Context, in *LatestHeadRequest, opts ...grpc.CallOption) (*LatestHeadReply, error)
	GetChainStatus(ctx context.Context, in *GetChainStatusRequest, opts ...grpc.CallOption) (*GetChainStatusReply, error)
	ListNodeStatuses(ctx context.Context, in *ListNodeStatusesRequest, opts ...grpc.CallOption) (*ListNodeStatusesReply, error)
	Transact(ctx context.Context, in *TransactionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type relayerClient struct {
	cc grpc.ClientConnInterface
}

func NewRelayerClient(cc grpc.ClientConnInterface) RelayerClient {
	return &relayerClient{cc}
}

func (c *relayerClient) NewContractWriter(ctx context.Context, in *NewContractWriterRequest, opts ...grpc.CallOption) (*NewContractWriterReply, error) {
	out := new(NewContractWriterReply)
	err := c.cc.Invoke(ctx, Relayer_NewContractWriter_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerClient) NewContractReader(ctx context.Context, in *NewContractReaderRequest, opts ...grpc.CallOption) (*NewContractReaderReply, error) {
	out := new(NewContractReaderReply)
	err := c.cc.Invoke(ctx, Relayer_NewContractReader_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerClient) NewConfigProvider(ctx context.Context, in *NewConfigProviderRequest, opts ...grpc.CallOption) (*NewConfigProviderReply, error) {
	out := new(NewConfigProviderReply)
	err := c.cc.Invoke(ctx, Relayer_NewConfigProvider_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerClient) NewPluginProvider(ctx context.Context, in *NewPluginProviderRequest, opts ...grpc.CallOption) (*NewPluginProviderReply, error) {
	out := new(NewPluginProviderReply)
	err := c.cc.Invoke(ctx, Relayer_NewPluginProvider_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerClient) LatestHead(ctx context.Context, in *LatestHeadRequest, opts ...grpc.CallOption) (*LatestHeadReply, error) {
	out := new(LatestHeadReply)
	err := c.cc.Invoke(ctx, Relayer_LatestHead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerClient) GetChainStatus(ctx context.Context, in *GetChainStatusRequest, opts ...grpc.CallOption) (*GetChainStatusReply, error) {
	out := new(GetChainStatusReply)
	err := c.cc.Invoke(ctx, Relayer_GetChainStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerClient) ListNodeStatuses(ctx context.Context, in *ListNodeStatusesRequest, opts ...grpc.CallOption) (*ListNodeStatusesReply, error) {
	out := new(ListNodeStatusesReply)
	err := c.cc.Invoke(ctx, Relayer_ListNodeStatuses_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerClient) Transact(ctx context.Context, in *TransactionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Relayer_Transact_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RelayerServer is the server API for Relayer service.
// All implementations must embed UnimplementedRelayerServer
// for forward compatibility
type RelayerServer interface {
	NewContractWriter(context.Context, *NewContractWriterRequest) (*NewContractWriterReply, error)
	NewContractReader(context.Context, *NewContractReaderRequest) (*NewContractReaderReply, error)
	NewConfigProvider(context.Context, *NewConfigProviderRequest) (*NewConfigProviderReply, error)
	NewPluginProvider(context.Context, *NewPluginProviderRequest) (*NewPluginProviderReply, error)
	LatestHead(context.Context, *LatestHeadRequest) (*LatestHeadReply, error)
	GetChainStatus(context.Context, *GetChainStatusRequest) (*GetChainStatusReply, error)
	ListNodeStatuses(context.Context, *ListNodeStatusesRequest) (*ListNodeStatusesReply, error)
	Transact(context.Context, *TransactionRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedRelayerServer()
}

// UnimplementedRelayerServer must be embedded to have forward compatible implementations.
type UnimplementedRelayerServer struct {
}

func (UnimplementedRelayerServer) NewContractWriter(context.Context, *NewContractWriterRequest) (*NewContractWriterReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewContractWriter not implemented")
}
func (UnimplementedRelayerServer) NewContractReader(context.Context, *NewContractReaderRequest) (*NewContractReaderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewContractReader not implemented")
}
func (UnimplementedRelayerServer) NewConfigProvider(context.Context, *NewConfigProviderRequest) (*NewConfigProviderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewConfigProvider not implemented")
}
func (UnimplementedRelayerServer) NewPluginProvider(context.Context, *NewPluginProviderRequest) (*NewPluginProviderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewPluginProvider not implemented")
}
func (UnimplementedRelayerServer) LatestHead(context.Context, *LatestHeadRequest) (*LatestHeadReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LatestHead not implemented")
}
func (UnimplementedRelayerServer) GetChainStatus(context.Context, *GetChainStatusRequest) (*GetChainStatusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChainStatus not implemented")
}
func (UnimplementedRelayerServer) ListNodeStatuses(context.Context, *ListNodeStatusesRequest) (*ListNodeStatusesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNodeStatuses not implemented")
}
func (UnimplementedRelayerServer) Transact(context.Context, *TransactionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Transact not implemented")
}
func (UnimplementedRelayerServer) mustEmbedUnimplementedRelayerServer() {}

// UnsafeRelayerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RelayerServer will
// result in compilation errors.
type UnsafeRelayerServer interface {
	mustEmbedUnimplementedRelayerServer()
}

func RegisterRelayerServer(s grpc.ServiceRegistrar, srv RelayerServer) {
	s.RegisterService(&Relayer_ServiceDesc, srv)
}

func _Relayer_NewContractWriter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewContractWriterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerServer).NewContractWriter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Relayer_NewContractWriter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerServer).NewContractWriter(ctx, req.(*NewContractWriterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Relayer_NewContractReader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewContractReaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerServer).NewContractReader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Relayer_NewContractReader_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerServer).NewContractReader(ctx, req.(*NewContractReaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Relayer_NewConfigProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewConfigProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerServer).NewConfigProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Relayer_NewConfigProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerServer).NewConfigProvider(ctx, req.(*NewConfigProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Relayer_NewPluginProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewPluginProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerServer).NewPluginProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Relayer_NewPluginProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerServer).NewPluginProvider(ctx, req.(*NewPluginProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Relayer_LatestHead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LatestHeadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerServer).LatestHead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Relayer_LatestHead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerServer).LatestHead(ctx, req.(*LatestHeadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Relayer_GetChainStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChainStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerServer).GetChainStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Relayer_GetChainStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerServer).GetChainStatus(ctx, req.(*GetChainStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Relayer_ListNodeStatuses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNodeStatusesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerServer).ListNodeStatuses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Relayer_ListNodeStatuses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerServer).ListNodeStatuses(ctx, req.(*ListNodeStatusesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Relayer_Transact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerServer).Transact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Relayer_Transact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerServer).Transact(ctx, req.(*TransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Relayer_ServiceDesc is the grpc.ServiceDesc for Relayer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Relayer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.Relayer",
	HandlerType: (*RelayerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewContractWriter",
			Handler:    _Relayer_NewContractWriter_Handler,
		},
		{
			MethodName: "NewContractReader",
			Handler:    _Relayer_NewContractReader_Handler,
		},
		{
			MethodName: "NewConfigProvider",
			Handler:    _Relayer_NewConfigProvider_Handler,
		},
		{
			MethodName: "NewPluginProvider",
			Handler:    _Relayer_NewPluginProvider_Handler,
		},
		{
			MethodName: "LatestHead",
			Handler:    _Relayer_LatestHead_Handler,
		},
		{
			MethodName: "GetChainStatus",
			Handler:    _Relayer_GetChainStatus_Handler,
		},
		{
			MethodName: "ListNodeStatuses",
			Handler:    _Relayer_ListNodeStatuses_Handler,
		},
		{
			MethodName: "Transact",
			Handler:    _Relayer_Transact_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "relayer.proto",
}

const (
	OffchainConfigDigester_ConfigDigest_FullMethodName       = "/loop.OffchainConfigDigester/ConfigDigest"
	OffchainConfigDigester_ConfigDigestPrefix_FullMethodName = "/loop.OffchainConfigDigester/ConfigDigestPrefix"
)

// OffchainConfigDigesterClient is the client API for OffchainConfigDigester service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OffchainConfigDigesterClient interface {
	ConfigDigest(ctx context.Context, in *ConfigDigestRequest, opts ...grpc.CallOption) (*ConfigDigestReply, error)
	ConfigDigestPrefix(ctx context.Context, in *ConfigDigestPrefixRequest, opts ...grpc.CallOption) (*ConfigDigestPrefixReply, error)
}

type offchainConfigDigesterClient struct {
	cc grpc.ClientConnInterface
}

func NewOffchainConfigDigesterClient(cc grpc.ClientConnInterface) OffchainConfigDigesterClient {
	return &offchainConfigDigesterClient{cc}
}

func (c *offchainConfigDigesterClient) ConfigDigest(ctx context.Context, in *ConfigDigestRequest, opts ...grpc.CallOption) (*ConfigDigestReply, error) {
	out := new(ConfigDigestReply)
	err := c.cc.Invoke(ctx, OffchainConfigDigester_ConfigDigest_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offchainConfigDigesterClient) ConfigDigestPrefix(ctx context.Context, in *ConfigDigestPrefixRequest, opts ...grpc.CallOption) (*ConfigDigestPrefixReply, error) {
	out := new(ConfigDigestPrefixReply)
	err := c.cc.Invoke(ctx, OffchainConfigDigester_ConfigDigestPrefix_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OffchainConfigDigesterServer is the server API for OffchainConfigDigester service.
// All implementations must embed UnimplementedOffchainConfigDigesterServer
// for forward compatibility
type OffchainConfigDigesterServer interface {
	ConfigDigest(context.Context, *ConfigDigestRequest) (*ConfigDigestReply, error)
	ConfigDigestPrefix(context.Context, *ConfigDigestPrefixRequest) (*ConfigDigestPrefixReply, error)
	mustEmbedUnimplementedOffchainConfigDigesterServer()
}

// UnimplementedOffchainConfigDigesterServer must be embedded to have forward compatible implementations.
type UnimplementedOffchainConfigDigesterServer struct {
}

func (UnimplementedOffchainConfigDigesterServer) ConfigDigest(context.Context, *ConfigDigestRequest) (*ConfigDigestReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigDigest not implemented")
}
func (UnimplementedOffchainConfigDigesterServer) ConfigDigestPrefix(context.Context, *ConfigDigestPrefixRequest) (*ConfigDigestPrefixReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigDigestPrefix not implemented")
}
func (UnimplementedOffchainConfigDigesterServer) mustEmbedUnimplementedOffchainConfigDigesterServer() {
}

// UnsafeOffchainConfigDigesterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OffchainConfigDigesterServer will
// result in compilation errors.
type UnsafeOffchainConfigDigesterServer interface {
	mustEmbedUnimplementedOffchainConfigDigesterServer()
}

func RegisterOffchainConfigDigesterServer(s grpc.ServiceRegistrar, srv OffchainConfigDigesterServer) {
	s.RegisterService(&OffchainConfigDigester_ServiceDesc, srv)
}

func _OffchainConfigDigester_ConfigDigest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigDigestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffchainConfigDigesterServer).ConfigDigest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OffchainConfigDigester_ConfigDigest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffchainConfigDigesterServer).ConfigDigest(ctx, req.(*ConfigDigestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OffchainConfigDigester_ConfigDigestPrefix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigDigestPrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffchainConfigDigesterServer).ConfigDigestPrefix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OffchainConfigDigester_ConfigDigestPrefix_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffchainConfigDigesterServer).ConfigDigestPrefix(ctx, req.(*ConfigDigestPrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OffchainConfigDigester_ServiceDesc is the grpc.ServiceDesc for OffchainConfigDigester service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OffchainConfigDigester_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.OffchainConfigDigester",
	HandlerType: (*OffchainConfigDigesterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigDigest",
			Handler:    _OffchainConfigDigester_ConfigDigest_Handler,
		},
		{
			MethodName: "ConfigDigestPrefix",
			Handler:    _OffchainConfigDigester_ConfigDigestPrefix_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "relayer.proto",
}

const (
	ContractConfigTracker_LatestConfigDetails_FullMethodName = "/loop.ContractConfigTracker/LatestConfigDetails"
	ContractConfigTracker_LatestConfig_FullMethodName        = "/loop.ContractConfigTracker/LatestConfig"
	ContractConfigTracker_LatestBlockHeight_FullMethodName   = "/loop.ContractConfigTracker/LatestBlockHeight"
)

// ContractConfigTrackerClient is the client API for ContractConfigTracker service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ContractConfigTrackerClient interface {
	LatestConfigDetails(ctx context.Context, in *LatestConfigDetailsRequest, opts ...grpc.CallOption) (*LatestConfigDetailsReply, error)
	LatestConfig(ctx context.Context, in *LatestConfigRequest, opts ...grpc.CallOption) (*LatestConfigReply, error)
	LatestBlockHeight(ctx context.Context, in *LatestBlockHeightRequest, opts ...grpc.CallOption) (*LatestBlockHeightReply, error)
}

type contractConfigTrackerClient struct {
	cc grpc.ClientConnInterface
}

func NewContractConfigTrackerClient(cc grpc.ClientConnInterface) ContractConfigTrackerClient {
	return &contractConfigTrackerClient{cc}
}

func (c *contractConfigTrackerClient) LatestConfigDetails(ctx context.Context, in *LatestConfigDetailsRequest, opts ...grpc.CallOption) (*LatestConfigDetailsReply, error) {
	out := new(LatestConfigDetailsReply)
	err := c.cc.Invoke(ctx, ContractConfigTracker_LatestConfigDetails_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractConfigTrackerClient) LatestConfig(ctx context.Context, in *LatestConfigRequest, opts ...grpc.CallOption) (*LatestConfigReply, error) {
	out := new(LatestConfigReply)
	err := c.cc.Invoke(ctx, ContractConfigTracker_LatestConfig_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractConfigTrackerClient) LatestBlockHeight(ctx context.Context, in *LatestBlockHeightRequest, opts ...grpc.CallOption) (*LatestBlockHeightReply, error) {
	out := new(LatestBlockHeightReply)
	err := c.cc.Invoke(ctx, ContractConfigTracker_LatestBlockHeight_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ContractConfigTrackerServer is the server API for ContractConfigTracker service.
// All implementations must embed UnimplementedContractConfigTrackerServer
// for forward compatibility
type ContractConfigTrackerServer interface {
	LatestConfigDetails(context.Context, *LatestConfigDetailsRequest) (*LatestConfigDetailsReply, error)
	LatestConfig(context.Context, *LatestConfigRequest) (*LatestConfigReply, error)
	LatestBlockHeight(context.Context, *LatestBlockHeightRequest) (*LatestBlockHeightReply, error)
	mustEmbedUnimplementedContractConfigTrackerServer()
}

// UnimplementedContractConfigTrackerServer must be embedded to have forward compatible implementations.
type UnimplementedContractConfigTrackerServer struct {
}

func (UnimplementedContractConfigTrackerServer) LatestConfigDetails(context.Context, *LatestConfigDetailsRequest) (*LatestConfigDetailsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LatestConfigDetails not implemented")
}
func (UnimplementedContractConfigTrackerServer) LatestConfig(context.Context, *LatestConfigRequest) (*LatestConfigReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LatestConfig not implemented")
}
func (UnimplementedContractConfigTrackerServer) LatestBlockHeight(context.Context, *LatestBlockHeightRequest) (*LatestBlockHeightReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LatestBlockHeight not implemented")
}
func (UnimplementedContractConfigTrackerServer) mustEmbedUnimplementedContractConfigTrackerServer() {}

// UnsafeContractConfigTrackerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ContractConfigTrackerServer will
// result in compilation errors.
type UnsafeContractConfigTrackerServer interface {
	mustEmbedUnimplementedContractConfigTrackerServer()
}

func RegisterContractConfigTrackerServer(s grpc.ServiceRegistrar, srv ContractConfigTrackerServer) {
	s.RegisterService(&ContractConfigTracker_ServiceDesc, srv)
}

func _ContractConfigTracker_LatestConfigDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LatestConfigDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractConfigTrackerServer).LatestConfigDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractConfigTracker_LatestConfigDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractConfigTrackerServer).LatestConfigDetails(ctx, req.(*LatestConfigDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractConfigTracker_LatestConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LatestConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractConfigTrackerServer).LatestConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractConfigTracker_LatestConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractConfigTrackerServer).LatestConfig(ctx, req.(*LatestConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractConfigTracker_LatestBlockHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LatestBlockHeightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractConfigTrackerServer).LatestBlockHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractConfigTracker_LatestBlockHeight_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractConfigTrackerServer).LatestBlockHeight(ctx, req.(*LatestBlockHeightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ContractConfigTracker_ServiceDesc is the grpc.ServiceDesc for ContractConfigTracker service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ContractConfigTracker_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.ContractConfigTracker",
	HandlerType: (*ContractConfigTrackerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LatestConfigDetails",
			Handler:    _ContractConfigTracker_LatestConfigDetails_Handler,
		},
		{
			MethodName: "LatestConfig",
			Handler:    _ContractConfigTracker_LatestConfig_Handler,
		},
		{
			MethodName: "LatestBlockHeight",
			Handler:    _ContractConfigTracker_LatestBlockHeight_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "relayer.proto",
}

const (
	ContractTransmitter_Transmit_FullMethodName                   = "/loop.ContractTransmitter/Transmit"
	ContractTransmitter_LatestConfigDigestAndEpoch_FullMethodName = "/loop.ContractTransmitter/LatestConfigDigestAndEpoch"
	ContractTransmitter_FromAccount_FullMethodName                = "/loop.ContractTransmitter/FromAccount"
)

// ContractTransmitterClient is the client API for ContractTransmitter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ContractTransmitterClient interface {
	Transmit(ctx context.Context, in *TransmitRequest, opts ...grpc.CallOption) (*TransmitReply, error)
	LatestConfigDigestAndEpoch(ctx context.Context, in *LatestConfigDigestAndEpochRequest, opts ...grpc.CallOption) (*LatestConfigDigestAndEpochReply, error)
	FromAccount(ctx context.Context, in *FromAccountRequest, opts ...grpc.CallOption) (*FromAccountReply, error)
}

type contractTransmitterClient struct {
	cc grpc.ClientConnInterface
}

func NewContractTransmitterClient(cc grpc.ClientConnInterface) ContractTransmitterClient {
	return &contractTransmitterClient{cc}
}

func (c *contractTransmitterClient) Transmit(ctx context.Context, in *TransmitRequest, opts ...grpc.CallOption) (*TransmitReply, error) {
	out := new(TransmitReply)
	err := c.cc.Invoke(ctx, ContractTransmitter_Transmit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractTransmitterClient) LatestConfigDigestAndEpoch(ctx context.Context, in *LatestConfigDigestAndEpochRequest, opts ...grpc.CallOption) (*LatestConfigDigestAndEpochReply, error) {
	out := new(LatestConfigDigestAndEpochReply)
	err := c.cc.Invoke(ctx, ContractTransmitter_LatestConfigDigestAndEpoch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractTransmitterClient) FromAccount(ctx context.Context, in *FromAccountRequest, opts ...grpc.CallOption) (*FromAccountReply, error) {
	out := new(FromAccountReply)
	err := c.cc.Invoke(ctx, ContractTransmitter_FromAccount_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ContractTransmitterServer is the server API for ContractTransmitter service.
// All implementations must embed UnimplementedContractTransmitterServer
// for forward compatibility
type ContractTransmitterServer interface {
	Transmit(context.Context, *TransmitRequest) (*TransmitReply, error)
	LatestConfigDigestAndEpoch(context.Context, *LatestConfigDigestAndEpochRequest) (*LatestConfigDigestAndEpochReply, error)
	FromAccount(context.Context, *FromAccountRequest) (*FromAccountReply, error)
	mustEmbedUnimplementedContractTransmitterServer()
}

// UnimplementedContractTransmitterServer must be embedded to have forward compatible implementations.
type UnimplementedContractTransmitterServer struct {
}

func (UnimplementedContractTransmitterServer) Transmit(context.Context, *TransmitRequest) (*TransmitReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Transmit not implemented")
}
func (UnimplementedContractTransmitterServer) LatestConfigDigestAndEpoch(context.Context, *LatestConfigDigestAndEpochRequest) (*LatestConfigDigestAndEpochReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LatestConfigDigestAndEpoch not implemented")
}
func (UnimplementedContractTransmitterServer) FromAccount(context.Context, *FromAccountRequest) (*FromAccountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FromAccount not implemented")
}
func (UnimplementedContractTransmitterServer) mustEmbedUnimplementedContractTransmitterServer() {}

// UnsafeContractTransmitterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ContractTransmitterServer will
// result in compilation errors.
type UnsafeContractTransmitterServer interface {
	mustEmbedUnimplementedContractTransmitterServer()
}

func RegisterContractTransmitterServer(s grpc.ServiceRegistrar, srv ContractTransmitterServer) {
	s.RegisterService(&ContractTransmitter_ServiceDesc, srv)
}

func _ContractTransmitter_Transmit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransmitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractTransmitterServer).Transmit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractTransmitter_Transmit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractTransmitterServer).Transmit(ctx, req.(*TransmitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractTransmitter_LatestConfigDigestAndEpoch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LatestConfigDigestAndEpochRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractTransmitterServer).LatestConfigDigestAndEpoch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractTransmitter_LatestConfigDigestAndEpoch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractTransmitterServer).LatestConfigDigestAndEpoch(ctx, req.(*LatestConfigDigestAndEpochRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractTransmitter_FromAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FromAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractTransmitterServer).FromAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractTransmitter_FromAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractTransmitterServer).FromAccount(ctx, req.(*FromAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ContractTransmitter_ServiceDesc is the grpc.ServiceDesc for ContractTransmitter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ContractTransmitter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.ContractTransmitter",
	HandlerType: (*ContractTransmitterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Transmit",
			Handler:    _ContractTransmitter_Transmit_Handler,
		},
		{
			MethodName: "LatestConfigDigestAndEpoch",
			Handler:    _ContractTransmitter_LatestConfigDigestAndEpoch_Handler,
		},
		{
			MethodName: "FromAccount",
			Handler:    _ContractTransmitter_FromAccount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "relayer.proto",
}

const (
	Service_Name_FullMethodName         = "/loop.Service/Name"
	Service_Close_FullMethodName        = "/loop.Service/Close"
	Service_Ready_FullMethodName        = "/loop.Service/Ready"
	Service_HealthReport_FullMethodName = "/loop.Service/HealthReport"
)

// ServiceClient is the client API for Service service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ServiceClient interface {
	Name(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*NameReply, error)
	Close(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Ready(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	HealthReport(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*HealthReportReply, error)
}

type serviceClient struct {
	cc grpc.ClientConnInterface
}

func NewServiceClient(cc grpc.ClientConnInterface) ServiceClient {
	return &serviceClient{cc}
}

func (c *serviceClient) Name(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*NameReply, error) {
	out := new(NameReply)
	err := c.cc.Invoke(ctx, Service_Name_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceClient) Close(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Service_Close_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceClient) Ready(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Service_Ready_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceClient) HealthReport(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*HealthReportReply, error) {
	out := new(HealthReportReply)
	err := c.cc.Invoke(ctx, Service_HealthReport_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServiceServer is the server API for Service service.
// All implementations must embed UnimplementedServiceServer
// for forward compatibility
type ServiceServer interface {
	Name(context.Context, *emptypb.Empty) (*NameReply, error)
	Close(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	Ready(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	HealthReport(context.Context, *emptypb.Empty) (*HealthReportReply, error)
	mustEmbedUnimplementedServiceServer()
}

// UnimplementedServiceServer must be embedded to have forward compatible implementations.
type UnimplementedServiceServer struct {
}

func (UnimplementedServiceServer) Name(context.Context, *emptypb.Empty) (*NameReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Name not implemented")
}
func (UnimplementedServiceServer) Close(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Close not implemented")
}
func (UnimplementedServiceServer) Ready(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ready not implemented")
}
func (UnimplementedServiceServer) HealthReport(context.Context, *emptypb.Empty) (*HealthReportReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthReport not implemented")
}
func (UnimplementedServiceServer) mustEmbedUnimplementedServiceServer() {}

// UnsafeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServiceServer will
// result in compilation errors.
type UnsafeServiceServer interface {
	mustEmbedUnimplementedServiceServer()
}

func RegisterServiceServer(s grpc.ServiceRegistrar, srv ServiceServer) {
	s.RegisterService(&Service_ServiceDesc, srv)
}

func _Service_Name_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).Name(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Service_Name_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).Name(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Service_Close_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).Close(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Service_Close_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).Close(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Service_Ready_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).Ready(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Service_Ready_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).Ready(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Service_HealthReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).HealthReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Service_HealthReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).HealthReport(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Service_ServiceDesc is the grpc.ServiceDesc for Service service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Service_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.Service",
	HandlerType: (*ServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Name",
			Handler:    _Service_Name_Handler,
		},
		{
			MethodName: "Close",
			Handler:    _Service_Close_Handler,
		},
		{
			MethodName: "Ready",
			Handler:    _Service_Ready_Handler,
		},
		{
			MethodName: "HealthReport",
			Handler:    _Service_HealthReport_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "relayer.proto",
}
