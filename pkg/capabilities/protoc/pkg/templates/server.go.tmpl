package server

import (
    "context"
    "time"

    {{- range .Services }}
        {{- range .Methods }}
            {{- addImport .Input.GoIdent.GoImportPath "" }}
            {{- addImport .Output.GoIdent.GoImportPath "" }}
        {{- end }}
    {{- end }}

    {{- range allimports }}
    {{.}}
    {{- end }}

    "github.com/smartcontractkit/chainlink-common/pkg/types/core"
    "github.com/smartcontractkit/chainlink-common/pkg/capabilities"
)

{{- range .Services}}
{{ $hasTriggers := false }}
{{ $hasActions := false }}
{{ $service := . }}
type {{.GoName}}Capability interface {
    {{- range .Methods}}
        {{- if isTrigger . }}
            {{ $hasTriggers = true }}
    Register{{.GoName}}(ctx context.Context, metadata capabilities.RequestMetadata, input *{{name .Input.GoIdent ""}}) (<- chan capabilities.TriggerAndId[*{{name .Output.GoIdent ""}}], error)
    Unregister{{.GoName}}(ctx context.Context, metadata capabilities.RequestMetadata, input *{{name .Input.GoIdent ""}}) error
        {{- else }}
            {{ $hasActions = true }}
    {{.GoName}}(ctx context.Context, metadata capabilities.RequestMetadata, input *{{name .Input.GoIdent ""}}, /* TODO  config {{name .Input.GoIdent ""}}*/) (*{{name .Output.GoIdent ""}}, error)
    Register{{.GoName}}(ctx context.Context, metadata capabilities.RegistrationMetadata/* TODO config */) error
    Unregister{{.GoName}}(ctx context.Context, metadata capabilities.RegistrationMetadata/* TODO config */) error
        {{- end }}
    {{- end }}
    Start(ctx context.Context) error
    Close() error
    HealthReport() map[string]error
    Name() string
    Description() string
    Ready() error
    Initialise(ctx context.Context, config string, telemetryService core.TelemetryService, store core.KeyValueStore, errorLog core.ErrorLog, pipelineRunner core.PipelineRunnerService, relayerSet core.RelayerSet, oracleFactory core.OracleFactory) error
}

func New{{.GoName}}Server(capability {{.GoName}}Capability) loop.StandardCapabilities {
    return &{{.GoName|LowerFirst}}Server{
        {{.GoName|LowerFirst}}Capability:   {{.GoName|LowerFirst}}Capability{ {{.GoName}}Capability: capability},
    }
}

type {{.GoName|LowerFirst}}Server struct {
    {{.GoName|LowerFirst}}Capability
    capabilityRegistry core.CapabilitiesRegistry
}


func (cs *{{.GoName|LowerFirst}}Server) Initialise(ctx context.Context, config string, telemetryService core.TelemetryService, store core.KeyValueStore, capabilityRegistry core.CapabilitiesRegistry, errorLog core.ErrorLog, pipelineRunner core.PipelineRunnerService, relayerSet core.RelayerSet, oracleFactory core.OracleFactory) error {
    if err := cs.{{.GoName}}Capability.Initialise(ctx, config, telemetryService, store, errorLog, pipelineRunner, relayerSet, oracleFactory); err != nil {
        return fmt.Errorf("error when initializing capability: %w", err)
    }

    cs.capabilityRegistry = capabilityRegistry

	if err := capabilityRegistry.Add(ctx, &{{.GoName|LowerFirst}}Capability{
	    {{.GoName}}Capability: cs.{{.GoName}}Capability,
	}); err != nil {
		return fmt.Errorf("error when adding kv store action to the registry: %w", err)
	}

	return nil
}

func (cs *{{.GoName|LowerFirst}}Server) Close() error{
    ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()
    if err := cs.capabilityRegistry.Remove(ctx, "{{$.CapabilityId}}"); err != nil {
		return err
	}

	return cs.{{.GoName|LowerFirst}}Capability.Close()
}


func (cs *{{.GoName|LowerFirst}}Server) Infos(ctx context.Context) ([]capabilities.CapabilityInfo, error) {
    // TODO if we get rid of targets in favour of actions that return empty proto, do we need Consensus stil?
    info, err := cs.{{.GoName|LowerFirst}}Capability.Info(ctx)
    if err != nil {
        return nil, err
    }
    return []capabilities.CapabilityInfo{info}, nil
}

type {{.GoName|LowerFirst}}Capability struct {
    {{.GoName}}Capability
}

func (c *{{.GoName|LowerFirst}}Capability) Info(ctx context.Context) (capabilities.CapabilityInfo, error) {
    // TODO this is problematic right not because we can do both...?
    // Maybe we do need to split it out, even if the user doesn't see it
	return capabilities.NewCapabilityInfo("{{$.CapabilityId}}", capabilities.CapabilityTypeAction, c.{{.GoName}}Capability.Description())
}

{{- if $hasTriggers }}
var _ capabilities.TriggerCapability = (*{{.GoName|LowerFirst}}Capability)(nil)
func (c *{{.GoName|LowerFirst}}Capability) RegisterTrigger(ctx context.Context, request capabilities.TriggerRegistrationRequest) (<-chan capabilities.TriggerResponse, error) {
    switch request.Method {
        {{- range .Methods}}
        {{- if (isTrigger .) }}
            case "{{.GoName}}":
                input := &{{name .Input.GoIdent ""}}{}
                return capabilities.RegisterTrigger(ctx, "{{$.CapabilityId}}", request, input, c.{{$service.GoName}}Capability.Register{{.GoName}})
        {{- end }}
        {{- end }}
        	default:
        	    return nil, fmt.Errorf("method %s not found", request.Method)
        }

}

func (c *{{.GoName|LowerFirst}}Capability) UnregisterTrigger(ctx context.Context, request capabilities.TriggerRegistrationRequest) error {
	    switch request.Method {
            {{- range .Methods}}
            {{- if (isTrigger .) }}
                case "{{.GoName}}":
                    input := &{{name .Input.GoIdent ""}}{}
                    _, err := capabilities.FromValueOrAny(request.Config, request.Request, input)
                    if err != nil {
                        return err
                    }
                    return c.{{$service.GoName}}Capability.Unregister{{.GoName}}(ctx, request.Metadata, input)
            {{- end }}
            {{- end }}
            	default:
            	    return fmt.Errorf("method %s not found", request.Method)
            }
}
{{- end }}

{{- if $hasActions }}
var _ capabilities.ActionCapability = (*{{.GoName|LowerFirst}}Capability)(nil)


func (c *{{.GoName|LowerFirst}}Capability) RegisterToWorkflow(ctx context.Context, request capabilities.RegisterToWorkflowRequest) error {
	//TODO implement me
	panic("implement me")
}

func (c *{{.GoName|LowerFirst}}Capability) UnregisterFromWorkflow(ctx context.Context, request capabilities.UnregisterFromWorkflowRequest) error {
	//TODO implement me
	panic("implement me")
}

func (c *{{.GoName|LowerFirst}}Capability) Execute(ctx context.Context, request capabilities.CapabilityRequest) (capabilities.CapabilityResponse, error) {
    response := capabilities.CapabilityResponse{}
	switch request.Method {
    {{- range .Methods}}
    {{- if  not (isTrigger .) }}
        case "{{.GoName}}":
            input := &{{name .Input.GoIdent ""}}{}
            // TODO config
            return capabilities.Execute(ctx, request, input, c.{{$service.GoName}}Capability.{{.GoName}})
    {{- end }}
    {{- end }}
    	default:
    	    return response, fmt.Errorf("method %s not found", request.Method)
    }
}

{{- end }}
{{- end }}